#!/usr/bin/env python
# $Id$
##
## This file is part of pyFormex 0.2.1 Release Fri Apr  8 23:30:39 2005
## pyFormex is a python implementation of Formex algebra
## Homepage: http://pyformex.berlios.de/
## Distributed under the GNU General Public License, see file COPYING
## Copyright (C) Benedict Verhegghe except where otherwise stated 
##
"""pyformex is a python implementation of Formex algebra"""

Version="pyFormex 0.2-20050313"

from formex import *
from canvas import *
from widgets import *

import sys,time,os.path,string
import threading
import qt


global config
config={}

global out   # holds the last drawn Formex
out=None


def debug(s):
    global options
    if options.debug:
        print s

def askPreferences(list):
    global config
    items = [ [ it,config.setdefault(it,"") ] for it in list ]
    #items = [ [ it,val,type(val) ] for it,val in items ]
    print "Asking Prefs ",items
    res = ConfigDialog(items).process()
    for r in res:
        config[r[0]] = r[1]
    print config

def prefSleeptime():
    askPreferences(['sleeptime'])

def preferences():
    test = [["item1","value1"],
            ["item2",""],
            ["an item with a long name","and a very long value for this item, just to test the scrolling"]]
    d = ConfigDialog(test)
    res = d.process()
    print res

def AddMenuItems(menu, items=[]):
    """Add a list of items to a menu.

    Each item is a tuple of three strings : Type, Text, Value.
    Type specifies the menu item type and must be one of
    'Sep', 'Popup', 'Action', 'VAction', 'QAction'.
    
    'Sep' is a separator item. Its Text and Value fields are not used.
    
    For the other types, Text is the string that will be displayed in the
    menu. It can include a '&' character to flag the hotkey.
    
    'Popup' is a popup submenu item. Its value should be an item list,
    defining the menu to pop up when activated.
    
    'Action' is an active item. Its value is a python function that will be
    executed when the item is activated. It should be a global function
    without arguments.
    
    'VAction' is an active item where the value is a tuple of an function
    and an integer argument. When activated, the function will be executed
    with the specified argument. With 'Vaction', you can bind multiple
    menu items to the same function.

    'QAction' signals that the value is a qt QAction. It is advisable to
    construct a QAction if you have to use the sameaction at more than one
    place of your program. With this type Text may be None, if it was already
    set in the QAction itself.
    """
    for key,txt,val in items:
        if key == "Sep":
            menu.insertSeparator()
        elif key == "Popup":
            pop = qt.QPopupMenu(menu,txt)
            AddMenuItems(pop,val)
            menu.insertItem(txt,pop)
        elif key == "Action":
            menu.insertItem(txt,eval(val))
        elif key == "VAction":
            id = menu.insertItem(txt,eval(val[0]))
            menu.setItemParameter(id,val[1])
        elif key == "Statement":
            menu.insertItem(txt,val)
        elif key == "QAction":
            if txt:
                val.setProperty("menuText",qt.QVariant(txt))
            val.addTo(menu)
        else:
            raise RuntimeError, "Invalid key %s in menu item"%key

MenuData = [
    ("Popup","&File",[
        ("Action","&Save","save"),
        ("Action","Save &As","saveAs"),
        ("Action","Save &Image","saveImage"),
        ("Sep",None,None),
        ("Action","&Play","play"),
        ("Action","&Record","record"),
        ("Sep",None,None),
        ("Action","E&xit","exit"), ]),
    ("Popup","&Settings",[
        ("Action","&Preferences","preferences"), 
        ("Action","&Sleep Time","prefSleeptime"), 
        ("Action","&LocalAxes","localAxes"),
        ("Action","&GlobalAxes","globalAxes"),
        ("Action","&Wireframe","wireframe"),
        ("Action","&Smooth","smooth"), ]),
    ("Popup","&Camera",[
        ("Action","&Zoom In","zoomIn"), 
        ("Action","&Zoom Out","zoomOut"), 
        ("Action","&Dolly In","dollyIn"), 
        ("Action","&Dolly Out","dollyOut"), 
        ("Action","Pan &Right","transRight"), 
        ("Action","Pan &Left","transLeft"), 
        ("Action","Pan &Up","transUp"),
        ("Action","Pan &Down","transDown"),
        ("Action","Rotate &Right","rotRight"),
        ("Action","Rotate &Left","rotLeft"),
        ("Action","Rotate &Up","rotUp"),
        ("Action","Rotate &Down","rotDown"),  ]),
    ("Popup","&Actions",[
        ("Action","&Wakeup","wakeup"),
        ("Action","&Kill","kill"), 
        ("Action","&Killall","killall"),
        ("Action","&Clear","clear"),
        ("Action","&Redraw","redraw"),
        ("Action","&ListAll","listall"),
        ("Action","&Print","printit"),
        ("Action","&Bbox","printbbox"),
        ("Action","&Globals","printglobals"),  ]),
    ("Popup","&Help",[
        ("Action","&Help","showHelp"),
        ("Action","&About","about"), 
        ("Action","&Warning","testwarning"), ]) ]

# Examples Menu
def insertExampleMenu():
    """Insert the examples menu in the menudata."""
    global config,example
    dir = os.path.join(config['pyformexdir'],"examples")
    if os.path.isdir(dir):
        example = filter(lambda s:s[-3:]==".py" and s[0]!='.',os.listdir(dir))
    example.sort()
    vm = ("Popup","&Examples",[
        ("VAction","&%s"%os.path.splitext(t)[0],("runExample",i)) for i,t in enumerate(example)
        ])
    nEx = len(vm[2])
    vm[2].append(("VAction","Run All Examples",("runExamples",nEx)))
    MenuData.insert(4,vm)

def runExample(i):
    """Run example i from the list of found examples."""
    global config,example
    playFile(os.path.join(config['pyformexdir'],"examples",example[i]))

def runExamples(n):
    """Run the first n examples."""
    for i in range(n):
        runExample(i)

# add action buttons to toolbar
def addActionButtons():
    global config,tool,action
    action = {}
    dir = config['icondir']
    buttons = [ [ "Step", "next.xbm", wakeup, False ],
                [ "Continue", "ff.xbm", kill, False ],
              ]
    for b in buttons:
        a = qt.QAction(b[0],qt.QIconSet(qt.QPixmap(os.path.join(dir,b[1]))),b[1],0,tool)
        qt.QObject.connect(a,qt.SIGNAL("activated()"),b[2])
        a.addTo(tool)
        a.setEnabled(b[3])
        action[b[0]] = a

# add camera buttons to toolbar (repeating)
def addCameraButtons():
    global config,tool
    dir = config['icondir']
    buttons = [ [ "Rotate left", "rotleft.xbm", rotLeft ],
                [ "Rotate right", "rotright.xbm", rotRight ],
                [ "Rotate up", "rotup.xbm", rotUp ],
                [ "Rotate down", "rotdown.xbm", rotDown ],
                [ "Twist left", "twistleft.xbm", twistLeft ],
                [ "Twist right", "twistright.xbm", twistRight ],
                [ "Translate left", "left.xbm", transLeft ],
                [ "Translate right", "right.xbm", transRight ],
                [ "Translate down", "down.xbm", transDown ],
                [ "Translate up", "up.xbm", transUp ],
                [ "Zoom In", "zoomin.xbm", zoomIn ],
                [ "Zoom Out", "zoomout.xbm", zoomOut ],  ]
    for b in buttons:
        w = qt.QToolButton(qt.QIconSet(qt.QPixmap(os.path.join(dir,b[1]))),b[0],"",b[2],tool)
        w.setAutoRepeat(True)

###################### Views #############################################
# Views are different camera postitions from where to view the structure.
# They can be activated from menus, or from the  view toolbox
# A number of views are predefined in the canvas class
# Any number of new views can be created, deleted, changed.
# Each view is identified by a string
    
def view(v):
    """Show a named view, either a builtin or a user defined."""
    global canvas
    if canvas.views.has_key(v):
        canvas.setView(None,v)
        canvas.update()
    else:
        warning("A view named '%s' has not been created yet" % v)
  
def initViewActions(viewlist):
    """Create the initial set of view actions."""
    global views
    views = []
    for name in viewlist:
        icon = name+"view.xbm"
        Name = string.capitalize(name)
        tooltip = Name+" View"
        menutext = "&"+Name
        createViewAction(name,icon,tooltip,menutext)

def createViewAction(name,icon,tooltip,menutext):
    """Creates a view action and adds it to the menu and/or toolbar.

    The view action is a MyQAction which sends the name when activated.
    It is added to the viewsMenu and/or the viewsBar if they exist.
    The toolbar button has icon and tooltip. The menu item has menutext. 
    """
    global config,views,viewsMenu,viewsBar,gui
    dir = config['icondir']
    a = MyQAction(name,tooltip,qt.QIconSet(qt.QPixmap(os.path.join(dir,icon))),menutext,0,gui)
    qt.QObject.connect(a,qt.PYSIGNAL("Clicked"),view)
    views.append(name)
    if viewsMenu:
        a.addTo(viewsMenu)
    if viewsBar:
        a.addTo(viewsBar)
 
def addView(name,angles,icon="userview.xbm",tooltip=None,menutext=None):
    """Add a new view to the list of predefined views.

    This creates a new named view with specified angles for the canvas.
    It also creates a MyQAction which sends the name when activated, and
    adds the MyQAction to the viewsMenu and/or the viewsBar if they exist.
    """
    global views,viewsMenu,viewsBar,canvas,gui
    if tooltip == None:
        tooltip = name
    if menutext == None:
        menutext == name
    dir = config['icondir']
    canvas.createView(name,angles)
    createViewAction(name,icon,tooltip,menutext)


###################### Actions #############################################
# Actions are just python functions, preferably without arguments
# Actions are often used as slots, which are triggered by signals,
#   e.g. by clicking a menu item or a tool button.
# Since signals have no arguments:
# Can we use python functions with arguments as actions ???
# - In menus we can have the menuitems send an integer id.
# - For other cases (like toolbuttons), we can subclass QAction and let it send
#   a signal with appropriate arguments 


def NotImplemented():
    warning("This option has not been implemented yet!")
    
save = NotImplemented
saveAs = NotImplemented
record = NotImplemented

global help
help = None
def showHelp():
    """Start up the help browser"""
    global help
    from helpviewer import HelpViewer
    print "help = ",help
    if help == None:
        dir = os.path.join(config['docdir'],"html")
        home = os.path.join(dir,"formex.html")
        print "Help file = ",home
        help = HelpViewer(home, dir,bookfile=config['helpbookmarks'])
        help.setCaption("pyFormex - Helpviewer")
        help.setAbout("pyFormex Help", \
                  "This is the pyFormex HelpViewer.<p>It was modeled after the HelpViewer example " \
                  "from the Qt documentation.</p>")
        #help.resize(800,600)
        help.connect(help,qt.SIGNAL("destroyed()"),closeHelp)
    help.show()

def closeHelp():
    """Close the help browser"""
    global help
    help = None
        

def about():
    about = qt.QMessageBox()
    about.about(about,"About pyFormex",
        Version+"\n\n"
        "pyFormex is a python implementation of Formex algebra\n\n"
        "http://pyformex.berlios.de\n\n"
        "Copyright 2004 Benedict Verhegghe\n"
        "Distributed under the GNU General Public License.\n\n"
        "For help or information, mailto benedict.verhegghe@ugent.be\n" )

def testwarning():
    warning("Smoking may be hazardous to your health!")
def warning(s):
    global options
    if options.gui:
        w = qt.QMessageBox()
        w.warning(w,Version,s)
    else:
        print s


def saveImage():
    """Save the current rendering in image format."""
    global canvas
    fs = FileSelectionDialog(pattern="Images (*.png *.jpg)",mode=qt.QFileDialog.AnyFile)
    fn = fs.getFilename()
    if fn:
        fmt = string.upper(os.path.splitext(fn)[1])
        if len(fmt) > 0 and fmt[0] == '.':
            fmt = fmt[1:]
            if fmt == 'JPG':
                fmt = 'JPEG'
        else:
            fmt = 'PNG'
            fn += '.png'
        if fmt in qt.QImage.outputFormats():
            canvas.save(fn,fmt)
        else:
            warning("Sorry, can not save in %s format!\n"
                    "Suggest you use PNG format ;)"%fmt)


def play():
    fs = FileSelectionDialog(".","pyformex scripts (*.frm *.py)")
    fn = fs.getFilename()
    if fn:
        playFile(fn)
def printit():
    global out
    print out
def printbbox():
    global out
    if out:
        print "bbox of displayed Formex",out.bbox()
def printglobals():
    print globals()

def zoomIn():
    global canvas,config
    canvas.zoom(1./config['zoomfactor'])
    canvas.update()
def zoomOut():
    global canvas,config
    canvas.zoom(config['zoomfactor'])
    canvas.update()
##def panRight():
##    global canvas,config
##    canvas.camera.pan(+5)
##    canvas.update()   
##def panLeft():
##    global canvas,config
##    canvas.camera.pan(-5)
##    canvas.update()   
##def panUp():
##    global canvas,config
##    canvas.camera.pan(+5,0)
##    canvas.update()   
##def panDown():
##    global canvas,config
##    canvas.camera.pan(-5,0)
##    canvas.update()   
def rotRight():
    global canvas,config
    canvas.camera.rotate(+config['rotfactor'],0,1,0)
    canvas.update()   
def rotLeft():
    global canvas,config
    canvas.camera.rotate(-config['rotfactor'],0,1,0)
    canvas.update()   
def rotUp():
    global canvas,config
    canvas.camera.rotate(-config['rotfactor'],1,0,0)
    canvas.update()   
def rotDown():
    global canvas,config
    canvas.camera.rotate(+config['rotfactor'],1,0,0)
    canvas.update()   
def twistLeft():
    global canvas,config
    canvas.camera.rotate(+config['rotfactor'],0,0,1)
    canvas.update()   
def twistRight():
    global canvas,config
    canvas.camera.rotate(-config['rotfactor'],0,0,1)
    canvas.update()   
def transLeft():
    global canvas,config
    canvas.camera.translate(-config['panfactor'],0,0,config['localaxes'])
    canvas.update()   
def transRight():
    global canvas,config
    canvas.camera.translate(config['panfactor'],0,0,config['localaxes'])
    canvas.update()   
def transDown():
    global canvas,config
    canvas.camera.translate(0,-config['panfactor'],0,config['localaxes'])
    canvas.update()   
def transUp():
    global canvas,config
    canvas.camera.translate(0,config['panfactor'],0,config['localaxes'])
    canvas.update()   
def dollyIn():
    global canvas,config
    canvas.camera.dolly(1./config['zoomfactor'])
    canvas.update()   
def dollyOut():
    global canvas,config
    canvas.camera.dolly(config['zoomfactor'])
    canvas.update()   

def frontView():
    view("front");
def backView():
    view("back");
def leftView():
    view("left");
def rightView():
    view("right");
def topView():
    view("top");
def bottomView():
    view("bottom");
def isoView():
    view("iso");
# JUST TESTING:
def userView(i=1):
    if i==1:
        frontView()
    else:
        isoView()

def clear():
    """Remove all actors from the canvas"""
    global canvas,out
    canvas.removeAllActors()
    canvas.clear()
    out = None
def wireframe():
    global canvas
    canvas.glinit("wireframe")
    canvas.redrawAll()
def smooth():
    global canvas
    canvas.glinit("render")
    canvas.redrawAll()
def redraw():
    global canvas
    canvas.redrawAll()

### draw now draws in color by default.
### use draw(...,color=None) to draw in black, like the old function did    
    
def draw(F,side='front',color="prop"):
    """Draw a Formex on the canvas.

    This draws an actor on the canvas, and directs the camera to it from
    the specified side. Default is looking in the -z direction.
    Specifying side=None leaves the camera settings unchanged.
    If other actors are on the scene, they may be visible as well.
    Clear the canvas before drawing if you only want one actor!

    If the Formex has properties and a color list is specified, then the
    the properties will be used as an index in the color list and each member
    will be drawn with the resulting color.
    If color is one color value, the whole Formex will be drawn with
    that color.
    Finally, is color=None is specified, the whole Formex is
    drawn in black.
    """
    global canvas,out,config
    out = F
    if F.p == None or color==None:
        # use the Formex directly as actor
        canvas.addActor(FormexActor(F))
    else:
        # create actors for each color value
        color=config['propcolors']
        for v in F.propSet():
            f = F.hasProp(v)
            i = v % len(color)
            canvas.addActor(FormexActor(f,color[i]))
    if side:
        canvas.setView(F.bbox(),side)
    # If side == None we still should calculate the bbox and zoom accordingly
    canvas.update()

    
def execFile(fn):
    """Play a pyformex script from file fn."""
    execScript(file(fn))
    
def execScript(scr):
    """Play a pyformex script scr. scr should be a valid Python text.

    This function executes the script with 
    """
    g = globals()
    g.update(Formex.globals())
    exec scr in g

def playFile(fn,name=None):
    """Play a formex script from file fn."""
    playScript(file(fn,'r'),fn)

wakeupMode=0  # 0 = sleeping allowed, 1 = stay awake for this script
              # 2 = always stay awake, 3 = stay awake and exit at end of script
scriptLock = threading.Lock()
timer = None
    
def playScript(scr,name="unnamed"):
    """Play a pyformex script scr. scr should be a valid Python text.

    If a second parameter is given, it will be displayed on the status line.
    This is different from execScript in that it starts a new thread,
    enabling the script to be killed.
    """
    global canvas,scriptLock,wakeupMode
    # Try to acquire the scriptLock, if not: return immediately
    # (We only allow one script executing at a time!)
    if not scriptLock.acquire(False):
        return
    message("Running script (%s)" % name)
    canvas.update()
    # We need to pass formex globals to the script
    # This would be done automatically if we put this function
    # in the formex.py file. But hen we need to pass other globals
    # from this file (like draw,...)
    # We might create a module with all operations accepted in
    # scripts.
    g = globals()
    g.update(Formex.globals())
    try:
        exec scr in g
    finally:
        scriptLock.release() # release the lock in case of an error
    message("Finished script")
    if wakeupMode > 2:
        exit()
    if wakeupMode < 2:
        wakeupMode = 0

# The sleep functionality has some problems which needs to be solved:
# If a script is played and enters in sleep mode, and the user does not wake
# it up before the next script is played, both get intermixed.
# Also, if a script is unfinished, and you try to close the program,
# It hangs.
# Therefore, it would be good to have some kill() function to cancel
# hanging scripts.

def sleep(timeout=None):
    """Sleep until key/mouse press in the canvas or until timeout"""
    global sleeping,wakeupMode,timer,app,action
    if wakeupMode > 0: # don't bother
        return
    # prepare for getting wakeup event 
    qt.QObject.connect(canvas,qt.PYSIGNAL("wakeup"),wakeup)
    # create a Timer to wakeup after timeout
    if timeout == None:
        timeout = max(0,int(config['sleeptime']))
    if timeout:
        timer = threading.Timer(timeout,wakeup)
        timer.start()
    else:
        timer = None
    # go into sleep mode
    sleeping = True
    action['Step'].setEnabled(True)
    action['Continue'].setEnabled(True)
    ## while sleeping, we have to process events
    ## (we could start another thread for this)
    while sleeping:
        app.processEvents()
        time.sleep(0.1)
    action['Step'].setEnabled(False)
    action['Continue'].setEnabled(False)
    # ignore further wakeup events
    qt.QObject.disconnect(canvas,qt.PYSIGNAL("wakeup"),wakeup)
        
def wakeup(mode=0):
    """Wake up from the sleep function.

    This is the only way to exit the sleep() function.
    Default is to wake up from the current sleep. A mode > 0
    forces wakeup for longer period.
    """
    global timer,sleeping,wakeupMode
    if timer:
        timer.cancel()
    sleeping = False
    wakeupMode = mode

def kill():
    """Kill the current script"""
    ## For now, this just wakes up the cript to let it finish
    ## We really should implement a kill, e.g. bny raising a user
    ## exception, which is caught by the playScript function
    wakeup(1)

def killall():
    """Kill the current and all subsequent scripts"""
    wakeup(2)
    

def setSleepTime(t):
    """Set the time to wait during a sleep() operation.

    The sleep time is specified in seconds. A zero value means
    sleep indefinitely.
    """
    global config
    config['sleeptime'] = t


def listall():
    """List all Formices in globals()"""
    print "Formices currently in globals():"
    for n,t in globals().items():
        if isinstance(t,Formex):
            print "%s, " % n
     

def localAxes():
    global config
    config['localaxes'] = True 
def globalAxes():
    global config
    config['localaxes'] = False 



def exit():
    global app,scriptLock,app_started
    #debug("exit()")
    if app and app_started:
        if scriptLock.acquire(False): # try to acquire script lock
            #debug("app.quit()")
            app.quit()  # exit on success (no script running)
        else:
            #debug("wakeup(3)")
            wakeup(3) # return to let the script finish, then exit
    else: # the gui didn't even start
        #debug("sys.exit()")
        sys.exit(0)

def message(s):
    """Display a permanent message in the status line."""
    global theMessage
    theMessage.setText(qt.QString(s))

###########################  GUI, app  ################################
def GUI():
    """Constructs the GUI.

    The GUI has a central canvas for drawing, a menubar and a toolbar
    on top, and a statusbar at the bottom.
    """
    global canvas,statusbar,theMessage,menu,tool, options,config,views,gui,viewsMenu,viewsBar
    wd,ht = (config['width'],config['height'])
    w = qt.QMainWindow()
    w.setCaption(Version)
    w.resize(wd,ht)
    # add widgets to the main window
    statusbar = w.statusBar()
    theMessage = qt.QLabel(statusbar)
    statusbar.addWidget(theMessage)
    message(Version+" (c) B. Verhegghe")
    menu = w.menuBar()
    tool = qt.QToolBar(w)
    # Create an OpenGL canvas with a nice frame around it
    f = qt.QHBox(w)
    f.setFrameStyle(qt.QFrame.Sunken | qt.QFrame.Panel)
    f.setLineWidth(2)
    f.resize(wd,ht)
    fmt = qtgl.QGLFormat.defaultFormat()
    fmt.setDirectRendering(options.dri)
    canvas = Canvas(wd,ht,fmt,f)
    w.setCentralWidget(f)
    # Populate the menu ...
    insertExampleMenu()
    AddMenuItems(menu,MenuData)
    # ... and the toolbar
    addActionButtons()
    if config.setdefault('camerabuttons',True):
        addCameraButtons()
    if config.setdefault('viewsmenu',True):
        viewsMenu = qt.QPopupMenu(menu)
        menu.insertItem('View',viewsMenu,-1,2)
    if config.setdefault('viewsbar',True):
        viewsBar = qt.QToolBar("Views",w)
    gui = w
    # Create View Actions for the default views provided by the canvas
    initViewActions(config.setdefault('builtinviews',['front','back','left','right','top','bottom','iso']))
    return w

def runApp(args):
    """Create and run the qt application."""
    global app,gui,app_started
    app = qt.QApplication(args)
    qt.QObject.connect(app,qt.SIGNAL("lastWindowClosed()"),app,qt.SLOT("quit()"))
    # create GUI, show it, run it
    gui = GUI()
    app.setMainWidget(gui)
    gui.show()
    options.gui = True
    # remaining args are interpreted as scripts
    app_started = False
    for arg in args:
        if os.path.exists(arg):
            playFile(arg)
    app_started = True
    app.exec_loop()

###########################  main  ################################
def main(argv=None):
    """This is a fairly generic main() function.

    It is responsible for reading the configuration file(s),
    processing the command line options and starting the application.
    """
    global options,config
    # this allows us to call main from the interpreter
    if argv is None:
        argv = sys.argv
    # set the path to the pyformex files
    config['pyformexdir'] = os.path.dirname(os.path.realpath(argv[0]))
    # Read the default config file
    f = os.path.join(config['pyformexdir'],"pyformexrc")
    execfile(f)
    #process options
    from optparse import OptionParser,make_option
    parser = OptionParser(
        usage = "usage: %prog [<options>] [ --  <Qapp-options> ]",
        version = Version,
        option_list=[
        make_option("--nodri", help="do not use Direct Rendering",
                    action="store_false", dest="dri", default=True),
        make_option("--debug", help="display logging info to sys.stdout",
                    action="store_true", dest="debug", default=False)
        ])
    (options, args) = parser.parse_args()
    # Read the available config files
    for f in ["/etc/pyformexrc", \
              os.path.join(os.environ['HOME'],".pyformexrc"), \
              ".pyformexrc", ]:
        if os.path.exists(f):
            execfile(f)
            break
    # Run the application
    return runApp(args)

#### deprecated functions (retained for compatibility)

def drawProp(F,side="front",color="prop"):
    print "drawProp() DEPRECATED: use draw() instead."
    draw(F,side,color)

#### Go

if __name__ == "__main__":
    sys.exit(main())

#### End
