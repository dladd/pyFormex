#!/usr/bin/env python
# $Id$
##
## This file is part of pyFormex 0.2 Release Mon Jan  3 14:54:38 2005
## pyFormex is a python implementation of Formex algebra
## Homepage: http://pyformex.berlios.de/
## Copyright (C) 2004 Benedict Verhegghe (benedict.verhegghe@ugent.be)
## Copyright (C) 2004 Bart Desloovere (bart.desloovere@telenet.be)
## Distributed under the General Public License, see file COPYING for details
##
"""pyformex is a python implementation of Formex algebra"""

Version="pyFormex 0.2-20050313"

from formex import *
from canvas import *

import sys,time,os.path,string
import threading
import qt


global config
config={}

global out   # holds the last drawn Formex
out=None

 
class MyQAction(qt.QAction):
    """A MyQAction is a QAction that sends a string as parameter when clicked."""
    def __init__(self,text,*args):
        qt.QAction.__init__(self,*args)
        self.signal = text
        self.connect(self,qt.SIGNAL("activated()"),self.activated)
    def activated(self):
        self.emit(qt.PYSIGNAL("Clicked"), (self.signal,))


class FileSelectionDialog(qt.QFileDialog):
    """A file selection dialog widget.

    You can specify a default path/filename that will be suggested
    initially.
    If a pattern is specified, only matching files will be shown.
    A pattern can be something like 'Images (*.png *.jpg)'.
    Default mode is to accept only existing files. You can specify
    any QFileDialog mode (e.g. QFileDialog.AnyFile to accept new files)
    
    """
    def __init__(self,default=None,pattern=None,mode=qt.QFileDialog.ExistingFile):
        qt.QFileDialog.__init__(self,default,pattern)
        self.setMode(mode)
        self.show()
    def getFilename(self):
        self.exec_loop()
        if self.result() == qt.QDialog.Accepted:
            return str(self.selectedFile())
        else:
            return None

def AddMenuItems(menu, items=[]):
    """Add a list of items to a menu.

    Each item is a tuple of three strings : Type, Text, Value.
    Type specifies the menu item type and must be one of
    'Sep', 'Popup', 'Action', 'VAction', 'QAction'.
    
    'Sep' is a separator item. Its Text and Value fields are not used.
    
    For the other types, Text is the string that will be displayed in the
    menu. It can include a '&' character to flag the hotkey.
    
    'Popup' is a popup submenu item. Its value should be an item list,
    defining the menu to pop up when activated.
    
    'Action' is an active item. Its value is a python function that will be
    executed when the item is activated. It should be a global function
    without arguments.
    
    'VAction' is an active item where the value is a tuple of an function
    and an integer argument. When activated, the function will be executed
    with the specified argument. With 'Vaction', you can bind multiple
    menu items to the same function.

    'QAction' signals that the value is a qt QAction. It is advisable to
    construct a QAction if you have to use the sameaction at more than one
    place of your program. With this type Text may be None, if it was already
    set in the QAction itself.
    """
    for key,txt,val in items:
        if key == "Sep":
            menu.insertSeparator()
        elif key == "Popup":
            pop = qt.QPopupMenu(menu,txt)
            AddMenuItems(pop,val)
            menu.insertItem(txt,pop)
        elif key == "Action":
            menu.insertItem(txt,eval(val))
        elif key == "VAction":
            id = menu.insertItem(txt,eval(val[0]))
            menu.setItemParameter(id,val[1])
        elif key == "Statement":
            menu.insertItem(txt,val)
        elif key == "QAction":
            if txt:
                val.setProperty("menuText",qt.QVariant(txt))
            val.addTo(menu)
        else:
            raise RuntimeError, "Invalid key %s in menu item"%key
        

MenuData = [
    ("Popup","&File",[
        ("Action","&Save","save"),
        ("Action","Save &As","saveAs"),
        ("Action","Save &Image","saveImage"),
        ("Sep",None,None),
        ("Action","&Play","play"),
        ("Action","&Record","record"),
        ("Sep",None,None),
        ("Action","E&xit","exit"), ]),
    ("Popup","&Settings",[
        ("Action","&SleepShort","sleepShort"), 
        ("Action","&SleepLong","sleepLong"), 
        ("Action","&SleepForever","sleepForever"),
        ("Action","&LocalAxes","localAxes"),
        ("Action","&GlobalAxes","globalAxes"),
        ("Action","&Wireframe","wireframe"),
        ("Action","&Smooth","smooth"), ]),
    ("Popup","&Camera",[
        ("Action","&Zoom In","zoomIn"), 
        ("Action","&Zoom Out","zoomOut"), 
        ("Action","&Dolly In","dollyIn"), 
        ("Action","&Dolly Out","dollyOut"), 
        ("Action","Pan &Right","transRight"), 
        ("Action","Pan &Left","transLeft"), 
        ("Action","Pan &Up","transUp"),
        ("Action","Pan &Down","transDown"),
        ("Action","Rotate &Right","rotRight"),
        ("Action","Rotate &Left","rotLeft"),
        ("Action","Rotate &Up","rotUp"),
        ("Action","Rotate &Down","rotDown"),  ]),
    ("Popup","&Actions",[
        ("Action","&Wakeup","wakeup"),
        ("Action","&Kill","kill"), 
        ("Action","&Killall","killall"),
        ("Action","&Clear","clear"),
        ("Action","&Redraw","redraw"),
        ("Action","&Print","printit"),
        ("Action","&Bbox","printbbox"),
        ("Action","&Globals","printglobals"),  ]),
    ("Popup","&Help",[
        ("Action","&Help","help"),
        ("Action","&About","about"), 
        ("Action","&Warning","testwarning"), ]) ]

# Examples Menu
def insertExampleMenu():
    """Insert the examples menu in the menudata."""
    global config,example
    dir = os.path.join(config['pyformexdir'],"examples")
    if os.path.isdir(dir):
        example = filter(lambda s:s[-3:]==".py" and s[0]!='.',os.listdir(dir))
    example.sort()
    vm = ("Popup","&Examples",[
        ("VAction","&%s"%os.path.splitext(t)[0],("runExample",i)) for i,t in enumerate(example)
        ])
    nEx = len(vm[2])
    vm[2].append(("VAction","Run All Examples",("runExamples",nEx)))
    MenuData.insert(4,vm)

def runExample(i):
    """Run example i from the list of found examples."""
    global config,example
    playFile(os.path.join(config['pyformexdir'],"examples",example[i]))


def runExamples(n):
    """Run the first n examples."""
    for i in range(n):
        runExample(i)

# add action buttons to toolbar
def addActionButtons():
    global config,tool,action
    action = {}
    dir = config['icondir']
    buttons = [ [ "Step", "next.xbm", wakeup, False ],
                [ "Continue", "ff.xbm", kill, False ],
              ]
    for b in buttons:
        a = qt.QAction(b[0],qt.QIconSet(qt.QPixmap(os.path.join(dir,b[1]))),b[1],0,tool)
        qt.QObject.connect(a,qt.SIGNAL("activated()"),b[2])
        a.addTo(tool)
        a.setEnabled(b[3])
        action[b[0]] = a

# add camera buttons to toolbar (repeating)
def addCameraButtons():
    global config,tool
    dir = config['icondir']
    buttons = [ [ "Rotate left", "rotleft.xbm", rotLeft ],
                [ "Rotate right", "rotright.xbm", rotRight ],
                [ "Rotate up", "rotup.xbm", rotUp ],
                [ "Rotate down", "rotdown.xbm", rotDown ],
                [ "Twist left", "twistleft.xbm", twistLeft ],
                [ "Twist right", "twistright.xbm", twistRight ],
                [ "Translate left", "left.xbm", transLeft ],
                [ "Translate right", "right.xbm", transRight ],
                [ "Translate down", "down.xbm", transDown ],
                [ "Translate up", "up.xbm", transUp ],
                [ "Zoom In", "zoomin.xbm", zoomIn ],
                [ "Zoom Out", "zoomout.xbm", zoomOut ],  ]
    for b in buttons:
        w = qt.QToolButton(qt.QIconSet(qt.QPixmap(os.path.join(dir,b[1]))),b[0],"",b[2],tool)
        w.setAutoRepeat(True)

###################### Views #############################################
# Views are different camera postitions from where to view the structure.
# They can be activated from menus, or from the  view toolbox
# A number of views are predefined in the canvas class
# Any number of new views can be created, deleted, changed.
# Each view is identified by a string
    
def view(v):
    """Show a named view, either a builtin or a user defined."""
    global canvas
    if canvas.views.has_key(v):
        canvas.setView(None,v)
        canvas.update()
    else:
        warning("A view named '%s' has not been created yet" % v)
  
def initViewActions(viewlist):
    """Create the initial set of view actions."""
    global views
    views = []
    for name in viewlist:
        icon = name+"view.xbm"
        Name = string.capitalize(name)
        tooltip = Name+" View"
        menutext = "&"+Name
        createViewAction(name,icon,tooltip,menutext)

def createViewAction(name,icon,tooltip,menutext):
    """Creates a view action and adds it to the menu and/or toolbar.

    The view action is a MyQAction which sends the name when activated.
    It is added to the viewsMenu and/or the viewsBar if they exist.
    The toolbar button has icon and tooltip. The menu item has menutext. 
    """
    global config,views,viewsMenu,viewsBar,gui
    print "Creating View Action ",name,icon,tooltip,menutext
    dir = config['icondir']
    a = MyQAction(name,tooltip,qt.QIconSet(qt.QPixmap(os.path.join(dir,icon))),menutext,0,gui)
    qt.QObject.connect(a,qt.PYSIGNAL("Clicked"),view)
    views.append(name)
    if viewsMenu:
        a.addTo(viewsMenu)
    if viewsBar:
        a.addTo(viewsBar)
 
def addView(name,angles,icon="userview.xbm",tooltip=None,menutext=None):
    """Add a new view to the list of predefined views.

    This creates a new named view with specified angles for the canvas.
    It also creates a MyQAction which sends the name when activated, and
    adds the MyQAction to the viewsMenu and/or the viewsBar if they exist.
    """
    global views,viewsMenu,viewsBar,canvas,gui
    if tooltip == None:
        tooltip = name
    if menutext == None:
        menutext == name
    dir = config['icondir']
    canvas.createView(name,angles)
    createViewAction(name,icon,tooltip,menutext)


# Actions (these are just python functions)
# ??? Can we use python functions with arguments as actions in menus ???
# Didn't succeed yet


def NotImplemented():
    warning("This option has not been implemented yet!")
    
save = NotImplemented
saveAs = NotImplemented
record = NotImplemented

def help():
    """Start up the help browser"""
    help = qt.QTextBrowser()
    help.setSource('doc/html/formex.py')

def about():
    about = qt.QMessageBox()
    about.about(about,"About pyFormex",
        Version+"\n\n"
        "pyFormex is a python implementation of Formex algebra\n\n"
        "http://pyformex.berlios.de\n\n"
        "Copyright 2004 Benedict Verhegghe\n"
        "Distributed under the GNU General Public License.\n\n"
        "For help or information, mailto benedict.verhegghe@ugent.be\n" )

def testwarning():
    warning("Smoking may be hazardous to your health!")
def warning(s):
    global options
    if options.gui:
        w = qt.QMessageBox()
        w.warning(w,Version,s)
    else:
        print s


def saveImage():
    """Save the current rendering in image format."""
    global canvas
    fs = FileSelectionDialog(pattern="Images (*.png *.jpg)",mode=qt.QFileDialog.AnyFile)
    fn = fs.getFilename()
    if fn:
        fmt = string.upper(os.path.splitext(fn)[1])
        if len(fmt) > 0 and fmt[0] == '.':
            fmt = fmt[1:]
            if fmt == 'JPG':
                fmt = 'JPEG'
        else:
            fmt = 'PNG'
            fn += '.png'
        if fmt in qt.QImage.outputFormats():
            canvas.save(fn,fmt)
        else:
            warning("Sorry, can not save in %s format!\n"
                    "Suggest you use PNG format ;)"%fmt)


def play():
    fs = FileSelectionDialog(".","pyformex scripts (*.frm *.py)")
    fn = fs.getFilename()
    if fn:
        playFile(fn)
def printit():
    global out
    print out
def printbbox():
    global out
    if out:
        print "bbox of displayed Formex",out.bbox()
def printglobals():
    print globals()

def zoomIn():
    global canvas,config
    canvas.zoom(1./config['zoomfactor'])
    canvas.update()
def zoomOut():
    global canvas,config
    canvas.zoom(config['zoomfactor'])
    canvas.update()
##def panRight():
##    global canvas,config
##    canvas.camera.pan(+5)
##    canvas.update()   
##def panLeft():
##    global canvas,config
##    canvas.camera.pan(-5)
##    canvas.update()   
##def panUp():
##    global canvas,config
##    canvas.camera.pan(+5,0)
##    canvas.update()   
##def panDown():
##    global canvas,config
##    canvas.camera.pan(-5,0)
##    canvas.update()   
def rotRight():
    global canvas,config
    canvas.camera.rotate(+config['rotfactor'],0,1,0)
    canvas.update()   
def rotLeft():
    global canvas,config
    canvas.camera.rotate(-config['rotfactor'],0,1,0)
    canvas.update()   
def rotUp():
    global canvas,config
    canvas.camera.rotate(-config['rotfactor'],1,0,0)
    canvas.update()   
def rotDown():
    global canvas,config
    canvas.camera.rotate(+config['rotfactor'],1,0,0)
    canvas.update()   
def twistLeft():
    global canvas,config
    canvas.camera.rotate(+config['rotfactor'],0,0,1)
    canvas.update()   
def twistRight():
    global canvas,config
    canvas.camera.rotate(-config['rotfactor'],0,0,1)
    canvas.update()   
def transLeft():
    global canvas,config
    canvas.camera.translate(-config['panfactor'],0,0,config['localaxes'])
    canvas.update()   
def transRight():
    global canvas,config
    canvas.camera.translate(config['panfactor'],0,0,config['localaxes'])
    canvas.update()   
def transDown():
    global canvas,config
    canvas.camera.translate(0,-config['panfactor'],0,config['localaxes'])
    canvas.update()   
def transUp():
    global canvas,config
    canvas.camera.translate(0,config['panfactor'],0,config['localaxes'])
    canvas.update()   
def dollyIn():
    global canvas,config
    canvas.camera.dolly(1./config['zoomfactor'])
    canvas.update()   
def dollyOut():
    global canvas,config
    canvas.camera.dolly(config['zoomfactor'])
    canvas.update()   

def frontView():
    view("front");
def backView():
    view("back");
def leftView():
    view("left");
def rightView():
    view("right");
def topView():
    view("top");
def bottomView():
    view("bottom");
def isoView():
    view("iso");
# JUST TESTING:
def userView(i=1):
    if i==1:
        frontView()
    else:
        isoView()

def clear():
    """Remove all actors from the canvas"""
    global canvas,out
    canvas.removeAllActors()
    canvas.clear()
    out = None
def wireframe():
    global canvas
    canvas.glinit("wireframe")
    canvas.redrawAll()
def smooth():
    global canvas
    canvas.glinit("render")
    canvas.redrawAll()
def redraw():
    global canvas
    canvas.redrawAll()

### draw now draws in color by default.
### use draw(...,color=None) to draw in black, like the old function did    
    
def draw(F,side='front',color="prop"):
    """Draw a Formex on the canvas.

    This draws an actor on the canvas, and directs the camera to it from
    the specified side. Default is looking in the -z direction.
    Specifying side=None leaves the camera settings unchanged.
    If other actors are on the scene, they may be visible as well.
    Clear the canvas before drawing if you only want one actor!

    If the Formex has properties and a color list is specified, then the
    the properties will be used as an index in the color list and each member
    will be drawn with the resulting color.
    If color is one color value, the whole Formex will be drawn with
    that color.
    Finally, is color=None is specified, the whole Formex is
    drawn in black.
    """
    global canvas,out,config
    out = F
    if F.p == None or color==None:
        # use the Formex directly as actor
        canvas.addActor(FormexActor(F))
    else:
        # create actors for each color value
        color=config['propcolors']
        for v in F.propSet():
            f = F.hasProp(v)
            i = v % len(color)
            canvas.addActor(FormexActor(f,color[i]))
    if side:
        canvas.setView(F.bbox(),side)
    # If side == None we still should calculate the bbox and zoom accordingly
    canvas.update()

    
def execFile(fn):
    """Play a pyformex script from file fn."""
    execScript(file(fn))
    
def execScript(scr):
    """Play a pyformex script scr. scr should be a valid Python text.

    This function executes the script with 
    """
    g = globals()
    g.update(Formex.globals())
    exec scr in g

def playFile(fn,name=None):
    """Play a formex script from file fn."""
    playScript(file(fn,'r'),fn)

wakeupMode=0  # 0 = sleeping allowed, 1 = stay awake for this script
              # 2 = always stay awake, 3 = stay awake and exit at end of script
scriptLock = threading.Lock()
    
def playScript(scr,name="unnamed"):
    """Play a pyformex script scr. scr should be a valid Python text.

    If a second parameter is given, it will be displayed on the status line.
    This is different from execScript in that it starts a new thread,
    enabling the script to be killed.
    """
    global canvas,scriptLock,wakeupMode
    # Try to acquire the scriptLock, if not: return immediately
    # (We only allow one script executing at a time!)
    if not scriptLock.acquire(False):
        return
    message("Running script (%s)" % name)
    canvas.update()
    # We need to pass formex globals to the script
    # This would be done automatically if we put this function
    # in the formex.py file. But hen we need to pass other globals
    # from this file (like draw,...)
    # We might create a module with all operations accepted in
    # scripts.
    g = globals()
    g.update(Formex.globals())
    try:
        exec scr in g
    finally:
        scriptLock.release() # release the lock in case of an error
    message("Finished script")
    if wakeupMode > 2:
        exit()
    if wakeupMode < 2:
        wakeupMode = 0

# The sleep functionality has some problems which needs to be solved:
# If a script is played and enters in sleep mode, and the user does not wake
# it up before the next script is played, both get intermixed.
# Also, if a script is unfinished, and you try to close the program,
# It hangs.
# Therefore, it would be good to have some kill() function to cancel
# hanging scripts.

def sleep(timeout=None):
    """Sleep until key/mouse press in the canvas or until timeout"""
    global sleeping,wakeupMode,timer,app,action
    if wakeupMode > 0: # don't bother
        return
    # prepare for getting wakeup event 
    qt.QObject.connect(canvas,qt.PYSIGNAL("wakeup"),wakeup)
    # create a Timer to wakeup after timeout
    if timeout == None:
        timeout = config['sleeptime']
    if timeout:
        timer = threading.Timer(timeout,wakeup)
        timer.start()
    else:
        timer = None
    # go into sleep mode
    sleeping = True
    action['Step'].setEnabled(True)
    action['Continue'].setEnabled(True)
    ## while sleeping, we have to process events
    ## (we could start another thread for this)
    while sleeping:
        app.processEvents()
        time.sleep(0.1)
    action['Step'].setEnabled(False)
    action['Continue'].setEnabled(False)
    # ignore further wakeup events
    qt.QObject.disconnect(canvas,qt.PYSIGNAL("wakeup"),wakeup)
        
def wakeup(mode=0):
    """Wake up from the sleep function.

    This is the only way to exit the sleep() function.
    Default is to wake up from the current sleep. A mode > 0
    forces wakeup for longer period.
    """
    global timer,sleeping,wakeupMode
    if timer:
        timer.cancel()
    sleeping = False
    wakeupMode = mode

def kill():
    """Kill the current script"""
    ## For now, this just wakes up the cript to let it finish
    ## We really should implement a kill, e.g. bny raising a user
    ## exception, which is caught by the playScript function
    wakeup(1)

def killall():
    """Kill the current and all subsequent scripts"""
    wakeup(2)

def sleepShort():
    setSleepTime(1)
def sleepLong():
    setSleepTime(5)
def sleepForever():
    setSleepTime(None)
def setSleepTime(t):
    global config
    config['sleeptime'] = t

def localAxes():
    global config
    config['localaxes'] = True 
def globalAxes():
    global config
    config['localaxes'] = False 

def exit():
    global app,scriptLock
    if app:
        if scriptLock.acquire(False): # try to acquire script lock
            app.quit()  # exit on success (no script running)
        else:
            wakeup(3) # return to let the script finish, then exit
    else: # the gui didn't even start
        sys.exit(0)

def message(s):
    """Display a permanent message in the status line."""
    global theMessage
    theMessage.setText(qt.QString(s))

###########################  GUI, app  ################################
def GUI():
    """Constructs the GUI.

    The GUI has a central canvas for drawing, a menubar and a toolbar
    on top, and a statusbar at the bottom.
    """
    global canvas,statusbar,theMessage,menu,tool, options,config,views,gui,viewsMenu,viewsBar
    wd,ht = (config['width'],config['height'])
    w = qt.QMainWindow()
    w.setCaption(Version)
    w.resize(wd,ht)
    # add widgets to the main window
    statusbar = w.statusBar()
    theMessage = qt.QLabel(statusbar)
    statusbar.addWidget(theMessage)
    message(Version+" (c) B. Verhegghe")
    menu = w.menuBar()
    tool = qt.QToolBar(w)
    # Create an OpenGL canvas with a nice frame around it
    f = qt.QHBox(w)
    f.setFrameStyle(qt.QFrame.Sunken | qt.QFrame.Panel)
    f.setLineWidth(2)
    f.resize(wd,ht)
    fmt = qtgl.QGLFormat.defaultFormat()
    fmt.setDirectRendering(options.dri)
    canvas = Canvas(wd,ht,fmt,f)
    w.setCentralWidget(f)
    # Populate the menu ...
    insertExampleMenu()
    AddMenuItems(menu,MenuData)
    # ... and the toolbar
    addActionButtons()
    if config.setdefault('camerabuttons',True):
        addCameraButtons()
    if config.setdefault('viewsmenu',True):
        viewsMenu = qt.QPopupMenu(menu)
        menu.insertItem('View',viewsMenu,-1,2)
    if config.setdefault('viewsbar',True):
        viewsBar = qt.QToolBar("Views",w)
    gui = w
    # Create View Actions for the default views provided by the canvas
    initViewActions(config.setdefault('builtinviews',['front','back','left','right','top','bottom','iso']))
    return w


def runApp(args):
    """Create and run the qt application."""
    global app,gui
    app = qt.QApplication(args)
    qt.QObject.connect(app,qt.SIGNAL("lastWindowClosed()"),app,qt.SLOT("quit()"))
    # create GUI, show it, run it
    gui = GUI()
    app.setMainWidget(gui)
    gui.show()
    options.gui = True
    app.exec_loop()

###########################  main  ################################
def main(argv=None):
    """This is a fairly generic main() function.

    It is responsible for reading the configuration file(s),
    processing the command line options and starting the application.
    """
    global options,config
    # this allows us to call main from the interpreter
    if argv is None:
        argv = sys.argv
    # set the path to the pyformex files
    config['pyformexdir'] = os.path.dirname(os.path.realpath(argv[0]))
    # Read the default config file
    f = os.path.join(config['pyformexdir'],"pyformexrc")
    execfile(f)
    #process options
    from optparse import OptionParser,make_option
    parser = OptionParser(
        usage = "usage: %prog [<options>] [ --  <Qapp-options> ]",
        version = Version,
        option_list=[
        make_option("--nodri", help="do not use Direct Rendering",
                    action="store_false", dest="dri", default=True),
        make_option("--debug", help="display logging info to sys.stdout",
                    action="store_true", dest="debug", default=False)
        ])
    (options, args) = parser.parse_args()
    # Read the available config files
    for f in ["/etc/pyformexrc", \
              os.path.join(os.environ['HOME'],".pyformexrc"), \
              ".pyformexrc", ]:
        if os.path.exists(f):
            execfile(f)
            break
    # Run the application
    return runApp(args)

#### deprecated functions (retained for compatibility)

def drawProp(F,side="front",color="prop"):
    print "DEPRECATED: use draw() instead."
    draw(F,side,color)

#### Go

if __name__ == "__main__":
    sys.exit(main())

#### End
