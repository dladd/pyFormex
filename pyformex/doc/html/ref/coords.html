


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- 
##
##  This file is part of the pyFormex project.
##  pyFormex is a tool for generating, manipulating and transforming 3D
##  geometrical models by sequences of mathematical operations.
##  Home page: http://pyformex.org
##  Project page:  http://savannah.nongnu.org/projects/pyformex/
##  Copyright (C) Benedict Verhegghe (benedict.verhegghe@ugent.be) 
##  Distributed under the GNU General Public License version 3 or later.
##
##
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see http://www.gnu.org/licenses/.
##
-->


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1. coords — A structured collection of 3D coordinates. &mdash; pyFormex 0.9.0-a1 documentation</title>

    
    <link rel="stylesheet" href="../_static/pyformex.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9.0-a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="pyFormex 0.9.0-a1 documentation" href="../index.html" />
    <link rel="up" title="pyFormex reference manual" href="../refman.html" />
    <link rel="next" title="4. formex — Formex algebra in Python" href="formex.html" />
    <link rel="prev" title="pyFormex reference manual" href="../refman.html" />
<link rel="icon" type="image/png" href="_static/pyformex_fav.png" />

  </head>
  <body>

<div class="header">
  <a href="http://pyformex.org">
  <img src="http://www.nongnu.org/pyformex/_static/scallop_dome_small.png" alt="scallop dome" border="0" hspace="20" vspace="12" align="left" />
  <img src="http://www.nongnu.org/pyformex/_static/pyformex-logo-2.png" alt="pyformex logo" border="0" hspace="10" vspace="8" align="left" />
  </a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="formex.html" title="4. formex — Formex algebra in Python"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../refman.html" title="pyFormex reference manual"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pyFormex 0.9.0-a1 documentation</a> &gt;</li>
          <li><a href="../refman.html" accesskey="U">pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div align="center">

<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_s-xclick"/>
<input type="hidden" name="hosted_button_id" value="P7J4AM4QULB4Q"/>
<input type="image" src="https://www.paypal.com/en_US/BE/i/btn/btn_donateCC_LG.gif" name="submit" alt="PayPal - The safer, easier way to pay online!"/>
<img alt="" border="0" src="https://www.paypal.com/nl_NL/i/scr/pixel.gif" width="1" height="1"/>
</form>

</div>
   
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. <tt class="docutils literal"><span class="pre">coords</span></tt> &#8212; A structured collection of 3D coordinates.</a></li>
<li><a class="reference internal" href="#id53">2. <tt class="docutils literal"><span class="pre">coords</span></tt> &#8212; A structured collection of 3D coordinates.</a></li>
<li><a class="reference internal" href="#id107">3. <tt class="docutils literal"><span class="pre">coords</span></tt> &#8212; A structured collection of 3D coordinates.</a></li>
</ul>


  <h4>Previous topic</h4>
  <p class="topless"><a href="../refman.html"
                        title="previous chapter">pyFormex reference manual</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="formex.html"
                        title="next chapter">4. <tt class="docutils literal docutils literal"><span class="pre">formex</span></tt> &#8212; Formex algebra in Python</a></p>
  
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>

<div align="center">
  <p>
  <a href="http://www.fsf.org/register_form?referrer=8491"><img src="http://www.nongnu.org/pyformex/_static/fsf-member8491.png" alt="[FSF Associate Member]" width="89" height="31"  /></a>
  </p>
  <p>
    <a href="http://validator.w3.org/check?uri=referer"><img
      src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Transitional" height="31" width="88" /></a>
  </p>
</div>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-coords">
<span id="coords-a-structured-collection-of-3d-coordinates"></span><span id="sec-ref-coords"></span><h1>1. <a class="reference internal" href="#module-coords" title="coords: A structured collection of 3D coordinates."><tt class="xref py py-mod docutils literal"><span class="pre">coords</span></tt></a> &#8212; A structured collection of 3D coordinates.<a class="headerlink" href="#module-coords" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="#module-coords" title="coords: A structured collection of 3D coordinates."><tt class="xref py py-mod docutils literal"><span class="pre">coords</span></tt></a> module defines the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> class, which is the basic
data structure in pyFormex to store the coordinates of points in a 3D space.</p>
<p>This module implements a data class for storing large sets of 3D coordinates
and provides an extensive set of methods for transforming these coordinates.
Most of pyFormex&#8217;s classes which represent geometry (e.g. <tt class="xref py py-class docutils literal"><span class="pre">Geometry</span></tt>,
<tt class="xref py py-class docutils literal"><span class="pre">Formex</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">Mesh</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">TriSurface</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">Curve</span></tt>) use a
<a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object to store their coordinates, and thus inherit all the
transformation methods of this class.</p>
<p>While the user will mostly use the higher level classes, he might occasionally
find good reason to use the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> class directly as well.</p>
<p><tt class="docutils literal"><span class="pre">Classes</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">coords</span></tt></p>
<dl class="class">
<dt id="coords.Coords">
<em class="property">class </em><tt class="descclassname">coords.</tt><tt class="descname">Coords</tt><a class="headerlink" href="#coords.Coords" title="Permalink to this definition">¶</a></dt>
<dd><p>A structured collection of points in a 3D cartesian space.</p>
<p>The <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> class is the basic data structure used throughout
pyFormex to store coordinates of points in a 3D space.
It is used by other classes, such as <tt class="xref py py-class docutils literal"><span class="pre">Formex</span></tt>
and <tt class="xref py py-class docutils literal"><span class="pre">Surface</span></tt>, which thus inherit the same transformation
capabilities. Applications will mostly use the higher level
classes, which usually have more elaborated consistency checking
and error handling.</p>
<p><a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is implemented as a subclass of <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>,
and thus inherits all its methods.
The last axis of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> always has a length equal to 3.
Each set of 3 values along the last axis represents a single point
in 3D cartesian space. The float datatype is only checked at creation
time. It is the responsibility of the user to keep this consistent
throughout the lifetime of the object.</p>
<p>A new Coords object is created with the following syntax</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Coords</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">dtyp</span><span class="o">=</span><span class="n">Float</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters:</p>
<ul class="simple">
<li><cite>data</cite>: array_like of type float.
The last axis should have a length of 1, 2 or 3, bu will always be
expanded to 3.
If no data are specified, an empty Coords with shape (0,3) is created.</li>
<li><cite>dtyp</cite>: the float datatype to be used.
It not specified, the datatype of <cite>data</cite> is used, or the default
<tt class="xref py py-data docutils literal"><span class="pre">Float</span></tt> (which is equivalent to <tt class="xref py py-data docutils literal"><span class="pre">numpy.float32</span></tt>).</li>
<li><cite>copy</cite>: boolean.
If <tt class="docutils literal"><span class="pre">True</span></tt>, the data are copied. The default setting will try to use
the original data if possible, e.g. if <cite>data</cite> is a correctly shaped and
typed <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">Coords([ 1.,  0.,  0.], dtype=float32)</span>
</pre></div>
</div>
<dl class="method">
<dt id="coords.Coords.points">
<tt class="descname">points</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object as a simple set of points.</p>
<p>This reshapes the array to a 2-dimensional array, flattening
the structure of the points.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.pshape">
<tt class="descname">pshape</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.pshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the shape of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>This is the shape of the <a class="reference external" href="http://numpy.scipy.org">NumPy</a> array with the last axis removed.
The full shape of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> array can be obtained from
its shape attribute.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.npoints">
<tt class="descname">npoints</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.npoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of points.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.ncoords">
<tt class="descname">ncoords</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.ncoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of points.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.x">
<tt class="descname">x</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the X-coordinates of all points.</p>
<p>Returns an array with all the X-coordinates in the Coords.
The returned array has the same shape as the Coords array along
its first ndim-1 axes.
This is equivalent with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.y">
<tt class="descname">y</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Y-coordinates of all points.</p>
<p>Returns an array with all the Y-coordinates in the Coords.
The returned array has the same shape as the Coords array along
its first ndim-1 axes.
This is equivalent with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.z">
<tt class="descname">z</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.z" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Z-coordinates of all points.</p>
<p>Returns an array with all the Z-coordinates in the Coords.
The returned array has the same shape as the Coords array along
its first ndim-1 axes.
This is equivalent with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.bbox">
<tt class="descname">bbox</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the bounding box of a set of points.</p>
<p>The bounding box is the smallest rectangular volume in the global
coordinates, such that no point of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> are outside
that volume.</p>
<p>Returns a Coords object with shape(2,3): the first point contains the
minimal coordinates, the second has the maximal ones.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">bbox</span><span class="p">()</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 3.  3.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.apt">
<tt class="descname">apt</tt><big>(</big><em>align</em><big>)</big><a class="headerlink" href="#coords.Coords.apt" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an alignment point of a Coords.</p>
<p>Alignment point are points whose coordinates are either the minimal
value, the maximal value or the middle value for the Coords.
Combining the three values with the three dimensions, a Coords
has in 27 (3**3) alignment points. The corner points of the
bounding box are a subset of these.</p>
<p>The 27 points are addressed by an alignment string of three
characters, one for each direction. Each character should be
one of the following</p>
<ul class="simple">
<li>&#8216;-&#8216;: use the minimal value for that coordinate,</li>
<li>&#8216;+&#8217;: use the minimal value for that coordinate,</li>
<li>&#8216;0&#8217;: use the middle value for that coordinate.</li>
</ul>
<p>Any other character will set the corresponding coordinate to zero.</p>
<p>A string &#8216;000&#8217; is equivalent with center(). The values &#8216;&#8212;&#8217; and
&#8216;+++&#8217; give the points of the bounding box.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">apt</span><span class="p">(</span><span class="s">&#39;-0+&#39;</span><span class="p">)</span>
<span class="go">[ 0.   0.5  1. ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.center">
<tt class="descname">center</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The center of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is the center of its bbox().
The return value is a (3,) shaped <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
<span class="go">[ 1.5  1.5  0. ]</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#coords.Coords.centroid" title="coords.Coords.centroid"><tt class="xref py py-meth docutils literal"><span class="pre">centroid()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.average">
<tt class="descname">average</tt><big>(</big><em>wts=None</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#coords.Coords.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a (weighted) average of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The average of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with one
axis less than the original, obtained by averaging all the points
along that axis.
The weights array can either be 1-D (in which case its length must
be the size along the given axis) or of the same shape as a.
Weights can be specified as a 1-D array with the length of that axis,
or as an array with the same shape as the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.
The sum of the weights (along the specified axis if not 1-D) will
generally be equal to 1.0.
If wts=None, then all points are assumed to have a weight equal to
one divided by the length of the specified axis.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]],</span>                   <span class="p">[[</span><span class="mf">4.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">5.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">6.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">average</span><span class="p">()</span>
<span class="go">[[ 2.  0.  0.]</span>
<span class="go"> [ 3.  0.  0.]</span>
<span class="go"> [ 4.  0.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 5.  0.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">wts</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.25</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[[ 0.75  0.    0.  ]</span>
<span class="go"> [ 4.75  0.    0.  ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.centroid">
<tt class="descname">centroid</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.centroid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the centroid of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The centroid of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is the point whose coordinates
are the mean values of all points.
The return value is a (3,) shaped <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
<span class="go">[ 1.  1.  0.]</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#coords.Coords.center" title="coords.Coords.center"><tt class="xref py py-meth docutils literal"><span class="pre">center()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.sizes">
<tt class="descname">sizes</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sizes of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>Returns an array with the length of the bbox along the 3 axes.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">sizes</span><span class="p">()</span>
<span class="go">[ 3.  3.  0.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.dsize">
<tt class="descname">dsize</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.dsize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an estimate of the global size of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>This estimate is the length of the diagonal of the bbox().</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">dsize</span><span class="p">()</span>
<span class="go">4.24264</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.bsphere">
<tt class="descname">bsphere</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.bsphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the diameter of the bounding sphere of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The bounding sphere is the smallest sphere with center in the
center() of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>, and such that no points of the
<a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> are lying outside the sphere.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">bsphere</span><span class="p">()</span>
<span class="go">2.12132024765</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.inertia">
<tt class="descname">inertia</tt><big>(</big><em>mass=None</em><big>)</big><a class="headerlink" href="#coords.Coords.inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns inertia related quantities of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>mass</cite>: float array with ncoords weight values. The default is to
attribute a weight 1.0 to each point.</li>
</ul>
<p>Returns a tuple of:</p>
<ul class="simple">
<li><cite>center</cite>: the center of mass: shape (3,)</li>
<li><cite>axes</cite>: the principal axes of the inertia tensor: shape (3,3)</li>
<li><cite>principal</cite>: the (prinicipal) moments of inertia: shape (3,)</li>
<li><cite>tensor</cite>: the full inertia tensor in the global axes: shape (3,3)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.distanceFromPlane">
<tt class="descname">distanceFromPlane</tt><big>(</big><em>p</em>, <em>n</em><big>)</big><a class="headerlink" href="#coords.Coords.distanceFromPlane" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the distance of all points from the plane (p,n).</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>p</cite>: is a point specified by 3 coordinates.</li>
<li><cite>n</cite>: is the normal vector to a plane, specified by 3 components.</li>
</ul>
<p>The return value is a float array with shape <tt class="docutils literal"><span class="pre">self.pshape()</span></tt> with
the distance of each point to the plane through p and having normal n.
Distance values are positive if the point is on the side of the
plane indicated by the positive normal.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">distanceFromPlane</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">[[ 0.  3.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.distanceFromLine">
<tt class="descname">distanceFromLine</tt><big>(</big><em>p</em>, <em>n</em><big>)</big><a class="headerlink" href="#coords.Coords.distanceFromLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the distance of all points from the line (p,n).</p>
<p>p,n are (1,3) or (npts,3) arrays defining 1 or npts lines</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>p</cite>: is a point on the line specified by 3 coordinates.</li>
<li><cite>n</cite>: is a vector specifying the direction of the line through p.</li>
</ul>
<p>The return value is a [...] shaped array with the distance of
each point to the line through p with direction n.
All distance values are positive or zero.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">distanceFromLine</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">[[ 0.  0.  3.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.distanceFromPoint">
<tt class="descname">distanceFromPoint</tt><big>(</big><em>p</em><big>)</big><a class="headerlink" href="#coords.Coords.distanceFromPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the distance of all points from the point p.</p>
<p>p is a single point specified by 3 coordinates.</p>
<p>The return value is a [...] shaped array with the distance of
each point to point p.
All distance values are positive or zero.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">distanceFromPoint</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">[[ 0.  3.  3.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.closestToPoint">
<tt class="descname">closestToPoint</tt><big>(</big><em>p</em><big>)</big><a class="headerlink" href="#coords.Coords.closestToPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the point closest to point p.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.directionalSize">
<tt class="descname">directionalSize</tt><big>(</big><em>n</em>, <em>p=None</em>, <em>_points=False</em><big>)</big><a class="headerlink" href="#coords.Coords.directionalSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the extreme distances from the plane p,n.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>n</cite>: the direction can be specified by a 3 component vector or by
a single integer 0..2 designing one of the coordinate axes.</li>
<li><cite>p</cite>: is any point in space. If not specified, it is taken as the
center() of the Coords.</li>
</ul>
<p>The return value is a tuple of two float values specifying the
extreme distances from the plane p,n.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.directionalExtremes">
<tt class="descname">directionalExtremes</tt><big>(</big><em>n</em>, <em>p=None</em><big>)</big><a class="headerlink" href="#coords.Coords.directionalExtremes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns extremal planes in the direction n.</p>
<p><cite>n</cite> and <cite>p</cite> have the same meaning as in <cite>directionalSize</cite>.</p>
<p>The return value is a list of two points on the line (p,n),
such that the planes with normal n through these points define
the extremal planes of the Coords.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.directionalWidth">
<tt class="descname">directionalWidth</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#coords.Coords.directionalWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the width of a Coords in the given direction.</p>
<p>The direction can be specified by a 3 component vector or by
a single integer 0..2 designating one of the coordinate axes.</p>
<p>The return value is the thickness of the object in the direction n.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.test">
<tt class="descname">test</tt><big>(</big><em>dir=0</em>, <em>min=None</em>, <em>max=None</em>, <em>atol=0.0</em><big>)</big><a class="headerlink" href="#coords.Coords.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag points having coordinates between min and max.</p>
<p>Tests the position of the points of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with respect to
one or two planes. This method is very convenient in clipping a
<a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> in a specified direction. In most cases the clipping
direction is one of the global cooordinate axes, but a general
direction may be used as well.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: either a global axis number (0, 1 or 2) or a direction vector
consisting of 3 floats. It specifies the direction in which the
distances are measured. Default is the 0 (or x) direction.</li>
<li><cite>min</cite>, <cite>max</cite>: position of the minimum and maximum clipping planes.
If <cite>dir</cite> was specified as an integer (0,1,2), this is a single float
value corresponding with the coordinate in that axis direction.
Else, it is a point in the clipping plane with normal direction <cite>dir</cite>.
One of the two clipping planes may be left unspecified.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A 1D integer array with same length as the number of points.
For each point the value is 1 (True) if the point is above the
minimum clipping plane and below the maximum clipping plane,
or 0 (False) otherwise.
An unspecified clipping plane corresponds with an infinitely low or
high value. The return value can directly be used as an index to
obtain a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with the points satisfying the test (or not).
See the examples below.</div></blockquote>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[False  True False False]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="nb">max</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
<span class="go">[[ 0.  1.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">t</span><span class="p">]</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 1.  0.  0.]</span>
<span class="go"> [ 0.  2.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.fprint">
<tt class="descname">fprint</tt><big>(</big><em>fmt='%10.3e %10.3e %10.3e'</em><big>)</big><a class="headerlink" href="#coords.Coords.fprint" title="Permalink to this definition">¶</a></dt>
<dd><p>Formatted printing of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>The supplied format should contain 3 formatting sequences for the
three coordinates of a point.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.set">
<tt class="descname">set</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#coords.Coords.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the coordinates from those in the given array.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.scale">
<tt class="descname">scale</tt><big>(</big><em>scale</em>, <em>dir=None</em>, <em>center=None</em>, <em>inplace=False</em><big>)</big><a class="headerlink" href="#coords.Coords.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy scaled with scale[i] in direction i.</p>
<p>The scale should be a list of 3 scaling factors for the 3 axis
directions, or a single scaling factor.
In the latter case, dir (a single axis number or a list) may be given
to specify the direction(s) to scale. The default is to produce a
homothetic scaling.
The center of the scaling, if not specified, is the global origin.
If a center is specified, the result is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="nb">dir</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[ 2.  2.  2.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span><span class="o">.</span><span class="n">scale</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">[ 2.  3.  4.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.translate">
<tt class="descname">translate</tt><big>(</big><em>dir</em>, <em>step=None</em>, <em>inplace=False</em><big>)</big><a class="headerlink" href="#coords.Coords.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Translates the Coords in the direction <cite>dir</cite> over a distance
<cite>step * length(dir)</cite>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the direction and distance of the translation. It
can be either<ul>
<li>an axis number (0,1,2), specifying a unit vector in the direction
of one of the coordinate axes.</li>
<li>a single translation vector,</li>
<li>an array of translation vectors, compatible with the Coords shape.</li>
</ul>
</li>
<li><cite>step</cite>: If specified, the translation vector specified by <cite>dir</cite> will
be multiplied with this value. It is commonly used with unit <cite>dir</cite>
vectors to set the translation distance.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.centered">
<tt class="descname">centered</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.centered" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a centered copy of the Coords.</p>
<p>Returns a Coords which is a translation thus that the center
coincides with the origin.
This is equivalent with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">trl</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.align">
<tt class="descname">align</tt><big>(</big><em>alignment='---', point=[0.0, 0.0, 0.0]</em><big>)</big><a class="headerlink" href="#coords.Coords.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a Coords on a given point.</p>
<p>Alignment involves a translation such that the bounding box
of the Coords object becomes aligned with a given point.
By default this is the origin of the global axes.
The requested alignment is determined by a string of three characters,
one for each of the coordinate axes. The character determines how
the structure is aligned in the corresponding direction:</p>
<ul class="simple">
<li>&#8216;-&#8216;: aligned on the minimal value of the bounding box,</li>
<li>&#8216;+&#8217;: aligned on the maximal value of the bounding box,</li>
<li>&#8216;0&#8217;: aligned on the middle value of the bounding box.</li>
</ul>
<p>Any other value will make the alignment in that direction unchanged.</p>
<p>The default alignment string <tt class="docutils literal"><span class="pre">'---'</span></tt> results in a translation which
puts all the points in the octant with all positive coordinate values.
A string <tt class="docutils literal"><span class="pre">'000'</span></tt> will center the object around the origin, just like
the (slightly faster) <a class="reference internal" href="#coords.Coords.centered" title="coords.Coords.centered"><tt class="xref py py-meth docutils literal"><span class="pre">centered()</span></tt></a> method.</p>
<p>See also the <a class="reference internal" href="#coords.align" title="coords.align"><tt class="xref py py-func docutils literal"><span class="pre">coords.align()</span></tt></a> function.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.rotate">
<tt class="descname">rotate</tt><big>(</big><em>angle</em>, <em>axis=2</em>, <em>around=None</em><big>)</big><a class="headerlink" href="#coords.Coords.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy rotated over angle around axis.</p>
<p>The angle is specified in degrees.
The axis is either one of (0,1,2) designating the global axes,
or a vector specifying an axis through the origin.
If no axis is specified, rotation is around the 2(z)-axis. This is
convenient for working on 2D-structures.</p>
<p>As a convenience, the user may also specify a 3x3 rotation matrix,
in which case the function rotate(mat) is equivalent to affine(mat).</p>
<p>All rotations are performed around the point [0.,0.,0.], unless a
rotation origin is specified in the argument &#8216;around&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.shear">
<tt class="descname">shear</tt><big>(</big><em>dir</em>, <em>dir1</em>, <em>skew</em>, <em>inplace=False</em><big>)</big><a class="headerlink" href="#coords.Coords.shear" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy skewed in the direction dir of plane (dir,dir1).</p>
<p>The coordinate dir is replaced with (dir + skew * dir1).</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.reflect">
<tt class="descname">reflect</tt><big>(</big><em>dir=0</em>, <em>pos=0.0</em>, <em>inplace=False</em><big>)</big><a class="headerlink" href="#coords.Coords.reflect" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflect the coordinates in direction dir against plane at pos.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: int: direction of the reflection (default 0)</li>
<li><cite>pos</cite>: float: offset of the mirror plane from origin (default 0.0)</li>
<li><cite>inplace</cite>: boolean: change the coordinates inplace (default False)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.affine">
<tt class="descname">affine</tt><big>(</big><em>mat</em>, <em>vec=None</em><big>)</big><a class="headerlink" href="#coords.Coords.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a general affine transformation.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>mat</cite>: a 3x3 float matrix</li>
<li><cite>vec</cite>: a length 3 list or array of floats</li>
</ul>
<p>The returned object has coordinates given by <tt class="docutils literal"><span class="pre">self</span> <span class="pre">*</span> <span class="pre">mat</span> <span class="pre">+</span> <span class="pre">vec</span></tt>.
If <cite>mat</cite> is a rotation matrix, than the operation performs a
rigid rotation of the object plus a translation.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.position">
<tt class="descname">position</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#coords.Coords.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Position an object so that points x are aligned with y.</p>
<p>Parameters are as for <a class="reference internal" href="arraytools.html#arraytools.trfMatrix" title="arraytools.trfMatrix"><tt class="xref py py-func docutils literal"><span class="pre">arraytools.trfMatrix()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.cylindrical">
<tt class="descname">cylindrical</tt><big>(</big><em>dir=[0, 1, 2], scale=[1.0, 1.0, 1.0], angle_spec=0.017453292519943295</em><big>)</big><a class="headerlink" href="#coords.Coords.cylindrical" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from cylindrical to cartesian after scaling.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates are interpreted as resp.
distance(r), angle(theta) and height(z). Default order is [r,theta,z].</li>
<li><cite>scale</cite>: will scale the coordinate values prior to the transformation.
(scale is given in order r,theta,z).</li>
</ul>
<p>The resulting angle is interpreted in degrees.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.toCylindrical">
<tt class="descname">toCylindrical</tt><big>(</big><em>dir=[0, 1, 2], angle_spec=0.017453292519943295</em><big>)</big><a class="headerlink" href="#coords.Coords.toCylindrical" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from cartesian to cylindrical coordinates.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates axes are parallel to respectively the
cylindrical axes distance(r), angle(theta) and height(z). Default
order is [x,y,z].</li>
</ul>
<p>The angle value is given in degrees.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.spherical">
<tt class="descname">spherical</tt><big>(</big><em>dir=[0, 1, 2], scale=[1.0, 1.0, 1.0], angle_spec=0.017453292519943295, colat=False</em><big>)</big><a class="headerlink" href="#coords.Coords.spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from spherical to cartesian after scaling.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates are interpreted as resp.
longitude(theta), latitude(phi) and distance(r).</li>
<li><cite>scale</cite>: will scale the coordinate values prior to the transformation.</li>
</ul>
<p>Angles are interpreted in degrees.
Latitude, i.e. the elevation angle, is measured from equator in
direction of north pole(90). South pole is -90.</p>
<p>If colat=True, the third coordinate is the colatitude (90-lat) instead.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.superSpherical">
<tt class="descname">superSpherical</tt><big>(</big><em>n=1.0, e=1.0, k=0.0, dir=[0, 1, 2], scale=[1.0, 1.0, 1.0], angle_spec=0.017453292519943295, colat=False</em><big>)</big><a class="headerlink" href="#coords.Coords.superSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a superspherical transformation.</p>
<p>superSpherical is much like spherical, but adds some extra
parameters to enable the creation of virtually any surface.</p>
<p>Just like with spherical(), the input coordinates are interpreted as
the longitude, latitude and distance in a spherical coordinate system.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates are interpreted as resp.longitude(theta),
latitude(phi) and distance(r).
Angles are then interpreted in degrees.
Latitude, i.e. the elevation angle, is measured from equator in
direction of north pole(90). South pole is -90.
If colat=True, the third coordinate is the colatitude (90-lat) instead.</li>
<li><cite>scale</cite>: will scale the coordinate values prior to the transformation.</li>
<li><cite>n</cite>, <cite>e</cite>: parameters define exponential transformations of the
north_south (latitude), resp. the east_west (longitude) coordinates.
Default values of 1 result in a circle.</li>
<li><cite>k</cite>: adds &#8216;eggness&#8217; to the shape: a difference between the northern and
southern hemisphere. Values &gt; 0 enlarge the southern hemishpere and
shrink the northern.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.toSpherical">
<tt class="descname">toSpherical</tt><big>(</big><em>dir=[0, 1, 2], angle_spec=0.017453292519943295</em><big>)</big><a class="headerlink" href="#coords.Coords.toSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from cartesian to spherical coordinates.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates axes are parallel to respectively
the spherical axes distance(r), longitude(theta) and latitude(phi).
Latitude is the elevation angle measured from equator in direction
of north pole(90). South pole is -90.
Default order is [0,1,2], thus the equator plane is the (x,y)-plane.</li>
</ul>
<p>The returned angle values are given in degrees.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.bump1">
<tt class="descname">bump1</tt><big>(</big><em>dir</em>, <em>a</em>, <em>func</em>, <em>dist</em><big>)</big><a class="headerlink" href="#coords.Coords.bump1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with a one-dimensional bump.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the axis of the modified coordinates;</li>
<li><cite>a</cite>: is the point that forces the bumping;</li>
<li><cite>dist</cite>: specifies the direction in which the distance is measured;</li>
<li><cite>func</cite>: is a function that calculates the bump intensity from distance
and should be such that <tt class="docutils literal"><span class="pre">func(0)</span> <span class="pre">!=</span> <span class="pre">0</span></tt>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.bump2">
<tt class="descname">bump2</tt><big>(</big><em>dir</em>, <em>a</em>, <em>func</em><big>)</big><a class="headerlink" href="#coords.Coords.bump2" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with a two-dimensional bump.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the axis of the modified coordinates;</li>
<li><cite>a</cite>: is the point that forces the bumping;</li>
<li><cite>func</cite>: is a function that calculates the bump intensity from distance
!! func(0) should be different from 0.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.bump">
<tt class="descname">bump</tt><big>(</big><em>dir</em>, <em>a</em>, <em>func</em>, <em>dist=None</em><big>)</big><a class="headerlink" href="#coords.Coords.bump" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with a bump.</p>
<p>A bump is a modification of a set of coordinates by a non-matching
point. It can produce various effects, but one of the most common
uses is to force a surface to be indented by some point.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the axis of the modified coordinates;</li>
<li><cite>a</cite>: is the point that forces the bumping;</li>
<li><cite>func</cite>: is a function that calculates the bump intensity from distance
(!! func(0) should be different from 0)</li>
<li><cite>dist</cite>: is the direction in which the distance is measured : this can
be one of the axes, or a list of one or more axes.
If only 1 axis is specified, the effect is like function bump1
If 2 axes are specified, the effect is like bump2
This function can take 3 axes however.
Default value is the set of 3 axes minus the direction of
modification. This function is then equivalent to bump2.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.flare">
<tt class="descname">flare</tt><big>(</big><em>xf, f, dir=[0, 2], end=0, exp=1.0</em><big>)</big><a class="headerlink" href="#coords.Coords.flare" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a flare at the end of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> block.</p>
<p>The flare extends over a distance <tt class="docutils literal"><span class="pre">xf</span></tt> at the start (<tt class="docutils literal"><span class="pre">end=0</span></tt>)
or end (<tt class="docutils literal"><span class="pre">end=1</span></tt>) in direction <tt class="docutils literal"><span class="pre">dir[0]</span></tt> of the coords block,
and has a maximum amplitude of <tt class="docutils literal"><span class="pre">f</span></tt> in the <tt class="docutils literal"><span class="pre">dir[1]</span></tt> direction.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.map">
<tt class="descname">map</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#coords.Coords.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> by a 3-D function.</p>
<p>This is one of the versatile mapping functions.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>func</cite>: is a numerical function which takes three arguments and produces
a list of three output values. The coordinates [x,y,z] will be
replaced by func(x,y,z).</li>
</ul>
<p>The function must be applicable to arrays, so it should
only include numerical operations and functions understood by the
numpy module.
This method is one of several mapping methods. See also map1 and mapd.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="mi">4</span><span class="o">*</span><span class="n">z</span><span class="p">])</span>
<span class="go">[[ 2.  3.  4.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.map1">
<tt class="descname">map1</tt><big>(</big><em>dir</em>, <em>func</em>, <em>x=None</em><big>)</big><a class="headerlink" href="#coords.Coords.map1" title="Permalink to this definition">¶</a></dt>
<dd><p>Map one coordinate by a 1-D function of one coordinate.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>func</cite>: is a numerical function which takes one argument and produces
one result. The coordinate dir will be replaced by func(coord[x]).
If no x is specified, x is taken equal to dir.</li>
</ul>
<p>The function must be applicable on arrays, so it should only
include numerical operations and functions understood by the
numpy module.
This method is one of several mapping methods. See also map and mapd.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.mapd">
<tt class="descname">mapd</tt><big>(</big><em>dir, func, point=[0.0, 0.0, 0.0], dist=None</em><big>)</big><a class="headerlink" href="#coords.Coords.mapd" title="Permalink to this definition">¶</a></dt>
<dd><p>Map one coordinate by a function of the distance to a point.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: 0, 1 or 2: the coordinate that will be replaced with
<tt class="docutils literal"><span class="pre">func(d)</span></tt>, where <cite>d</cite> is calculated as the distance to <cite>point</cite>.</li>
<li><cite>func</cite>: a numerical function which takes one float argument and
produce one float result. The function must be applicable on arrays,
so it should only include numerical operations and functions
understood by the <tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> module.</li>
<li><cite>point</cite>: the point to where the distance <cite>d</cite> is computed.</li>
<li><cite>dist</cite>: a list of coordinate directions that are used to compute
the distances <cite>d</cite>. It can also be a single coordinate direction.
The default is to use 3-D distances.</li>
</ul>
<p>This method is one of several mapping methods. See also
<tt class="xref py py-meth docutils literal"><span class="pre">map3()</span></tt> and <a class="reference internal" href="#coords.Coords.map1" title="coords.Coords.map1"><tt class="xref py py-meth docutils literal"><span class="pre">map1()</span></tt></a>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span><span class="o">.</span><span class="n">mapd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span><span class="n">E</span><span class="o">.</span><span class="n">center</span><span class="p">(),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>maps <tt class="docutils literal"><span class="pre">E</span></tt> on a sphere with radius 10.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.egg">
<tt class="descname">egg</tt><big>(</big><em>k</em><big>)</big><a class="headerlink" href="#coords.Coords.egg" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the coordinates to an egg-shape</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.replace">
<tt class="descname">replace</tt><big>(</big><em>i</em>, <em>j</em>, <em>other=None</em><big>)</big><a class="headerlink" href="#coords.Coords.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the coordinates along the axes i by those along j.</p>
<p>i and j are lists of axis numbers or single axis numbers.
replace ([0,1,2],[1,2,0]) will roll the axes by 1.
replace ([0,1],[1,0]) will swap axes 0 and 1.
An optionally third argument may specify another <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object to take
the coordinates from. It should have the same dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.swapAxes">
<tt class="descname">swapAxes</tt><big>(</big><em>i</em>, <em>j</em><big>)</big><a class="headerlink" href="#coords.Coords.swapAxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap coordinate axes i and j.</p>
<p>Beware! This is different from numpy&#8217;s swapaxes() method !</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.rollAxes">
<tt class="descname">rollAxes</tt><big>(</big><em>n=1</em><big>)</big><a class="headerlink" href="#coords.Coords.rollAxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll the axes over the given amount.</p>
<p>Default is 1, thus axis 0 becomes the new 1 axis, 1 becomes 2 and
2 becomes 0.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.projectOnPlane">
<tt class="descname">projectOnPlane</tt><big>(</big><em>n=2, P=[0.0, 0.0, 0.0]</em><big>)</big><a class="headerlink" href="#coords.Coords.projectOnPlane" title="Permalink to this definition">¶</a></dt>
<dd><p>Project a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> on a plane (or planes).</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>n</cite>: the normal direction to the plane. It can be specified either
by a list of three floats, or by a single integer (0, 1 or 2) to
use one of the global axes.</li>
<li><cite>P</cite>: a point on the plane, by default the global origin.
If an int, the plane is the coordinate plane perpendicular to the</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For planes parallel to a coordinate plane, it is far more
efficient to specify the normal by an axis number than by a
three component vector.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method will also work if any or both of P and n have
a shape (ncoords,3), where ncoords is the total number of points
in the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>. This allows to project each point on an
individual plane.</p>
</div>
<p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with same shape as original, with all the
points projected on the specified plane(s).</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.projectOnSphere">
<tt class="descname">projectOnSphere</tt><big>(</big><em>radius=1.0, center=[0.0, 0.0, 0.0]</em><big>)</big><a class="headerlink" href="#coords.Coords.projectOnSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Project <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> on a sphere.</p>
<p>The default sphere is a unit sphere at the origin.
The center of the sphere should not be part of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.projectOnCylinder">
<tt class="descname">projectOnCylinder</tt><big>(</big><em>radius=1.0, dir=0, center=[0.0, 0.0, 0.0]</em><big>)</big><a class="headerlink" href="#coords.Coords.projectOnCylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Project <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> on a cylinder with axis parallel to a global axis.</p>
<p>The default cylinder has its axis along the x-axis and a unit radius.
No points of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> should belong to the axis..</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.projectOnSurface">
<tt class="descname">projectOnSurface</tt><big>(</big><em>S</em>, <em>dir=0</em>, <em>missing='error'</em>, <em>return_indices=False</em><big>)</big><a class="headerlink" href="#coords.Coords.projectOnSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the Coords on a triangulated surface.</p>
<p>The points of the Coords are projected in the specified direction dir
onto the surface S.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>S</cite>: TriSurface: any triangulated surface</li>
<li><cite>dir</cite>: int or vector: specifies the direction of the projection</li>
<li><cite>missing</cite>: float value or a string. Specifies a distance to set
the position of the projection point in cases where the projective
line does not cut the surface. The sign of the distance is taken
into account. If specified as a string, it should be one of the
strings &#8216;c&#8217;, &#8216;f&#8217;, or &#8216;m&#8217;, possibly preceded by a &#8216;+&#8217; or &#8216;-&#8216;.
The distance will then be taken equal to the closest,
the furthest, or the mean distance of a point to its projection,
and applied in positive or negative direction as specified.
Any other value of missing will result in an error if some point
does not have any projection. An error will also be raised if not
a single point projection intersects the surface.</li>
<li><cite>return_indices</cite>: if True, also returns an index of the points that
have a projection on the surface.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A Coords with the same shape as the input. If <cite>return_indices</cite>
is True, also returns an index of the points that have a projection
on the surface. This index is a sequential one, no matter what the
shape of the input Coords is.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.isopar">
<tt class="descname">isopar</tt><big>(</big><em>eltype</em>, <em>coords</em>, <em>oldcoords</em><big>)</big><a class="headerlink" href="#coords.Coords.isopar" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an isoparametric transformation on a Coords.</p>
<p>This is a convenience method to transform a Coords object through
an isoparametric transformation. It is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Isopar</span><span class="p">(</span><span class="n">eltype</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span><span class="n">oldcoords</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>See <tt class="xref py py-mod docutils literal"><span class="pre">plugins.isopar</span></tt> for more details.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.transformCS">
<tt class="descname">transformCS</tt><big>(</big><em>currentCS</em>, <em>initialCS=None</em><big>)</big><a class="headerlink" href="#coords.Coords.transformCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a coordinate system transformation on the Coords.</p>
<p>This method transforms the Coords object by the transformation that
turns the initial coordinate system into the current coordinate system.</p>
<p>currentCS and initialCS are (4,3) shaped Coords instances defining
a coordinate system as described in <tt class="xref py py-class docutils literal"><span class="pre">CoordinateSystem</span></tt>.
If initialCS is None, the global (x,y,z) axes are used.</p>
<p>E.g. the default initialCS and currentCS equal to:</p>
<div class="highlight-python"><pre> 0.  1.  0.
-1.  0.  0.
 0.  0.  1.
 0.  0.  0.</pre>
</div>
<p>result in a rotation of 90 degrees around the z-axis.</p>
<p>This is a convenience function equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">isopar</span><span class="p">(</span><span class="s">&#39;tet4&#39;</span><span class="p">,</span><span class="n">currentCS</span><span class="p">,</span><span class="n">initialCS</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.addNoise">
<tt class="descname">addNoise</tt><big>(</big><em>rsize=0.05</em>, <em>asize=0.0</em><big>)</big><a class="headerlink" href="#coords.Coords.addNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add random noise to a Coords.</p>
<p>A random amount is added to eacho individual coordinate in the Coords.
The difference of any coordinate from its original value will
not be r than <tt class="docutils literal"><span class="pre">asize+rsize*self.sizes().max()</span></tt>. The default
is to set it to 0.05 times the geometrical size of the structure.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.replicate">
<tt class="descname">replicate</tt><big>(</big><em>n</em>, <em>dir=0</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#coords.Coords.replicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Replicate a Coords n times with fixed step in any direction.</p>
<p>Returns a Coords object with shape <cite>(n,) + self.shape</cite>, thus having
an extra first axis.
Each component along the axis 0 is equal to the previous component
translated over <cite>(dir,step)</cite>, where <cite>dir</cite> and <cite>step</cite> are
interpreted just like in the <a class="reference internal" href="#coords.Coords.translate" title="coords.Coords.translate"><tt class="xref py py-meth docutils literal"><span class="pre">translate()</span></tt></a> method.
The first component along the axis 0 is identical to the
original Coords.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.split">
<tt class="descname">split</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.Coords.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the coordinate array in blocks along first axis.</p>
<p>The result is a sequence of arrays with shape self.shape[1:].
Raises an error if self.ndim &lt; 2.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.sort">
<tt class="descname">sort</tt><big>(</big><em>order=[0, 1, 2]</em><big>)</big><a class="headerlink" href="#coords.Coords.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort points in the specified order of their coordinates.</p>
<p>The points are sorted based on their coordinate values. There is a
maximum number of points (above 2 million) that can be sorted. If you
need to to sort more, first split up your data according to the first
axis.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>order</cite>: permutation of [0,1,2], specifying the order in which
the subsequent axes are used to sort the points.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>An int array which is a permutation of range(self.npoints()).
If taken in the specified order, it is guaranteed that no point can
have a coordinate that is larger that the corresponding coordinate
of the next point.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.boxes">
<tt class="descname">boxes</tt><big>(</big><em>ppb=1</em>, <em>shift=0.5</em>, <em>minsize=1e-05</em><big>)</big><a class="headerlink" href="#coords.Coords.boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a grid of equally sized boxes spanning the points x.</p>
<p>A regular 3D grid of equally sized boxes is created spanning all
the points <cite>x</cite>. The size, position and number of boxes are determined
from the specified parameters.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>ppb</cite>: int: mean number of points per box. The box sizes and
number of boxes will be determined to approximate this number.</li>
<li><cite>shift</cite>: float (0.0 .. 1.0): a relative shift value for the grid.
Applying a shift of 0.5 will make the lowest coordinate values fall
at the center of the outer boxes.</li>
<li><cite>minsize</cite>: float: minimum absolute size of the boxes (same in each
coordinate direction).</li>
</ul>
<p>Returns a tuple of:</p>
<ul class="simple">
<li><cite>ox</cite>: float array (3): minimal coordinates of the box grid,</li>
<li><cite>dx</cite>: float array (3): box size in the three axis directions,</li>
<li><cite>nx</cite>: in array (3): number of boxes in each of the coordinate
directions.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.fuse">
<tt class="descname">fuse</tt><big>(</big><em>ppb=1</em>, <em>shift=0.5</em>, <em>rtol=1e-05</em>, <em>atol=1e-05</em>, <em>repeat=True</em>, <em>nodesperbox=None</em><big>)</big><a class="headerlink" href="#coords.Coords.fuse" title="Permalink to this definition">¶</a></dt>
<dd><p>Find (almost) identical nodes and return a compressed set.</p>
<p>This method finds the points that are very close and replaces them
with a single point. The return value is a tuple of two arrays:</p>
<ul class="simple">
<li>the unique points as a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object with shape (npoints,3)</li>
<li>an integer (nnod) array holding an index in the unique
coordinates array for each of the original nodes. This index will
have the same shape as the pshape() of the coords array.</li>
</ul>
<p>The procedure works by first dividing the 3D space in a number of
equally sized boxes, with a mean population of ppb.
The boxes are numbered in the 3 directions and a unique integer scalar
is computed, that is then used to sort the nodes.
Then only nodes inside the same box are compared on almost equal
coordinates, using the numpy allclose() function. Two coordinates are
considered close if they are within a relative tolerance rtol or
absolute tolerance atol. See numpy for detail. The default atol is
set larger than in numpy, because pyformex typically runs with single
precision.
Close nodes are replaced by a single one.</p>
<p>Running the procedure once does not guarantee to find all close nodes:
two close nodes might be in adjacent boxes. The performance hit for
testing adjacent boxes is rather high, and the probability of separating
two close nodes with the computed box limits is very small.
Therefore, the most sensible way is to run the procedure twice, with
a different shift value (they should differ more than the tolerance).
Specifying repeat=True will automatically do this.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.match">
<tt class="descname">match</tt><big>(</big><em>coords</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#coords.Coords.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Match points form another Coords object.</p>
<p>This method finds the points from <cite>coords</cite> that coincide with
(or are very close to) points of <cite>self</cite>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>coords</cite>: a Coords object</li>
<li><cite>**kargs</cite>: keyword arguments that you want to pass to the
<a class="reference internal" href="#coords.Coords.fuse" title="coords.Coords.fuse"><tt class="xref py py-meth docutils literal"><span class="pre">fuse()</span></tt></a> method.</li>
</ul>
<p>This method works by concatenating the serialized point sets of
both Coords and then fusing them.</p>
<p>Returns:</p>
<ul class="simple">
<li><cite>matches</cite>: an Int array with shape (nmatches,2)</li>
<li><cite>coords</cite>: a Coords with the fused coordinate set</li>
<li><cite>index</cite>: an index with the position of each of the serialized
points of the concatenation in the fused coordinate set. To find
the index of the points of the orginal coordinate sets, split
this index at the position self.npoints() and reshape the resulting
parts to <cite>self.pshape()</cite>, resp. <cite>coords.pshape()</cite>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.append">
<tt class="descname">append</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#coords.Coords.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append coords to a Coords object.</p>
<p>The appended coords should have matching dimensions in all
but the first axis.</p>
<p>Returns the concatenated Coords object, without changing the current.</p>
<p>This is comparable to <tt class="xref py py-func docutils literal"><span class="pre">numpy.append()</span></tt>, but the result
is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object, the default axis is the first one
instead of the last, and it is a method rather than a function.</p>
</dd></dl>

<dl class="classmethod">
<dt id="coords.Coords.concatenate">
<em class="property">classmethod </em><tt class="descname">concatenate</tt><big>(</big><em>clas</em>, <em>L</em>, <em>axis=0</em><big>)</big><a class="headerlink" href="#coords.Coords.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate a list of <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>All <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object in the list L should have the same shape
except for the length of the specified axis.
This function is equivalent to the numpy concatenate, but makes
sure the result is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object,and the default axis
is the first one instead of the last.</p>
<p>The result is at least a 2D array, even when the list contains
a single Coords with a single point.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[</span><span class="mf">2.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">])</span>
<span class="go">[[ 1.  1.  0.]</span>
<span class="go"> [ 2.  2.  0.]</span>
<span class="go"> [ 3.  3.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">])</span>
<span class="go">[[ 1.  1.  0.]</span>
<span class="go"> [ 1.  1.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">Y</span><span class="p">])</span>
<span class="go">[[ 2.  2.  0.]</span>
<span class="go"> [ 3.  3.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">X</span><span class="p">])</span>
<span class="go">[[ 1.  1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="coords.Coords.fromstring">
<em class="property">classmethod </em><tt class="descname">fromstring</tt><big>(</big><em>clas</em>, <em>fil</em>, <em>sep=' '</em>, <em>ndim=3</em>, <em>count=-1</em><big>)</big><a class="headerlink" href="#coords.Coords.fromstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object with data from a string.</p>
<p>This convenience function uses the <tt class="xref py py-func docutils literal"><span class="pre">numpy.fromstring()</span></tt>
function to read coordinates from a string.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>fil</cite>: a string containing a single sequence of float numbers separated
by whitespace and a possible separator string.</li>
<li><cite>sep</cite>: the separator used between the coordinates. If not a space,
all extra whitespace is ignored.</li>
<li><cite>ndim</cite>: number of coordinates per point. Should be 1, 2 or 3 (default).
If 1, resp. 2, the coordinate string only holds x, resp. x,y
values.</li>
<li><cite>count</cite>: total number of coordinates to read. This should be a multiple
of 3. The default is to read all the coordinates in the string.
count can be used to force an error condition if the string
does not contain the expected number of values.</li>
</ul>
<p>The return value is  Coords object.</p>
</dd></dl>

<dl class="classmethod">
<dt id="coords.Coords.fromfile">
<em class="property">classmethod </em><tt class="descname">fromfile</tt><big>(</big><em>clas</em>, <em>fil</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#coords.Coords.fromfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> from file.</p>
<p>This convenience function uses the numpy fromfile function to read
the coordinates from file.
You just have to make sure that the coordinates are read in order
(X,Y,Z) for subsequent points, and that the total number of
coordinates read is a multiple of 3.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.interpolate">
<tt class="descname">interpolate</tt><big>(</big><em>X</em>, <em>div</em><big>)</big><a class="headerlink" href="#coords.Coords.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create interpolations between two <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>X</cite>: a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with same shape as <cite>self</cite>.</li>
<li><cite>div</cite>: a list of floating point values, or an int. If an int
is specified, a list with (div+1) values for <cite>div</cite> is created
by dividing the interval [0..1] into <cite>div</cite> equal distances.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with an extra (first) axis, containing the
concatenation of the interpolations of <cite>self</cite> and <cite>X</cite> at all
values in <cite>div</cite>.
Its shape is (n,) + self.shape, where n is the number of values
in <cite>div</cite>.</div></blockquote>
<p>An interpolation of F and G at value v is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> H where
each coordinate Hijk is obtained from:  Fijk = Fijk + v * (Gijk-Fijk).
Thus, X.interpolate(Y,[0.,0.5,1.0]) will contain all points of
X and Y and all points with mean coordinates between those of X and Y.</p>
<p>F.interpolate(G,n) is equivalent with
F.interpolate(G,arange(0,n+1)/float(n))</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.rot">
<tt class="descname">rot</tt><big>(</big><em>angle</em>, <em>axis=2</em>, <em>around=None</em><big>)</big><a class="headerlink" href="#coords.Coords.rot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy rotated over angle around axis.</p>
<p>The angle is specified in degrees.
The axis is either one of (0,1,2) designating the global axes,
or a vector specifying an axis through the origin.
If no axis is specified, rotation is around the 2(z)-axis. This is
convenient for working on 2D-structures.</p>
<p>As a convenience, the user may also specify a 3x3 rotation matrix,
in which case the function rotate(mat) is equivalent to affine(mat).</p>
<p>All rotations are performed around the point [0.,0.,0.], unless a
rotation origin is specified in the argument &#8216;around&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.trl">
<tt class="descname">trl</tt><big>(</big><em>dir</em>, <em>step=None</em>, <em>inplace=False</em><big>)</big><a class="headerlink" href="#coords.Coords.trl" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Translates the Coords in the direction <cite>dir</cite> over a distance
<cite>step * length(dir)</cite>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the direction and distance of the translation. It
can be either<ul>
<li>an axis number (0,1,2), specifying a unit vector in the direction
of one of the coordinate axes.</li>
<li>a single translation vector,</li>
<li>an array of translation vectors, compatible with the Coords shape.</li>
</ul>
</li>
<li><cite>step</cite>: If specified, the translation vector specified by <cite>dir</cite> will
be multiplied with this value. It is commonly used with unit <cite>dir</cite>
vectors to set the translation distance.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="coords.Coords.rep">
<tt class="descname">rep</tt><big>(</big><em>n</em>, <em>dir=0</em>, <em>step=None</em><big>)</big><a class="headerlink" href="#coords.Coords.rep" title="Permalink to this definition">¶</a></dt>
<dd><p>Replicate a Coords n times with fixed step in any direction.</p>
<p>Returns a Coords object with shape <cite>(n,) + self.shape</cite>, thus having
an extra first axis.
Each component along the axis 0 is equal to the previous component
translated over <cite>(dir,step)</cite>, where <cite>dir</cite> and <cite>step</cite> are
interpreted just like in the <a class="reference internal" href="#coords.Coords.translate" title="coords.Coords.translate"><tt class="xref py py-meth docutils literal"><span class="pre">translate()</span></tt></a> method.
The first component along the axis 0 is identical to the
original Coords.</p>
</dd></dl>

</dd></dl>

<p><tt class="docutils literal"><span class="pre">Functions</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">coords</span></tt></p>
<dl class="function">
<dt id="coords.bbox">
<tt class="descclassname">coords.</tt><tt class="descname">bbox</tt><big>(</big><em>objects</em><big>)</big><a class="headerlink" href="#coords.bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bounding box of a list of objects.</p>
<p>The bounding box of an object is the smallest rectangular cuboid
in the global Cartesian coordinates, such that no points of the
objects lie outside that cuboid. The resulting bounding box of the list
of objects is the smallest bounding box that encloses all the objects
in the list. Objects that do not have a <a class="reference internal" href="#coords.bbox" title="coords.bbox"><tt class="xref py py-meth docutils literal"><span class="pre">bbox()</span></tt></a> method or whose
<a class="reference internal" href="#coords.bbox" title="coords.bbox"><tt class="xref py py-meth docutils literal"><span class="pre">bbox()</span></tt></a> method returns invalid values, are ignored.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>objects</cite>: a list of objects (which should probably have the method
<a class="reference internal" href="#coords.bbox" title="coords.bbox"><tt class="xref py py-meth docutils literal"><span class="pre">bbox()</span></tt></a>).</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A Coords object with two points: the first contains the minimal
coordinate values, the second has the maximal ones of the overall
bounding box.</div></blockquote>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">formex</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bbox</span><span class="p">([</span><span class="n">Coords</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]),</span><span class="n">Formex</span><span class="p">(</span><span class="s">&#39;l:5&#39;</span><span class="p">)])</span>
<span class="go">Coords([[-1.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="coords.bboxIntersection">
<tt class="descclassname">coords.</tt><tt class="descname">bboxIntersection</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#coords.bboxIntersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the intersection of the bounding box of two objects.</p>
<p>A and B are objects having a bbox method. The intersection of the two
bounding boxes is returned in boox format.</p>
</dd></dl>

<dl class="function">
<dt id="coords.testBbox">
<tt class="descclassname">coords.</tt><tt class="descname">testBbox</tt><big>(</big><em>A, bb, dirs=[0, 1, 2], nodes='any'</em><big>)</big><a class="headerlink" href="#coords.testBbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Test which part of A is inside a given bbox, applied in directions dirs.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>A</cite>: is any object having bbox and a test method (Formex, Mesh).</li>
<li><cite>bb</cite>: is a bounding box, i.e. a (2,3) shape float array.</li>
<li><cite>dirs</cite>: is a list of the three coordinate axes or a subset thereof.</li>
<li><cite>nodes</cite>: has the same meaning as in Formex.test and Mesh.test.</li>
</ul>
<p>The result is a bool array flagging the elements that are inside the given
bounding box.</p>
</dd></dl>

<dl class="function">
<dt id="coords.origin">
<tt class="descclassname">coords.</tt><tt class="descname">origin</tt><big>(</big><big>)</big><a class="headerlink" href="#coords.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a single point with coordinates [0.,0.,0.].</p>
<p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object with shape(3,) holding three zero
coordinates.</p>
</dd></dl>

<dl class="function">
<dt id="coords.pattern">
<tt class="descclassname">coords.</tt><tt class="descname">pattern</tt><big>(</big><em>s</em>, <em>aslist=False</em><big>)</big><a class="headerlink" href="#coords.pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a series of points lying on a regular grid.</p>
<p>This function creates a series of points that lie on a regular grid
with unit step. These points are created from a string input, interpreting
each character as a code specifying how to move to the next point.
The start position is always the origin (0.,0.,0.).</p>
<p>Currently the following codes are defined:</p>
<ul class="simple">
<li>0: goto origin (0.,0.,0.)</li>
<li>1..8: move in the x,y plane</li>
<li>9 or .: remain at the same place (i.e. duplicate the last point)</li>
<li>A..I: same as 1..9 plus step +1. in z-direction</li>
<li>a..i: same as 1..9 plus step -1. in z-direction</li>
<li>/: do not insert the next point</li>
</ul>
<p>Any other character raises an error.</p>
<p>When looking at the x,y-plane with the x-axis to the right and the
y-axis up, we have the following basic moves:
1 = East, 2 = North, 3 = West, 4 = South, 5 = NE, 6 = NW, 7 = SW, 8 = SE.</p>
<p>Adding 16 to the ordinal of the character causes an extra move of +1. in
the z-direction. Adding 48 causes an extra move of -1. This means that
&#8216;ABCDEFGHI&#8217;, resp. &#8216;abcdefghi&#8217;, correspond with &#8216;123456789&#8217; with an extra
z +/-= 1. This gives the following schema:</p>
<div class="highlight-python"><pre>    z+=1             z unchanged            z -= 1

F    B    E          6    2    5         f    b    e
     |                    |                   |
     |                    |                   |
C----I----A          3----9----1         c----i----a
     |                    |                   |
     |                    |                   |
G    D    H          7    4    8         g    d    h</pre>
</div>
<p>The special character &#8216;/&#8217; can be put before any character to make the
move without inserting the new point. You need to start
the string with a &#8216;0&#8217; or &#8216;9&#8217; to include the origin in the output.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>s</cite>: string: with the characters generating subsequent points.</li>
<li><cite>aslist</cite>: bool: if True, the points are returned as lists of
integer coordinates instead of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</li>
</ul>
<p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with the generated points (default) or a list
of tuples with 3 integer coordinates (if <cite>aslist</cite> is True).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pattern</span><span class="p">(</span><span class="s">&#39;0123&#39;</span><span class="p">)</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 1.  0.  0.]</span>
<span class="go"> [ 1.  1.  0.]</span>
<span class="go"> [ 0.  1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="coords.xpattern">
<tt class="descclassname">coords.</tt><tt class="descname">xpattern</tt><big>(</big><em>s</em>, <em>nplex=1</em><big>)</big><a class="headerlink" href="#coords.xpattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Coords object from a string pattern.</p>
<p>This is like pattern, but allows grouping the points into elements.
First, the string is expanded to a list of points by calling pattern(s).
Then the resulting list of points is transformed in a 2D table of points
where each row has the length <cite>nplex</cite>.</p>
<p>If the number of points produced by <cite>s</cite> is not a multiple of <cite>nplex</cite>,
an error is raised.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">xpattern</span><span class="p">(</span><span class="s">&#39;.12.34&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[[ 0.  0.  0.]</span>
<span class="go">  [ 1.  0.  0.]</span>
<span class="go">  [ 1.  1.  0.]]</span>

<span class="go"> [[ 1.  1.  0.]</span>
<span class="go">  [ 0.  1.  0.]</span>
<span class="go">  [ 0.  0.  0.]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="coords.align">
<tt class="descclassname">coords.</tt><tt class="descname">align</tt><big>(</big><em>L, align, offset=[0.0, 0.0, 0.0]</em><big>)</big><a class="headerlink" href="#coords.align" title="Permalink to this definition">¶</a></dt>
<dd><p>Align a list of geometrical objects.</p>
<p>L is a list of geometrical objects (Coords or Geometry or subclasses
thereof) and thus having an appropriate <tt class="docutils literal"><span class="pre">align</span></tt> method.
align is a string of three characters, one for each coordinate direction,
defining how the subsequent objects have to be aligned in that direction:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-</span></tt> : align on the minimal coordinate value</li>
<li><tt class="docutils literal"><span class="pre">+</span></tt> : align on the maximal coordinate value</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt> : align on the middle coordinate value</li>
<li><tt class="docutils literal"><span class="pre">|</span></tt> : align the minimum value on the maximal value of the previous item</li>
</ul>
<p>E.g., the string <tt class="docutils literal"><span class="pre">'|--'</span></tt> will juxtapose the objects in the x-direction,
while aligning them on their minimal coordinates in the y- and z- direction.</p>
<p>An offset may be specified to create a space between the object, instead
of juxtaposing them.</p>
<p>Returns: a list with the aligned objects.</p>
</dd></dl>

<dl class="function">
<dt id="coords.sweepCoords">
<tt class="descclassname">coords.</tt><tt class="descname">sweepCoords</tt><big>(</big><em>self, path, origin=[0.0, 0.0, 0.0], normal=0, upvector=2, avgdir=False, enddir=None, scalex=None, scaley=None</em><big>)</big><a class="headerlink" href="#coords.sweepCoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Sweep a Coords object along a path, returning a series of copies.</p>
<p>origin and normal define the local path position and direction on the mesh.</p>
<p>At each point of the curve, a copy of the Coords object is created, with
its origin in the curve&#8217;s point, and its normal along the curve&#8217;s direction.
In case of a PolyLine, directions are pointing to the next point by default.
If avgdir==True, average directions are taken at the intermediate points
avgdir can also be an array like sequence of shape (N,3) to explicitely set the
the directions for ALL the points of the path</p>
<p>Missing end directions can explicitely be set by enddir, and are by default
taken along the last segment.
enddir is a list of 2 array like values of shape (3). one of the two can also be an empty list
If the curve is closed, endpoints are treated as any intermediate point,
and the user should normally not specify enddir.</p>
<p>At each point of the curve, the original Coords object can be scaled in x
and y direction by specifying scalex and scaley. The number of values
specified in scalex and scaly should be equal to the number of points on
the curve.</p>
<p>The return value is a sequence of the transformed Coords objects.</p>
</dd></dl>

</div>
<div class="section" id="id53">
<span id="id54"></span><h1>2. <a class="reference internal" href="#module-coords" title="coords: A structured collection of 3D coordinates."><tt class="xref py py-mod docutils literal"><span class="pre">coords</span></tt></a> &#8212; A structured collection of 3D coordinates.<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-coords"></span><p>The <a class="reference internal" href="#module-coords" title="coords: A structured collection of 3D coordinates."><tt class="xref py py-mod docutils literal"><span class="pre">coords</span></tt></a> module defines the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> class, which is the basic
data structure in pyFormex to store the coordinates of points in a 3D space.</p>
<p>This module implements a data class for storing large sets of 3D coordinates
and provides an extensive set of methods for transforming these coordinates.
Most of pyFormex&#8217;s classes which represent geometry (e.g. <tt class="xref py py-class docutils literal"><span class="pre">Geometry</span></tt>,
<tt class="xref py py-class docutils literal"><span class="pre">Formex</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">Mesh</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">TriSurface</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">Curve</span></tt>) use a
<a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object to store their coordinates, and thus inherit all the
transformation methods of this class.</p>
<p>While the user will mostly use the higher level classes, he might occasionally
find good reason to use the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> class directly as well.</p>
<p><tt class="docutils literal"><span class="pre">Classes</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">coords</span></tt></p>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">coords.</tt><tt class="descname">Coords</tt></dt>
<dd><p>A structured collection of points in a 3D cartesian space.</p>
<p>The <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> class is the basic data structure used throughout
pyFormex to store coordinates of points in a 3D space.
It is used by other classes, such as <tt class="xref py py-class docutils literal"><span class="pre">Formex</span></tt>
and <tt class="xref py py-class docutils literal"><span class="pre">Surface</span></tt>, which thus inherit the same transformation
capabilities. Applications will mostly use the higher level
classes, which usually have more elaborated consistency checking
and error handling.</p>
<p><a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is implemented as a subclass of <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>,
and thus inherits all its methods.
The last axis of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> always has a length equal to 3.
Each set of 3 values along the last axis represents a single point
in 3D cartesian space. The float datatype is only checked at creation
time. It is the responsibility of the user to keep this consistent
throughout the lifetime of the object.</p>
<p>A new Coords object is created with the following syntax</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Coords</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">dtyp</span><span class="o">=</span><span class="n">Float</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters:</p>
<ul class="simple">
<li><cite>data</cite>: array_like of type float.
The last axis should have a length of 1, 2 or 3, bu will always be
expanded to 3.
If no data are specified, an empty Coords with shape (0,3) is created.</li>
<li><cite>dtyp</cite>: the float datatype to be used.
It not specified, the datatype of <cite>data</cite> is used, or the default
<tt class="xref py py-data docutils literal"><span class="pre">Float</span></tt> (which is equivalent to <tt class="xref py py-data docutils literal"><span class="pre">numpy.float32</span></tt>).</li>
<li><cite>copy</cite>: boolean.
If <tt class="docutils literal"><span class="pre">True</span></tt>, the data are copied. The default setting will try to use
the original data if possible, e.g. if <cite>data</cite> is a correctly shaped and
typed <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">Coords([ 1.,  0.,  0.], dtype=float32)</span>
</pre></div>
</div>
<dl class="method">
<dt>
<tt class="descname">points</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object as a simple set of points.</p>
<p>This reshapes the array to a 2-dimensional array, flattening
the structure of the points.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">pshape</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the shape of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>This is the shape of the <a class="reference external" href="http://numpy.scipy.org">NumPy</a> array with the last axis removed.
The full shape of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> array can be obtained from
its shape attribute.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">npoints</tt><big>(</big><big>)</big></dt>
<dd><p>Return the total number of points.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">ncoords</tt><big>(</big><big>)</big></dt>
<dd><p>Return the total number of points.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">x</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the X-coordinates of all points.</p>
<p>Returns an array with all the X-coordinates in the Coords.
The returned array has the same shape as the Coords array along
its first ndim-1 axes.
This is equivalent with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">y</tt><big>(</big><big>)</big></dt>
<dd><p>Return the Y-coordinates of all points.</p>
<p>Returns an array with all the Y-coordinates in the Coords.
The returned array has the same shape as the Coords array along
its first ndim-1 axes.
This is equivalent with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">z</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the Z-coordinates of all points.</p>
<p>Returns an array with all the Z-coordinates in the Coords.
The returned array has the same shape as the Coords array along
its first ndim-1 axes.
This is equivalent with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bbox</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the bounding box of a set of points.</p>
<p>The bounding box is the smallest rectangular volume in the global
coordinates, such that no point of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> are outside
that volume.</p>
<p>Returns a Coords object with shape(2,3): the first point contains the
minimal coordinates, the second has the maximal ones.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">bbox</span><span class="p">()</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 3.  3.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">apt</tt><big>(</big><em>align</em><big>)</big></dt>
<dd><p>Returns an alignment point of a Coords.</p>
<p>Alignment point are points whose coordinates are either the minimal
value, the maximal value or the middle value for the Coords.
Combining the three values with the three dimensions, a Coords
has in 27 (3**3) alignment points. The corner points of the
bounding box are a subset of these.</p>
<p>The 27 points are addressed by an alignment string of three
characters, one for each direction. Each character should be
one of the following</p>
<ul class="simple">
<li>&#8216;-&#8216;: use the minimal value for that coordinate,</li>
<li>&#8216;+&#8217;: use the minimal value for that coordinate,</li>
<li>&#8216;0&#8217;: use the middle value for that coordinate.</li>
</ul>
<p>Any other character will set the corresponding coordinate to zero.</p>
<p>A string &#8216;000&#8217; is equivalent with center(). The values &#8216;&#8212;&#8217; and
&#8216;+++&#8217; give the points of the bounding box.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">apt</span><span class="p">(</span><span class="s">&#39;-0+&#39;</span><span class="p">)</span>
<span class="go">[ 0.   0.5  1. ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">center</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the center of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The center of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is the center of its bbox().
The return value is a (3,) shaped <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
<span class="go">[ 1.5  1.5  0. ]</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#coords.Coords.centroid" title="coords.Coords.centroid"><tt class="xref py py-meth docutils literal"><span class="pre">centroid()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">average</tt><big>(</big><em>wts=None</em>, <em>axis=0</em><big>)</big></dt>
<dd><p>Returns a (weighted) average of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The average of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with one
axis less than the original, obtained by averaging all the points
along that axis.
The weights array can either be 1-D (in which case its length must
be the size along the given axis) or of the same shape as a.
Weights can be specified as a 1-D array with the length of that axis,
or as an array with the same shape as the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.
The sum of the weights (along the specified axis if not 1-D) will
generally be equal to 1.0.
If wts=None, then all points are assumed to have a weight equal to
one divided by the length of the specified axis.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]],</span>                   <span class="p">[[</span><span class="mf">4.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">5.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">6.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">average</span><span class="p">()</span>
<span class="go">[[ 2.  0.  0.]</span>
<span class="go"> [ 3.  0.  0.]</span>
<span class="go"> [ 4.  0.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 5.  0.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">wts</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.25</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[[ 0.75  0.    0.  ]</span>
<span class="go"> [ 4.75  0.    0.  ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">centroid</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the centroid of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The centroid of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is the point whose coordinates
are the mean values of all points.
The return value is a (3,) shaped <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
<span class="go">[ 1.  1.  0.]</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#coords.Coords.center" title="coords.Coords.center"><tt class="xref py py-meth docutils literal"><span class="pre">center()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">sizes</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the sizes of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>Returns an array with the length of the bbox along the 3 axes.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">sizes</span><span class="p">()</span>
<span class="go">[ 3.  3.  0.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">dsize</tt><big>(</big><big>)</big></dt>
<dd><p>Returns an estimate of the global size of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>This estimate is the length of the diagonal of the bbox().</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">dsize</span><span class="p">()</span>
<span class="go">4.24264</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bsphere</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the diameter of the bounding sphere of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The bounding sphere is the smallest sphere with center in the
center() of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>, and such that no points of the
<a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> are lying outside the sphere.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">bsphere</span><span class="p">()</span>
<span class="go">2.12132024765</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">inertia</tt><big>(</big><em>mass=None</em><big>)</big></dt>
<dd><p>Returns inertia related quantities of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>mass</cite>: float array with ncoords weight values. The default is to
attribute a weight 1.0 to each point.</li>
</ul>
<p>Returns a tuple of:</p>
<ul class="simple">
<li><cite>center</cite>: the center of mass: shape (3,)</li>
<li><cite>axes</cite>: the principal axes of the inertia tensor: shape (3,3)</li>
<li><cite>principal</cite>: the (prinicipal) moments of inertia: shape (3,)</li>
<li><cite>tensor</cite>: the full inertia tensor in the global axes: shape (3,3)</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">distanceFromPlane</tt><big>(</big><em>p</em>, <em>n</em><big>)</big></dt>
<dd><p>Returns the distance of all points from the plane (p,n).</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>p</cite>: is a point specified by 3 coordinates.</li>
<li><cite>n</cite>: is the normal vector to a plane, specified by 3 components.</li>
</ul>
<p>The return value is a float array with shape <tt class="docutils literal"><span class="pre">self.pshape()</span></tt> with
the distance of each point to the plane through p and having normal n.
Distance values are positive if the point is on the side of the
plane indicated by the positive normal.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">distanceFromPlane</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">[[ 0.  3.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">distanceFromLine</tt><big>(</big><em>p</em>, <em>n</em><big>)</big></dt>
<dd><p>Returns the distance of all points from the line (p,n).</p>
<p>p,n are (1,3) or (npts,3) arrays defining 1 or npts lines</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>p</cite>: is a point on the line specified by 3 coordinates.</li>
<li><cite>n</cite>: is a vector specifying the direction of the line through p.</li>
</ul>
<p>The return value is a [...] shaped array with the distance of
each point to the line through p with direction n.
All distance values are positive or zero.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">distanceFromLine</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">[[ 0.  0.  3.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">distanceFromPoint</tt><big>(</big><em>p</em><big>)</big></dt>
<dd><p>Returns the distance of all points from the point p.</p>
<p>p is a single point specified by 3 coordinates.</p>
<p>The return value is a [...] shaped array with the distance of
each point to point p.
All distance values are positive or zero.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">distanceFromPoint</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">[[ 0.  3.  3.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">closestToPoint</tt><big>(</big><em>p</em><big>)</big></dt>
<dd><p>Returns the point closest to point p.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">directionalSize</tt><big>(</big><em>n</em>, <em>p=None</em>, <em>_points=False</em><big>)</big></dt>
<dd><p>Returns the extreme distances from the plane p,n.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>n</cite>: the direction can be specified by a 3 component vector or by
a single integer 0..2 designing one of the coordinate axes.</li>
<li><cite>p</cite>: is any point in space. If not specified, it is taken as the
center() of the Coords.</li>
</ul>
<p>The return value is a tuple of two float values specifying the
extreme distances from the plane p,n.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">directionalExtremes</tt><big>(</big><em>n</em>, <em>p=None</em><big>)</big></dt>
<dd><p>Returns extremal planes in the direction n.</p>
<p><cite>n</cite> and <cite>p</cite> have the same meaning as in <cite>directionalSize</cite>.</p>
<p>The return value is a list of two points on the line (p,n),
such that the planes with normal n through these points define
the extremal planes of the Coords.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">directionalWidth</tt><big>(</big><em>n</em><big>)</big></dt>
<dd><p>Returns the width of a Coords in the given direction.</p>
<p>The direction can be specified by a 3 component vector or by
a single integer 0..2 designating one of the coordinate axes.</p>
<p>The return value is the thickness of the object in the direction n.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">test</tt><big>(</big><em>dir=0</em>, <em>min=None</em>, <em>max=None</em>, <em>atol=0.0</em><big>)</big></dt>
<dd><p>Flag points having coordinates between min and max.</p>
<p>Tests the position of the points of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with respect to
one or two planes. This method is very convenient in clipping a
<a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> in a specified direction. In most cases the clipping
direction is one of the global cooordinate axes, but a general
direction may be used as well.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: either a global axis number (0, 1 or 2) or a direction vector
consisting of 3 floats. It specifies the direction in which the
distances are measured. Default is the 0 (or x) direction.</li>
<li><cite>min</cite>, <cite>max</cite>: position of the minimum and maximum clipping planes.
If <cite>dir</cite> was specified as an integer (0,1,2), this is a single float
value corresponding with the coordinate in that axis direction.
Else, it is a point in the clipping plane with normal direction <cite>dir</cite>.
One of the two clipping planes may be left unspecified.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A 1D integer array with same length as the number of points.
For each point the value is 1 (True) if the point is above the
minimum clipping plane and below the maximum clipping plane,
or 0 (False) otherwise.
An unspecified clipping plane corresponds with an infinitely low or
high value. The return value can directly be used as an index to
obtain a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with the points satisfying the test (or not).
See the examples below.</div></blockquote>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[False  True False False]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="nb">max</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
<span class="go">[[ 0.  1.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">t</span><span class="p">]</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 1.  0.  0.]</span>
<span class="go"> [ 0.  2.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">fprint</tt><big>(</big><em>fmt='%10.3e %10.3e %10.3e'</em><big>)</big></dt>
<dd><p>Formatted printing of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>The supplied format should contain 3 formatting sequences for the
three coordinates of a point.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">set</tt><big>(</big><em>f</em><big>)</big></dt>
<dd><p>Set the coordinates from those in the given array.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">scale</tt><big>(</big><em>scale</em>, <em>dir=None</em>, <em>center=None</em>, <em>inplace=False</em><big>)</big></dt>
<dd><p>Returns a copy scaled with scale[i] in direction i.</p>
<p>The scale should be a list of 3 scaling factors for the 3 axis
directions, or a single scaling factor.
In the latter case, dir (a single axis number or a list) may be given
to specify the direction(s) to scale. The default is to produce a
homothetic scaling.
The center of the scaling, if not specified, is the global origin.
If a center is specified, the result is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="nb">dir</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[ 2.  2.  2.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span><span class="o">.</span><span class="n">scale</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">[ 2.  3.  4.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">translate</tt><big>(</big><em>dir</em>, <em>step=None</em>, <em>inplace=False</em><big>)</big></dt>
<dd><p>Translate a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Translates the Coords in the direction <cite>dir</cite> over a distance
<cite>step * length(dir)</cite>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the direction and distance of the translation. It
can be either<ul>
<li>an axis number (0,1,2), specifying a unit vector in the direction
of one of the coordinate axes.</li>
<li>a single translation vector,</li>
<li>an array of translation vectors, compatible with the Coords shape.</li>
</ul>
</li>
<li><cite>step</cite>: If specified, the translation vector specified by <cite>dir</cite> will
be multiplied with this value. It is commonly used with unit <cite>dir</cite>
vectors to set the translation distance.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">centered</tt><big>(</big><big>)</big></dt>
<dd><p>Returns a centered copy of the Coords.</p>
<p>Returns a Coords which is a translation thus that the center
coincides with the origin.
This is equivalent with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">trl</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">align</tt><big>(</big><em>alignment='---', point=[0.0, 0.0, 0.0]</em><big>)</big></dt>
<dd><p>Align a Coords on a given point.</p>
<p>Alignment involves a translation such that the bounding box
of the Coords object becomes aligned with a given point.
By default this is the origin of the global axes.
The requested alignment is determined by a string of three characters,
one for each of the coordinate axes. The character determines how
the structure is aligned in the corresponding direction:</p>
<ul class="simple">
<li>&#8216;-&#8216;: aligned on the minimal value of the bounding box,</li>
<li>&#8216;+&#8217;: aligned on the maximal value of the bounding box,</li>
<li>&#8216;0&#8217;: aligned on the middle value of the bounding box.</li>
</ul>
<p>Any other value will make the alignment in that direction unchanged.</p>
<p>The default alignment string <tt class="docutils literal"><span class="pre">'---'</span></tt> results in a translation which
puts all the points in the octant with all positive coordinate values.
A string <tt class="docutils literal"><span class="pre">'000'</span></tt> will center the object around the origin, just like
the (slightly faster) <a class="reference internal" href="#coords.Coords.centered" title="coords.Coords.centered"><tt class="xref py py-meth docutils literal"><span class="pre">centered()</span></tt></a> method.</p>
<p>See also the <a class="reference internal" href="#coords.align" title="coords.align"><tt class="xref py py-func docutils literal"><span class="pre">coords.align()</span></tt></a> function.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">rotate</tt><big>(</big><em>angle</em>, <em>axis=2</em>, <em>around=None</em><big>)</big></dt>
<dd><p>Returns a copy rotated over angle around axis.</p>
<p>The angle is specified in degrees.
The axis is either one of (0,1,2) designating the global axes,
or a vector specifying an axis through the origin.
If no axis is specified, rotation is around the 2(z)-axis. This is
convenient for working on 2D-structures.</p>
<p>As a convenience, the user may also specify a 3x3 rotation matrix,
in which case the function rotate(mat) is equivalent to affine(mat).</p>
<p>All rotations are performed around the point [0.,0.,0.], unless a
rotation origin is specified in the argument &#8216;around&#8217;.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">shear</tt><big>(</big><em>dir</em>, <em>dir1</em>, <em>skew</em>, <em>inplace=False</em><big>)</big></dt>
<dd><p>Returns a copy skewed in the direction dir of plane (dir,dir1).</p>
<p>The coordinate dir is replaced with (dir + skew * dir1).</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">reflect</tt><big>(</big><em>dir=0</em>, <em>pos=0.0</em>, <em>inplace=False</em><big>)</big></dt>
<dd><p>Reflect the coordinates in direction dir against plane at pos.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: int: direction of the reflection (default 0)</li>
<li><cite>pos</cite>: float: offset of the mirror plane from origin (default 0.0)</li>
<li><cite>inplace</cite>: boolean: change the coordinates inplace (default False)</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">affine</tt><big>(</big><em>mat</em>, <em>vec=None</em><big>)</big></dt>
<dd><p>Perform a general affine transformation.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>mat</cite>: a 3x3 float matrix</li>
<li><cite>vec</cite>: a length 3 list or array of floats</li>
</ul>
<p>The returned object has coordinates given by <tt class="docutils literal"><span class="pre">self</span> <span class="pre">*</span> <span class="pre">mat</span> <span class="pre">+</span> <span class="pre">vec</span></tt>.
If <cite>mat</cite> is a rotation matrix, than the operation performs a
rigid rotation of the object plus a translation.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">position</tt><big>(</big><em>x</em>, <em>y</em><big>)</big></dt>
<dd><p>Position an object so that points x are aligned with y.</p>
<p>Parameters are as for <a class="reference internal" href="arraytools.html#arraytools.trfMatrix" title="arraytools.trfMatrix"><tt class="xref py py-func docutils literal"><span class="pre">arraytools.trfMatrix()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">cylindrical</tt><big>(</big><em>dir=[0, 1, 2], scale=[1.0, 1.0, 1.0], angle_spec=0.017453292519943295</em><big>)</big></dt>
<dd><p>Converts from cylindrical to cartesian after scaling.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates are interpreted as resp.
distance(r), angle(theta) and height(z). Default order is [r,theta,z].</li>
<li><cite>scale</cite>: will scale the coordinate values prior to the transformation.
(scale is given in order r,theta,z).</li>
</ul>
<p>The resulting angle is interpreted in degrees.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">toCylindrical</tt><big>(</big><em>dir=[0, 1, 2], angle_spec=0.017453292519943295</em><big>)</big></dt>
<dd><p>Converts from cartesian to cylindrical coordinates.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates axes are parallel to respectively the
cylindrical axes distance(r), angle(theta) and height(z). Default
order is [x,y,z].</li>
</ul>
<p>The angle value is given in degrees.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">spherical</tt><big>(</big><em>dir=[0, 1, 2], scale=[1.0, 1.0, 1.0], angle_spec=0.017453292519943295, colat=False</em><big>)</big></dt>
<dd><p>Converts from spherical to cartesian after scaling.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates are interpreted as resp.
longitude(theta), latitude(phi) and distance(r).</li>
<li><cite>scale</cite>: will scale the coordinate values prior to the transformation.</li>
</ul>
<p>Angles are interpreted in degrees.
Latitude, i.e. the elevation angle, is measured from equator in
direction of north pole(90). South pole is -90.</p>
<p>If colat=True, the third coordinate is the colatitude (90-lat) instead.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">superSpherical</tt><big>(</big><em>n=1.0, e=1.0, k=0.0, dir=[0, 1, 2], scale=[1.0, 1.0, 1.0], angle_spec=0.017453292519943295, colat=False</em><big>)</big></dt>
<dd><p>Performs a superspherical transformation.</p>
<p>superSpherical is much like spherical, but adds some extra
parameters to enable the creation of virtually any surface.</p>
<p>Just like with spherical(), the input coordinates are interpreted as
the longitude, latitude and distance in a spherical coordinate system.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates are interpreted as resp.longitude(theta),
latitude(phi) and distance(r).
Angles are then interpreted in degrees.
Latitude, i.e. the elevation angle, is measured from equator in
direction of north pole(90). South pole is -90.
If colat=True, the third coordinate is the colatitude (90-lat) instead.</li>
<li><cite>scale</cite>: will scale the coordinate values prior to the transformation.</li>
<li><cite>n</cite>, <cite>e</cite>: parameters define exponential transformations of the
north_south (latitude), resp. the east_west (longitude) coordinates.
Default values of 1 result in a circle.</li>
<li><cite>k</cite>: adds &#8216;eggness&#8217; to the shape: a difference between the northern and
southern hemisphere. Values &gt; 0 enlarge the southern hemishpere and
shrink the northern.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">toSpherical</tt><big>(</big><em>dir=[0, 1, 2], angle_spec=0.017453292519943295</em><big>)</big></dt>
<dd><p>Converts from cartesian to spherical coordinates.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates axes are parallel to respectively
the spherical axes distance(r), longitude(theta) and latitude(phi).
Latitude is the elevation angle measured from equator in direction
of north pole(90). South pole is -90.
Default order is [0,1,2], thus the equator plane is the (x,y)-plane.</li>
</ul>
<p>The returned angle values are given in degrees.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bump1</tt><big>(</big><em>dir</em>, <em>a</em>, <em>func</em>, <em>dist</em><big>)</big></dt>
<dd><p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with a one-dimensional bump.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the axis of the modified coordinates;</li>
<li><cite>a</cite>: is the point that forces the bumping;</li>
<li><cite>dist</cite>: specifies the direction in which the distance is measured;</li>
<li><cite>func</cite>: is a function that calculates the bump intensity from distance
and should be such that <tt class="docutils literal"><span class="pre">func(0)</span> <span class="pre">!=</span> <span class="pre">0</span></tt>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bump2</tt><big>(</big><em>dir</em>, <em>a</em>, <em>func</em><big>)</big></dt>
<dd><p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with a two-dimensional bump.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the axis of the modified coordinates;</li>
<li><cite>a</cite>: is the point that forces the bumping;</li>
<li><cite>func</cite>: is a function that calculates the bump intensity from distance
!! func(0) should be different from 0.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bump</tt><big>(</big><em>dir</em>, <em>a</em>, <em>func</em>, <em>dist=None</em><big>)</big></dt>
<dd><p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with a bump.</p>
<p>A bump is a modification of a set of coordinates by a non-matching
point. It can produce various effects, but one of the most common
uses is to force a surface to be indented by some point.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the axis of the modified coordinates;</li>
<li><cite>a</cite>: is the point that forces the bumping;</li>
<li><cite>func</cite>: is a function that calculates the bump intensity from distance
(!! func(0) should be different from 0)</li>
<li><cite>dist</cite>: is the direction in which the distance is measured : this can
be one of the axes, or a list of one or more axes.
If only 1 axis is specified, the effect is like function bump1
If 2 axes are specified, the effect is like bump2
This function can take 3 axes however.
Default value is the set of 3 axes minus the direction of
modification. This function is then equivalent to bump2.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">flare</tt><big>(</big><em>xf, f, dir=[0, 2], end=0, exp=1.0</em><big>)</big></dt>
<dd><p>Create a flare at the end of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> block.</p>
<p>The flare extends over a distance <tt class="docutils literal"><span class="pre">xf</span></tt> at the start (<tt class="docutils literal"><span class="pre">end=0</span></tt>)
or end (<tt class="docutils literal"><span class="pre">end=1</span></tt>) in direction <tt class="docutils literal"><span class="pre">dir[0]</span></tt> of the coords block,
and has a maximum amplitude of <tt class="docutils literal"><span class="pre">f</span></tt> in the <tt class="docutils literal"><span class="pre">dir[1]</span></tt> direction.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">map</tt><big>(</big><em>func</em><big>)</big></dt>
<dd><p>Map a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> by a 3-D function.</p>
<p>This is one of the versatile mapping functions.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>func</cite>: is a numerical function which takes three arguments and produces
a list of three output values. The coordinates [x,y,z] will be
replaced by func(x,y,z).</li>
</ul>
<p>The function must be applicable to arrays, so it should
only include numerical operations and functions understood by the
numpy module.
This method is one of several mapping methods. See also map1 and mapd.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="mi">4</span><span class="o">*</span><span class="n">z</span><span class="p">])</span>
<span class="go">[[ 2.  3.  4.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">map1</tt><big>(</big><em>dir</em>, <em>func</em>, <em>x=None</em><big>)</big></dt>
<dd><p>Map one coordinate by a 1-D function of one coordinate.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>func</cite>: is a numerical function which takes one argument and produces
one result. The coordinate dir will be replaced by func(coord[x]).
If no x is specified, x is taken equal to dir.</li>
</ul>
<p>The function must be applicable on arrays, so it should only
include numerical operations and functions understood by the
numpy module.
This method is one of several mapping methods. See also map and mapd.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">mapd</tt><big>(</big><em>dir, func, point=[0.0, 0.0, 0.0], dist=None</em><big>)</big></dt>
<dd><p>Map one coordinate by a function of the distance to a point.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: 0, 1 or 2: the coordinate that will be replaced with
<tt class="docutils literal"><span class="pre">func(d)</span></tt>, where <cite>d</cite> is calculated as the distance to <cite>point</cite>.</li>
<li><cite>func</cite>: a numerical function which takes one float argument and
produce one float result. The function must be applicable on arrays,
so it should only include numerical operations and functions
understood by the <tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> module.</li>
<li><cite>point</cite>: the point to where the distance <cite>d</cite> is computed.</li>
<li><cite>dist</cite>: a list of coordinate directions that are used to compute
the distances <cite>d</cite>. It can also be a single coordinate direction.
The default is to use 3-D distances.</li>
</ul>
<p>This method is one of several mapping methods. See also
<tt class="xref py py-meth docutils literal"><span class="pre">map3()</span></tt> and <a class="reference internal" href="#coords.Coords.map1" title="coords.Coords.map1"><tt class="xref py py-meth docutils literal"><span class="pre">map1()</span></tt></a>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span><span class="o">.</span><span class="n">mapd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span><span class="n">E</span><span class="o">.</span><span class="n">center</span><span class="p">(),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>maps <tt class="docutils literal"><span class="pre">E</span></tt> on a sphere with radius 10.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">egg</tt><big>(</big><em>k</em><big>)</big></dt>
<dd><p>Maps the coordinates to an egg-shape</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">replace</tt><big>(</big><em>i</em>, <em>j</em>, <em>other=None</em><big>)</big></dt>
<dd><p>Replace the coordinates along the axes i by those along j.</p>
<p>i and j are lists of axis numbers or single axis numbers.
replace ([0,1,2],[1,2,0]) will roll the axes by 1.
replace ([0,1],[1,0]) will swap axes 0 and 1.
An optionally third argument may specify another <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object to take
the coordinates from. It should have the same dimensions.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">swapAxes</tt><big>(</big><em>i</em>, <em>j</em><big>)</big></dt>
<dd><p>Swap coordinate axes i and j.</p>
<p>Beware! This is different from numpy&#8217;s swapaxes() method !</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">rollAxes</tt><big>(</big><em>n=1</em><big>)</big></dt>
<dd><p>Roll the axes over the given amount.</p>
<p>Default is 1, thus axis 0 becomes the new 1 axis, 1 becomes 2 and
2 becomes 0.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">projectOnPlane</tt><big>(</big><em>n=2, P=[0.0, 0.0, 0.0]</em><big>)</big></dt>
<dd><p>Project a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> on a plane (or planes).</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>n</cite>: the normal direction to the plane. It can be specified either
by a list of three floats, or by a single integer (0, 1 or 2) to
use one of the global axes.</li>
<li><cite>P</cite>: a point on the plane, by default the global origin.
If an int, the plane is the coordinate plane perpendicular to the</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For planes parallel to a coordinate plane, it is far more
efficient to specify the normal by an axis number than by a
three component vector.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method will also work if any or both of P and n have
a shape (ncoords,3), where ncoords is the total number of points
in the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>. This allows to project each point on an
individual plane.</p>
</div>
<p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with same shape as original, with all the
points projected on the specified plane(s).</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">projectOnSphere</tt><big>(</big><em>radius=1.0, center=[0.0, 0.0, 0.0]</em><big>)</big></dt>
<dd><p>Project <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> on a sphere.</p>
<p>The default sphere is a unit sphere at the origin.
The center of the sphere should not be part of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">projectOnCylinder</tt><big>(</big><em>radius=1.0, dir=0, center=[0.0, 0.0, 0.0]</em><big>)</big></dt>
<dd><p>Project <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> on a cylinder with axis parallel to a global axis.</p>
<p>The default cylinder has its axis along the x-axis and a unit radius.
No points of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> should belong to the axis..</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">projectOnSurface</tt><big>(</big><em>S</em>, <em>dir=0</em>, <em>missing='error'</em>, <em>return_indices=False</em><big>)</big></dt>
<dd><p>Project the Coords on a triangulated surface.</p>
<p>The points of the Coords are projected in the specified direction dir
onto the surface S.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>S</cite>: TriSurface: any triangulated surface</li>
<li><cite>dir</cite>: int or vector: specifies the direction of the projection</li>
<li><cite>missing</cite>: float value or a string. Specifies a distance to set
the position of the projection point in cases where the projective
line does not cut the surface. The sign of the distance is taken
into account. If specified as a string, it should be one of the
strings &#8216;c&#8217;, &#8216;f&#8217;, or &#8216;m&#8217;, possibly preceded by a &#8216;+&#8217; or &#8216;-&#8216;.
The distance will then be taken equal to the closest,
the furthest, or the mean distance of a point to its projection,
and applied in positive or negative direction as specified.
Any other value of missing will result in an error if some point
does not have any projection. An error will also be raised if not
a single point projection intersects the surface.</li>
<li><cite>return_indices</cite>: if True, also returns an index of the points that
have a projection on the surface.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A Coords with the same shape as the input. If <cite>return_indices</cite>
is True, also returns an index of the points that have a projection
on the surface. This index is a sequential one, no matter what the
shape of the input Coords is.</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">isopar</tt><big>(</big><em>eltype</em>, <em>coords</em>, <em>oldcoords</em><big>)</big></dt>
<dd><p>Perform an isoparametric transformation on a Coords.</p>
<p>This is a convenience method to transform a Coords object through
an isoparametric transformation. It is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Isopar</span><span class="p">(</span><span class="n">eltype</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span><span class="n">oldcoords</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>See <tt class="xref py py-mod docutils literal"><span class="pre">plugins.isopar</span></tt> for more details.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">transformCS</tt><big>(</big><em>currentCS</em>, <em>initialCS=None</em><big>)</big></dt>
<dd><p>Perform a coordinate system transformation on the Coords.</p>
<p>This method transforms the Coords object by the transformation that
turns the initial coordinate system into the current coordinate system.</p>
<p>currentCS and initialCS are (4,3) shaped Coords instances defining
a coordinate system as described in <tt class="xref py py-class docutils literal"><span class="pre">CoordinateSystem</span></tt>.
If initialCS is None, the global (x,y,z) axes are used.</p>
<p>E.g. the default initialCS and currentCS equal to:</p>
<div class="highlight-python"><pre> 0.  1.  0.
-1.  0.  0.
 0.  0.  1.
 0.  0.  0.</pre>
</div>
<p>result in a rotation of 90 degrees around the z-axis.</p>
<p>This is a convenience function equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">isopar</span><span class="p">(</span><span class="s">&#39;tet4&#39;</span><span class="p">,</span><span class="n">currentCS</span><span class="p">,</span><span class="n">initialCS</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">addNoise</tt><big>(</big><em>rsize=0.05</em>, <em>asize=0.0</em><big>)</big></dt>
<dd><p>Add random noise to a Coords.</p>
<p>A random amount is added to eacho individual coordinate in the Coords.
The difference of any coordinate from its original value will
not be r than <tt class="docutils literal"><span class="pre">asize+rsize*self.sizes().max()</span></tt>. The default
is to set it to 0.05 times the geometrical size of the structure.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">replicate</tt><big>(</big><em>n</em>, <em>dir=0</em>, <em>step=None</em><big>)</big></dt>
<dd><p>Replicate a Coords n times with fixed step in any direction.</p>
<p>Returns a Coords object with shape <cite>(n,) + self.shape</cite>, thus having
an extra first axis.
Each component along the axis 0 is equal to the previous component
translated over <cite>(dir,step)</cite>, where <cite>dir</cite> and <cite>step</cite> are
interpreted just like in the <a class="reference internal" href="#coords.Coords.translate" title="coords.Coords.translate"><tt class="xref py py-meth docutils literal"><span class="pre">translate()</span></tt></a> method.
The first component along the axis 0 is identical to the
original Coords.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">split</tt><big>(</big><big>)</big></dt>
<dd><p>Split the coordinate array in blocks along first axis.</p>
<p>The result is a sequence of arrays with shape self.shape[1:].
Raises an error if self.ndim &lt; 2.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">sort</tt><big>(</big><em>order=[0, 1, 2]</em><big>)</big></dt>
<dd><p>Sort points in the specified order of their coordinates.</p>
<p>The points are sorted based on their coordinate values. There is a
maximum number of points (above 2 million) that can be sorted. If you
need to to sort more, first split up your data according to the first
axis.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>order</cite>: permutation of [0,1,2], specifying the order in which
the subsequent axes are used to sort the points.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>An int array which is a permutation of range(self.npoints()).
If taken in the specified order, it is guaranteed that no point can
have a coordinate that is larger that the corresponding coordinate
of the next point.</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">boxes</tt><big>(</big><em>ppb=1</em>, <em>shift=0.5</em>, <em>minsize=1e-05</em><big>)</big></dt>
<dd><p>Create a grid of equally sized boxes spanning the points x.</p>
<p>A regular 3D grid of equally sized boxes is created spanning all
the points <cite>x</cite>. The size, position and number of boxes are determined
from the specified parameters.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>ppb</cite>: int: mean number of points per box. The box sizes and
number of boxes will be determined to approximate this number.</li>
<li><cite>shift</cite>: float (0.0 .. 1.0): a relative shift value for the grid.
Applying a shift of 0.5 will make the lowest coordinate values fall
at the center of the outer boxes.</li>
<li><cite>minsize</cite>: float: minimum absolute size of the boxes (same in each
coordinate direction).</li>
</ul>
<p>Returns a tuple of:</p>
<ul class="simple">
<li><cite>ox</cite>: float array (3): minimal coordinates of the box grid,</li>
<li><cite>dx</cite>: float array (3): box size in the three axis directions,</li>
<li><cite>nx</cite>: in array (3): number of boxes in each of the coordinate
directions.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">fuse</tt><big>(</big><em>ppb=1</em>, <em>shift=0.5</em>, <em>rtol=1e-05</em>, <em>atol=1e-05</em>, <em>repeat=True</em>, <em>nodesperbox=None</em><big>)</big></dt>
<dd><p>Find (almost) identical nodes and return a compressed set.</p>
<p>This method finds the points that are very close and replaces them
with a single point. The return value is a tuple of two arrays:</p>
<ul class="simple">
<li>the unique points as a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object with shape (npoints,3)</li>
<li>an integer (nnod) array holding an index in the unique
coordinates array for each of the original nodes. This index will
have the same shape as the pshape() of the coords array.</li>
</ul>
<p>The procedure works by first dividing the 3D space in a number of
equally sized boxes, with a mean population of ppb.
The boxes are numbered in the 3 directions and a unique integer scalar
is computed, that is then used to sort the nodes.
Then only nodes inside the same box are compared on almost equal
coordinates, using the numpy allclose() function. Two coordinates are
considered close if they are within a relative tolerance rtol or
absolute tolerance atol. See numpy for detail. The default atol is
set larger than in numpy, because pyformex typically runs with single
precision.
Close nodes are replaced by a single one.</p>
<p>Running the procedure once does not guarantee to find all close nodes:
two close nodes might be in adjacent boxes. The performance hit for
testing adjacent boxes is rather high, and the probability of separating
two close nodes with the computed box limits is very small.
Therefore, the most sensible way is to run the procedure twice, with
a different shift value (they should differ more than the tolerance).
Specifying repeat=True will automatically do this.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">match</tt><big>(</big><em>coords</em>, <em>**kargs</em><big>)</big></dt>
<dd><p>Match points form another Coords object.</p>
<p>This method finds the points from <cite>coords</cite> that coincide with
(or are very close to) points of <cite>self</cite>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>coords</cite>: a Coords object</li>
<li><cite>**kargs</cite>: keyword arguments that you want to pass to the
<a class="reference internal" href="#coords.Coords.fuse" title="coords.Coords.fuse"><tt class="xref py py-meth docutils literal"><span class="pre">fuse()</span></tt></a> method.</li>
</ul>
<p>This method works by concatenating the serialized point sets of
both Coords and then fusing them.</p>
<p>Returns:</p>
<ul class="simple">
<li><cite>matches</cite>: an Int array with shape (nmatches,2)</li>
<li><cite>coords</cite>: a Coords with the fused coordinate set</li>
<li><cite>index</cite>: an index with the position of each of the serialized
points of the concatenation in the fused coordinate set. To find
the index of the points of the orginal coordinate sets, split
this index at the position self.npoints() and reshape the resulting
parts to <cite>self.pshape()</cite>, resp. <cite>coords.pshape()</cite>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">append</tt><big>(</big><em>coords</em><big>)</big></dt>
<dd><p>Append coords to a Coords object.</p>
<p>The appended coords should have matching dimensions in all
but the first axis.</p>
<p>Returns the concatenated Coords object, without changing the current.</p>
<p>This is comparable to <tt class="xref py py-func docutils literal"><span class="pre">numpy.append()</span></tt>, but the result
is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object, the default axis is the first one
instead of the last, and it is a method rather than a function.</p>
</dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><tt class="descname">concatenate</tt><big>(</big><em>clas</em>, <em>L</em>, <em>axis=0</em><big>)</big></dt>
<dd><p>Concatenate a list of <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>All <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object in the list L should have the same shape
except for the length of the specified axis.
This function is equivalent to the numpy concatenate, but makes
sure the result is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object,and the default axis
is the first one instead of the last.</p>
<p>The result is at least a 2D array, even when the list contains
a single Coords with a single point.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[</span><span class="mf">2.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">])</span>
<span class="go">[[ 1.  1.  0.]</span>
<span class="go"> [ 2.  2.  0.]</span>
<span class="go"> [ 3.  3.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">])</span>
<span class="go">[[ 1.  1.  0.]</span>
<span class="go"> [ 1.  1.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">Y</span><span class="p">])</span>
<span class="go">[[ 2.  2.  0.]</span>
<span class="go"> [ 3.  3.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">X</span><span class="p">])</span>
<span class="go">[[ 1.  1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><tt class="descname">fromstring</tt><big>(</big><em>clas</em>, <em>fil</em>, <em>sep=' '</em>, <em>ndim=3</em>, <em>count=-1</em><big>)</big></dt>
<dd><p>Create a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object with data from a string.</p>
<p>This convenience function uses the <tt class="xref py py-func docutils literal"><span class="pre">numpy.fromstring()</span></tt>
function to read coordinates from a string.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>fil</cite>: a string containing a single sequence of float numbers separated
by whitespace and a possible separator string.</li>
<li><cite>sep</cite>: the separator used between the coordinates. If not a space,
all extra whitespace is ignored.</li>
<li><cite>ndim</cite>: number of coordinates per point. Should be 1, 2 or 3 (default).
If 1, resp. 2, the coordinate string only holds x, resp. x,y
values.</li>
<li><cite>count</cite>: total number of coordinates to read. This should be a multiple
of 3. The default is to read all the coordinates in the string.
count can be used to force an error condition if the string
does not contain the expected number of values.</li>
</ul>
<p>The return value is  Coords object.</p>
</dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><tt class="descname">fromfile</tt><big>(</big><em>clas</em>, <em>fil</em>, <em>**kargs</em><big>)</big></dt>
<dd><p>Read a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> from file.</p>
<p>This convenience function uses the numpy fromfile function to read
the coordinates from file.
You just have to make sure that the coordinates are read in order
(X,Y,Z) for subsequent points, and that the total number of
coordinates read is a multiple of 3.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">interpolate</tt><big>(</big><em>X</em>, <em>div</em><big>)</big></dt>
<dd><p>Create interpolations between two <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>X</cite>: a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with same shape as <cite>self</cite>.</li>
<li><cite>div</cite>: a list of floating point values, or an int. If an int
is specified, a list with (div+1) values for <cite>div</cite> is created
by dividing the interval [0..1] into <cite>div</cite> equal distances.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with an extra (first) axis, containing the
concatenation of the interpolations of <cite>self</cite> and <cite>X</cite> at all
values in <cite>div</cite>.
Its shape is (n,) + self.shape, where n is the number of values
in <cite>div</cite>.</div></blockquote>
<p>An interpolation of F and G at value v is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> H where
each coordinate Hijk is obtained from:  Fijk = Fijk + v * (Gijk-Fijk).
Thus, X.interpolate(Y,[0.,0.5,1.0]) will contain all points of
X and Y and all points with mean coordinates between those of X and Y.</p>
<p>F.interpolate(G,n) is equivalent with
F.interpolate(G,arange(0,n+1)/float(n))</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">rot</tt><big>(</big><em>angle</em>, <em>axis=2</em>, <em>around=None</em><big>)</big></dt>
<dd><p>Returns a copy rotated over angle around axis.</p>
<p>The angle is specified in degrees.
The axis is either one of (0,1,2) designating the global axes,
or a vector specifying an axis through the origin.
If no axis is specified, rotation is around the 2(z)-axis. This is
convenient for working on 2D-structures.</p>
<p>As a convenience, the user may also specify a 3x3 rotation matrix,
in which case the function rotate(mat) is equivalent to affine(mat).</p>
<p>All rotations are performed around the point [0.,0.,0.], unless a
rotation origin is specified in the argument &#8216;around&#8217;.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">trl</tt><big>(</big><em>dir</em>, <em>step=None</em>, <em>inplace=False</em><big>)</big></dt>
<dd><p>Translate a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Translates the Coords in the direction <cite>dir</cite> over a distance
<cite>step * length(dir)</cite>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the direction and distance of the translation. It
can be either<ul>
<li>an axis number (0,1,2), specifying a unit vector in the direction
of one of the coordinate axes.</li>
<li>a single translation vector,</li>
<li>an array of translation vectors, compatible with the Coords shape.</li>
</ul>
</li>
<li><cite>step</cite>: If specified, the translation vector specified by <cite>dir</cite> will
be multiplied with this value. It is commonly used with unit <cite>dir</cite>
vectors to set the translation distance.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">rep</tt><big>(</big><em>n</em>, <em>dir=0</em>, <em>step=None</em><big>)</big></dt>
<dd><p>Replicate a Coords n times with fixed step in any direction.</p>
<p>Returns a Coords object with shape <cite>(n,) + self.shape</cite>, thus having
an extra first axis.
Each component along the axis 0 is equal to the previous component
translated over <cite>(dir,step)</cite>, where <cite>dir</cite> and <cite>step</cite> are
interpreted just like in the <a class="reference internal" href="#coords.Coords.translate" title="coords.Coords.translate"><tt class="xref py py-meth docutils literal"><span class="pre">translate()</span></tt></a> method.
The first component along the axis 0 is identical to the
original Coords.</p>
</dd></dl>

</dd></dl>

<p><tt class="docutils literal"><span class="pre">Functions</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">coords</span></tt></p>
<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">bbox</tt><big>(</big><em>objects</em><big>)</big></dt>
<dd><p>Compute the bounding box of a list of objects.</p>
<p>The bounding box of an object is the smallest rectangular cuboid
in the global Cartesian coordinates, such that no points of the
objects lie outside that cuboid. The resulting bounding box of the list
of objects is the smallest bounding box that encloses all the objects
in the list. Objects that do not have a <a class="reference internal" href="#coords.bbox" title="coords.bbox"><tt class="xref py py-meth docutils literal"><span class="pre">bbox()</span></tt></a> method or whose
<a class="reference internal" href="#coords.bbox" title="coords.bbox"><tt class="xref py py-meth docutils literal"><span class="pre">bbox()</span></tt></a> method returns invalid values, are ignored.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>objects</cite>: a list of objects (which should probably have the method
<a class="reference internal" href="#coords.bbox" title="coords.bbox"><tt class="xref py py-meth docutils literal"><span class="pre">bbox()</span></tt></a>).</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A Coords object with two points: the first contains the minimal
coordinate values, the second has the maximal ones of the overall
bounding box.</div></blockquote>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">formex</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bbox</span><span class="p">([</span><span class="n">Coords</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]),</span><span class="n">Formex</span><span class="p">(</span><span class="s">&#39;l:5&#39;</span><span class="p">)])</span>
<span class="go">Coords([[-1.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">bboxIntersection</tt><big>(</big><em>A</em>, <em>B</em><big>)</big></dt>
<dd><p>Compute the intersection of the bounding box of two objects.</p>
<p>A and B are objects having a bbox method. The intersection of the two
bounding boxes is returned in boox format.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">testBbox</tt><big>(</big><em>A, bb, dirs=[0, 1, 2], nodes='any'</em><big>)</big></dt>
<dd><p>Test which part of A is inside a given bbox, applied in directions dirs.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>A</cite>: is any object having bbox and a test method (Formex, Mesh).</li>
<li><cite>bb</cite>: is a bounding box, i.e. a (2,3) shape float array.</li>
<li><cite>dirs</cite>: is a list of the three coordinate axes or a subset thereof.</li>
<li><cite>nodes</cite>: has the same meaning as in Formex.test and Mesh.test.</li>
</ul>
<p>The result is a bool array flagging the elements that are inside the given
bounding box.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">origin</tt><big>(</big><big>)</big></dt>
<dd><p>Return a single point with coordinates [0.,0.,0.].</p>
<p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object with shape(3,) holding three zero
coordinates.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">pattern</tt><big>(</big><em>s</em>, <em>aslist=False</em><big>)</big></dt>
<dd><p>Return a series of points lying on a regular grid.</p>
<p>This function creates a series of points that lie on a regular grid
with unit step. These points are created from a string input, interpreting
each character as a code specifying how to move to the next point.
The start position is always the origin (0.,0.,0.).</p>
<p>Currently the following codes are defined:</p>
<ul class="simple">
<li>0: goto origin (0.,0.,0.)</li>
<li>1..8: move in the x,y plane</li>
<li>9 or .: remain at the same place (i.e. duplicate the last point)</li>
<li>A..I: same as 1..9 plus step +1. in z-direction</li>
<li>a..i: same as 1..9 plus step -1. in z-direction</li>
<li>/: do not insert the next point</li>
</ul>
<p>Any other character raises an error.</p>
<p>When looking at the x,y-plane with the x-axis to the right and the
y-axis up, we have the following basic moves:
1 = East, 2 = North, 3 = West, 4 = South, 5 = NE, 6 = NW, 7 = SW, 8 = SE.</p>
<p>Adding 16 to the ordinal of the character causes an extra move of +1. in
the z-direction. Adding 48 causes an extra move of -1. This means that
&#8216;ABCDEFGHI&#8217;, resp. &#8216;abcdefghi&#8217;, correspond with &#8216;123456789&#8217; with an extra
z +/-= 1. This gives the following schema:</p>
<div class="highlight-python"><pre>    z+=1             z unchanged            z -= 1

F    B    E          6    2    5         f    b    e
     |                    |                   |
     |                    |                   |
C----I----A          3----9----1         c----i----a
     |                    |                   |
     |                    |                   |
G    D    H          7    4    8         g    d    h</pre>
</div>
<p>The special character &#8216;/&#8217; can be put before any character to make the
move without inserting the new point. You need to start
the string with a &#8216;0&#8217; or &#8216;9&#8217; to include the origin in the output.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>s</cite>: string: with the characters generating subsequent points.</li>
<li><cite>aslist</cite>: bool: if True, the points are returned as lists of
integer coordinates instead of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</li>
</ul>
<p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with the generated points (default) or a list
of tuples with 3 integer coordinates (if <cite>aslist</cite> is True).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pattern</span><span class="p">(</span><span class="s">&#39;0123&#39;</span><span class="p">)</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 1.  0.  0.]</span>
<span class="go"> [ 1.  1.  0.]</span>
<span class="go"> [ 0.  1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">xpattern</tt><big>(</big><em>s</em>, <em>nplex=1</em><big>)</big></dt>
<dd><p>Create a Coords object from a string pattern.</p>
<p>This is like pattern, but allows grouping the points into elements.
First, the string is expanded to a list of points by calling pattern(s).
Then the resulting list of points is transformed in a 2D table of points
where each row has the length <cite>nplex</cite>.</p>
<p>If the number of points produced by <cite>s</cite> is not a multiple of <cite>nplex</cite>,
an error is raised.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">xpattern</span><span class="p">(</span><span class="s">&#39;.12.34&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[[ 0.  0.  0.]</span>
<span class="go">  [ 1.  0.  0.]</span>
<span class="go">  [ 1.  1.  0.]]</span>

<span class="go"> [[ 1.  1.  0.]</span>
<span class="go">  [ 0.  1.  0.]</span>
<span class="go">  [ 0.  0.  0.]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">align</tt><big>(</big><em>L, align, offset=[0.0, 0.0, 0.0]</em><big>)</big></dt>
<dd><p>Align a list of geometrical objects.</p>
<p>L is a list of geometrical objects (Coords or Geometry or subclasses
thereof) and thus having an appropriate <tt class="docutils literal"><span class="pre">align</span></tt> method.
align is a string of three characters, one for each coordinate direction,
defining how the subsequent objects have to be aligned in that direction:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-</span></tt> : align on the minimal coordinate value</li>
<li><tt class="docutils literal"><span class="pre">+</span></tt> : align on the maximal coordinate value</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt> : align on the middle coordinate value</li>
<li><tt class="docutils literal"><span class="pre">|</span></tt> : align the minimum value on the maximal value of the previous item</li>
</ul>
<p>E.g., the string <tt class="docutils literal"><span class="pre">'|--'</span></tt> will juxtapose the objects in the x-direction,
while aligning them on their minimal coordinates in the y- and z- direction.</p>
<p>An offset may be specified to create a space between the object, instead
of juxtaposing them.</p>
<p>Returns: a list with the aligned objects.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">sweepCoords</tt><big>(</big><em>self, path, origin=[0.0, 0.0, 0.0], normal=0, upvector=2, avgdir=False, enddir=None, scalex=None, scaley=None</em><big>)</big></dt>
<dd><p>Sweep a Coords object along a path, returning a series of copies.</p>
<p>origin and normal define the local path position and direction on the mesh.</p>
<p>At each point of the curve, a copy of the Coords object is created, with
its origin in the curve&#8217;s point, and its normal along the curve&#8217;s direction.
In case of a PolyLine, directions are pointing to the next point by default.
If avgdir==True, average directions are taken at the intermediate points
avgdir can also be an array like sequence of shape (N,3) to explicitely set the
the directions for ALL the points of the path</p>
<p>Missing end directions can explicitely be set by enddir, and are by default
taken along the last segment.
enddir is a list of 2 array like values of shape (3). one of the two can also be an empty list
If the curve is closed, endpoints are treated as any intermediate point,
and the user should normally not specify enddir.</p>
<p>At each point of the curve, the original Coords object can be scaled in x
and y direction by specifying scalex and scaley. The number of values
specified in scalex and scaly should be equal to the number of points on
the curve.</p>
<p>The return value is a sequence of the transformed Coords objects.</p>
</dd></dl>

</div>
<div class="section" id="id107">
<span id="id108"></span><h1>3. <a class="reference internal" href="#module-coords" title="coords: A structured collection of 3D coordinates."><tt class="xref py py-mod docutils literal"><span class="pre">coords</span></tt></a> &#8212; A structured collection of 3D coordinates.<a class="headerlink" href="#id107" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-coords"></span><p>The <a class="reference internal" href="#module-coords" title="coords: A structured collection of 3D coordinates."><tt class="xref py py-mod docutils literal"><span class="pre">coords</span></tt></a> module defines the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> class, which is the basic
data structure in pyFormex to store the coordinates of points in a 3D space.</p>
<p>This module implements a data class for storing large sets of 3D coordinates
and provides an extensive set of methods for transforming these coordinates.
Most of pyFormex&#8217;s classes which represent geometry (e.g. <tt class="xref py py-class docutils literal"><span class="pre">Geometry</span></tt>,
<tt class="xref py py-class docutils literal"><span class="pre">Formex</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">Mesh</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">TriSurface</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">Curve</span></tt>) use a
<a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object to store their coordinates, and thus inherit all the
transformation methods of this class.</p>
<p>While the user will mostly use the higher level classes, he might occasionally
find good reason to use the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> class directly as well.</p>
<p><tt class="docutils literal"><span class="pre">Classes</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">coords</span></tt></p>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">coords.</tt><tt class="descname">Coords</tt></dt>
<dd><p>A structured collection of points in a 3D cartesian space.</p>
<p>The <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> class is the basic data structure used throughout
pyFormex to store coordinates of points in a 3D space.
It is used by other classes, such as <tt class="xref py py-class docutils literal"><span class="pre">Formex</span></tt>
and <tt class="xref py py-class docutils literal"><span class="pre">Surface</span></tt>, which thus inherit the same transformation
capabilities. Applications will mostly use the higher level
classes, which usually have more elaborated consistency checking
and error handling.</p>
<p><a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is implemented as a subclass of <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>,
and thus inherits all its methods.
The last axis of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> always has a length equal to 3.
Each set of 3 values along the last axis represents a single point
in 3D cartesian space. The float datatype is only checked at creation
time. It is the responsibility of the user to keep this consistent
throughout the lifetime of the object.</p>
<p>A new Coords object is created with the following syntax</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Coords</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">dtyp</span><span class="o">=</span><span class="n">Float</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters:</p>
<ul class="simple">
<li><cite>data</cite>: array_like of type float.
The last axis should have a length of 1, 2 or 3, bu will always be
expanded to 3.
If no data are specified, an empty Coords with shape (0,3) is created.</li>
<li><cite>dtyp</cite>: the float datatype to be used.
It not specified, the datatype of <cite>data</cite> is used, or the default
<tt class="xref py py-data docutils literal"><span class="pre">Float</span></tt> (which is equivalent to <tt class="xref py py-data docutils literal"><span class="pre">numpy.float32</span></tt>).</li>
<li><cite>copy</cite>: boolean.
If <tt class="docutils literal"><span class="pre">True</span></tt>, the data are copied. The default setting will try to use
the original data if possible, e.g. if <cite>data</cite> is a correctly shaped and
typed <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">Coords([ 1.,  0.,  0.], dtype=float32)</span>
</pre></div>
</div>
<dl class="method">
<dt>
<tt class="descname">points</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object as a simple set of points.</p>
<p>This reshapes the array to a 2-dimensional array, flattening
the structure of the points.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">pshape</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the shape of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>This is the shape of the <a class="reference external" href="http://numpy.scipy.org">NumPy</a> array with the last axis removed.
The full shape of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> array can be obtained from
its shape attribute.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">npoints</tt><big>(</big><big>)</big></dt>
<dd><p>Return the total number of points.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">ncoords</tt><big>(</big><big>)</big></dt>
<dd><p>Return the total number of points.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">x</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the X-coordinates of all points.</p>
<p>Returns an array with all the X-coordinates in the Coords.
The returned array has the same shape as the Coords array along
its first ndim-1 axes.
This is equivalent with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">y</tt><big>(</big><big>)</big></dt>
<dd><p>Return the Y-coordinates of all points.</p>
<p>Returns an array with all the Y-coordinates in the Coords.
The returned array has the same shape as the Coords array along
its first ndim-1 axes.
This is equivalent with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">z</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the Z-coordinates of all points.</p>
<p>Returns an array with all the Z-coordinates in the Coords.
The returned array has the same shape as the Coords array along
its first ndim-1 axes.
This is equivalent with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bbox</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the bounding box of a set of points.</p>
<p>The bounding box is the smallest rectangular volume in the global
coordinates, such that no point of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> are outside
that volume.</p>
<p>Returns a Coords object with shape(2,3): the first point contains the
minimal coordinates, the second has the maximal ones.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">bbox</span><span class="p">()</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 3.  3.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">apt</tt><big>(</big><em>align</em><big>)</big></dt>
<dd><p>Returns an alignment point of a Coords.</p>
<p>Alignment point are points whose coordinates are either the minimal
value, the maximal value or the middle value for the Coords.
Combining the three values with the three dimensions, a Coords
has in 27 (3**3) alignment points. The corner points of the
bounding box are a subset of these.</p>
<p>The 27 points are addressed by an alignment string of three
characters, one for each direction. Each character should be
one of the following</p>
<ul class="simple">
<li>&#8216;-&#8216;: use the minimal value for that coordinate,</li>
<li>&#8216;+&#8217;: use the minimal value for that coordinate,</li>
<li>&#8216;0&#8217;: use the middle value for that coordinate.</li>
</ul>
<p>Any other character will set the corresponding coordinate to zero.</p>
<p>A string &#8216;000&#8217; is equivalent with center(). The values &#8216;&#8212;&#8217; and
&#8216;+++&#8217; give the points of the bounding box.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">apt</span><span class="p">(</span><span class="s">&#39;-0+&#39;</span><span class="p">)</span>
<span class="go">[ 0.   0.5  1. ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">center</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the center of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The center of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is the center of its bbox().
The return value is a (3,) shaped <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>
<span class="go">[ 1.5  1.5  0. ]</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#coords.Coords.centroid" title="coords.Coords.centroid"><tt class="xref py py-meth docutils literal"><span class="pre">centroid()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">average</tt><big>(</big><em>wts=None</em>, <em>axis=0</em><big>)</big></dt>
<dd><p>Returns a (weighted) average of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The average of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with one
axis less than the original, obtained by averaging all the points
along that axis.
The weights array can either be 1-D (in which case its length must
be the size along the given axis) or of the same shape as a.
Weights can be specified as a 1-D array with the length of that axis,
or as an array with the same shape as the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.
The sum of the weights (along the specified axis if not 1-D) will
generally be equal to 1.0.
If wts=None, then all points are assumed to have a weight equal to
one divided by the length of the specified axis.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]],</span>                   <span class="p">[[</span><span class="mf">4.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">5.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">6.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">average</span><span class="p">()</span>
<span class="go">[[ 2.  0.  0.]</span>
<span class="go"> [ 3.  0.  0.]</span>
<span class="go"> [ 4.  0.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 5.  0.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">wts</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.25</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[[ 0.75  0.    0.  ]</span>
<span class="go"> [ 4.75  0.    0.  ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">centroid</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the centroid of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The centroid of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> is the point whose coordinates
are the mean values of all points.
The return value is a (3,) shaped <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
<span class="go">[ 1.  1.  0.]</span>
</pre></div>
</div>
<p>See also: <a class="reference internal" href="#coords.Coords.center" title="coords.Coords.center"><tt class="xref py py-meth docutils literal"><span class="pre">center()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">sizes</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the sizes of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>Returns an array with the length of the bbox along the 3 axes.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">sizes</span><span class="p">()</span>
<span class="go">[ 3.  3.  0.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">dsize</tt><big>(</big><big>)</big></dt>
<dd><p>Returns an estimate of the global size of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>This estimate is the length of the diagonal of the bbox().</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">dsize</span><span class="p">()</span>
<span class="go">4.24264</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bsphere</tt><big>(</big><big>)</big></dt>
<dd><p>Returns the diameter of the bounding sphere of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>The bounding sphere is the smallest sphere with center in the
center() of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>, and such that no points of the
<a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> are lying outside the sphere.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span><span class="o">.</span><span class="n">bsphere</span><span class="p">()</span>
<span class="go">2.12132024765</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">inertia</tt><big>(</big><em>mass=None</em><big>)</big></dt>
<dd><p>Returns inertia related quantities of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>mass</cite>: float array with ncoords weight values. The default is to
attribute a weight 1.0 to each point.</li>
</ul>
<p>Returns a tuple of:</p>
<ul class="simple">
<li><cite>center</cite>: the center of mass: shape (3,)</li>
<li><cite>axes</cite>: the principal axes of the inertia tensor: shape (3,3)</li>
<li><cite>principal</cite>: the (prinicipal) moments of inertia: shape (3,)</li>
<li><cite>tensor</cite>: the full inertia tensor in the global axes: shape (3,3)</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">distanceFromPlane</tt><big>(</big><em>p</em>, <em>n</em><big>)</big></dt>
<dd><p>Returns the distance of all points from the plane (p,n).</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>p</cite>: is a point specified by 3 coordinates.</li>
<li><cite>n</cite>: is the normal vector to a plane, specified by 3 components.</li>
</ul>
<p>The return value is a float array with shape <tt class="docutils literal"><span class="pre">self.pshape()</span></tt> with
the distance of each point to the plane through p and having normal n.
Distance values are positive if the point is on the side of the
plane indicated by the positive normal.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">distanceFromPlane</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">[[ 0.  3.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">distanceFromLine</tt><big>(</big><em>p</em>, <em>n</em><big>)</big></dt>
<dd><p>Returns the distance of all points from the line (p,n).</p>
<p>p,n are (1,3) or (npts,3) arrays defining 1 or npts lines</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>p</cite>: is a point on the line specified by 3 coordinates.</li>
<li><cite>n</cite>: is a vector specifying the direction of the line through p.</li>
</ul>
<p>The return value is a [...] shaped array with the distance of
each point to the line through p with direction n.
All distance values are positive or zero.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">distanceFromLine</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">[[ 0.  0.  3.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">distanceFromPoint</tt><big>(</big><em>p</em><big>)</big></dt>
<dd><p>Returns the distance of all points from the point p.</p>
<p>p is a single point specified by 3 coordinates.</p>
<p>The return value is a [...] shaped array with the distance of
each point to point p.
All distance values are positive or zero.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">X</span><span class="o">.</span><span class="n">distanceFromPoint</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="go">[[ 0.  3.  3.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">closestToPoint</tt><big>(</big><em>p</em><big>)</big></dt>
<dd><p>Returns the point closest to point p.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">directionalSize</tt><big>(</big><em>n</em>, <em>p=None</em>, <em>_points=False</em><big>)</big></dt>
<dd><p>Returns the extreme distances from the plane p,n.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>n</cite>: the direction can be specified by a 3 component vector or by
a single integer 0..2 designing one of the coordinate axes.</li>
<li><cite>p</cite>: is any point in space. If not specified, it is taken as the
center() of the Coords.</li>
</ul>
<p>The return value is a tuple of two float values specifying the
extreme distances from the plane p,n.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">directionalExtremes</tt><big>(</big><em>n</em>, <em>p=None</em><big>)</big></dt>
<dd><p>Returns extremal planes in the direction n.</p>
<p><cite>n</cite> and <cite>p</cite> have the same meaning as in <cite>directionalSize</cite>.</p>
<p>The return value is a list of two points on the line (p,n),
such that the planes with normal n through these points define
the extremal planes of the Coords.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">directionalWidth</tt><big>(</big><em>n</em><big>)</big></dt>
<dd><p>Returns the width of a Coords in the given direction.</p>
<p>The direction can be specified by a 3 component vector or by
a single integer 0..2 designating one of the coordinate axes.</p>
<p>The return value is the thickness of the object in the direction n.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">test</tt><big>(</big><em>dir=0</em>, <em>min=None</em>, <em>max=None</em>, <em>atol=0.0</em><big>)</big></dt>
<dd><p>Flag points having coordinates between min and max.</p>
<p>Tests the position of the points of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with respect to
one or two planes. This method is very convenient in clipping a
<a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> in a specified direction. In most cases the clipping
direction is one of the global cooordinate axes, but a general
direction may be used as well.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: either a global axis number (0, 1 or 2) or a direction vector
consisting of 3 floats. It specifies the direction in which the
distances are measured. Default is the 0 (or x) direction.</li>
<li><cite>min</cite>, <cite>max</cite>: position of the minimum and maximum clipping planes.
If <cite>dir</cite> was specified as an integer (0,1,2), this is a single float
value corresponding with the coordinate in that axis direction.
Else, it is a point in the clipping plane with normal direction <cite>dir</cite>.
One of the two clipping planes may be left unspecified.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A 1D integer array with same length as the number of points.
For each point the value is 1 (True) if the point is above the
minimum clipping plane and below the maximum clipping plane,
or 0 (False) otherwise.
An unspecified clipping plane corresponds with an infinitely low or
high value. The return value can directly be used as an index to
obtain a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with the points satisfying the test (or not).
See the examples below.</div></blockquote>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[False  True False False]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">test</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="nb">max</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
<span class="go">[[ 0.  1.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">t</span><span class="p">]</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 1.  0.  0.]</span>
<span class="go"> [ 0.  2.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">fprint</tt><big>(</big><em>fmt='%10.3e %10.3e %10.3e'</em><big>)</big></dt>
<dd><p>Formatted printing of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>The supplied format should contain 3 formatting sequences for the
three coordinates of a point.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">set</tt><big>(</big><em>f</em><big>)</big></dt>
<dd><p>Set the coordinates from those in the given array.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">scale</tt><big>(</big><em>scale</em>, <em>dir=None</em>, <em>center=None</em>, <em>inplace=False</em><big>)</big></dt>
<dd><p>Returns a copy scaled with scale[i] in direction i.</p>
<p>The scale should be a list of 3 scaling factors for the 3 axis
directions, or a single scaling factor.
In the latter case, dir (a single axis number or a list) may be given
to specify the direction(s) to scale. The default is to produce a
homothetic scaling.
The center of the scaling, if not specified, is the global origin.
If a center is specified, the result is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span><span class="nb">dir</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[ 2.  2.  2.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span><span class="o">.</span><span class="n">scale</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">[ 2.  3.  4.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">translate</tt><big>(</big><em>dir</em>, <em>step=None</em>, <em>inplace=False</em><big>)</big></dt>
<dd><p>Translate a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Translates the Coords in the direction <cite>dir</cite> over a distance
<cite>step * length(dir)</cite>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the direction and distance of the translation. It
can be either<ul>
<li>an axis number (0,1,2), specifying a unit vector in the direction
of one of the coordinate axes.</li>
<li>a single translation vector,</li>
<li>an array of translation vectors, compatible with the Coords shape.</li>
</ul>
</li>
<li><cite>step</cite>: If specified, the translation vector specified by <cite>dir</cite> will
be multiplied with this value. It is commonly used with unit <cite>dir</cite>
vectors to set the translation distance.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">centered</tt><big>(</big><big>)</big></dt>
<dd><p>Returns a centered copy of the Coords.</p>
<p>Returns a Coords which is a translation thus that the center
coincides with the origin.
This is equivalent with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">trl</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">())</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">align</tt><big>(</big><em>alignment='---', point=[0.0, 0.0, 0.0]</em><big>)</big></dt>
<dd><p>Align a Coords on a given point.</p>
<p>Alignment involves a translation such that the bounding box
of the Coords object becomes aligned with a given point.
By default this is the origin of the global axes.
The requested alignment is determined by a string of three characters,
one for each of the coordinate axes. The character determines how
the structure is aligned in the corresponding direction:</p>
<ul class="simple">
<li>&#8216;-&#8216;: aligned on the minimal value of the bounding box,</li>
<li>&#8216;+&#8217;: aligned on the maximal value of the bounding box,</li>
<li>&#8216;0&#8217;: aligned on the middle value of the bounding box.</li>
</ul>
<p>Any other value will make the alignment in that direction unchanged.</p>
<p>The default alignment string <tt class="docutils literal"><span class="pre">'---'</span></tt> results in a translation which
puts all the points in the octant with all positive coordinate values.
A string <tt class="docutils literal"><span class="pre">'000'</span></tt> will center the object around the origin, just like
the (slightly faster) <a class="reference internal" href="#coords.Coords.centered" title="coords.Coords.centered"><tt class="xref py py-meth docutils literal"><span class="pre">centered()</span></tt></a> method.</p>
<p>See also the <a class="reference internal" href="#coords.align" title="coords.align"><tt class="xref py py-func docutils literal"><span class="pre">coords.align()</span></tt></a> function.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">rotate</tt><big>(</big><em>angle</em>, <em>axis=2</em>, <em>around=None</em><big>)</big></dt>
<dd><p>Returns a copy rotated over angle around axis.</p>
<p>The angle is specified in degrees.
The axis is either one of (0,1,2) designating the global axes,
or a vector specifying an axis through the origin.
If no axis is specified, rotation is around the 2(z)-axis. This is
convenient for working on 2D-structures.</p>
<p>As a convenience, the user may also specify a 3x3 rotation matrix,
in which case the function rotate(mat) is equivalent to affine(mat).</p>
<p>All rotations are performed around the point [0.,0.,0.], unless a
rotation origin is specified in the argument &#8216;around&#8217;.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">shear</tt><big>(</big><em>dir</em>, <em>dir1</em>, <em>skew</em>, <em>inplace=False</em><big>)</big></dt>
<dd><p>Returns a copy skewed in the direction dir of plane (dir,dir1).</p>
<p>The coordinate dir is replaced with (dir + skew * dir1).</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">reflect</tt><big>(</big><em>dir=0</em>, <em>pos=0.0</em>, <em>inplace=False</em><big>)</big></dt>
<dd><p>Reflect the coordinates in direction dir against plane at pos.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: int: direction of the reflection (default 0)</li>
<li><cite>pos</cite>: float: offset of the mirror plane from origin (default 0.0)</li>
<li><cite>inplace</cite>: boolean: change the coordinates inplace (default False)</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">affine</tt><big>(</big><em>mat</em>, <em>vec=None</em><big>)</big></dt>
<dd><p>Perform a general affine transformation.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>mat</cite>: a 3x3 float matrix</li>
<li><cite>vec</cite>: a length 3 list or array of floats</li>
</ul>
<p>The returned object has coordinates given by <tt class="docutils literal"><span class="pre">self</span> <span class="pre">*</span> <span class="pre">mat</span> <span class="pre">+</span> <span class="pre">vec</span></tt>.
If <cite>mat</cite> is a rotation matrix, than the operation performs a
rigid rotation of the object plus a translation.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">position</tt><big>(</big><em>x</em>, <em>y</em><big>)</big></dt>
<dd><p>Position an object so that points x are aligned with y.</p>
<p>Parameters are as for <a class="reference internal" href="arraytools.html#arraytools.trfMatrix" title="arraytools.trfMatrix"><tt class="xref py py-func docutils literal"><span class="pre">arraytools.trfMatrix()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">cylindrical</tt><big>(</big><em>dir=[0, 1, 2], scale=[1.0, 1.0, 1.0], angle_spec=0.017453292519943295</em><big>)</big></dt>
<dd><p>Converts from cylindrical to cartesian after scaling.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates are interpreted as resp.
distance(r), angle(theta) and height(z). Default order is [r,theta,z].</li>
<li><cite>scale</cite>: will scale the coordinate values prior to the transformation.
(scale is given in order r,theta,z).</li>
</ul>
<p>The resulting angle is interpreted in degrees.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">toCylindrical</tt><big>(</big><em>dir=[0, 1, 2], angle_spec=0.017453292519943295</em><big>)</big></dt>
<dd><p>Converts from cartesian to cylindrical coordinates.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates axes are parallel to respectively the
cylindrical axes distance(r), angle(theta) and height(z). Default
order is [x,y,z].</li>
</ul>
<p>The angle value is given in degrees.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">spherical</tt><big>(</big><em>dir=[0, 1, 2], scale=[1.0, 1.0, 1.0], angle_spec=0.017453292519943295, colat=False</em><big>)</big></dt>
<dd><p>Converts from spherical to cartesian after scaling.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates are interpreted as resp.
longitude(theta), latitude(phi) and distance(r).</li>
<li><cite>scale</cite>: will scale the coordinate values prior to the transformation.</li>
</ul>
<p>Angles are interpreted in degrees.
Latitude, i.e. the elevation angle, is measured from equator in
direction of north pole(90). South pole is -90.</p>
<p>If colat=True, the third coordinate is the colatitude (90-lat) instead.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">superSpherical</tt><big>(</big><em>n=1.0, e=1.0, k=0.0, dir=[0, 1, 2], scale=[1.0, 1.0, 1.0], angle_spec=0.017453292519943295, colat=False</em><big>)</big></dt>
<dd><p>Performs a superspherical transformation.</p>
<p>superSpherical is much like spherical, but adds some extra
parameters to enable the creation of virtually any surface.</p>
<p>Just like with spherical(), the input coordinates are interpreted as
the longitude, latitude and distance in a spherical coordinate system.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates are interpreted as resp.longitude(theta),
latitude(phi) and distance(r).
Angles are then interpreted in degrees.
Latitude, i.e. the elevation angle, is measured from equator in
direction of north pole(90). South pole is -90.
If colat=True, the third coordinate is the colatitude (90-lat) instead.</li>
<li><cite>scale</cite>: will scale the coordinate values prior to the transformation.</li>
<li><cite>n</cite>, <cite>e</cite>: parameters define exponential transformations of the
north_south (latitude), resp. the east_west (longitude) coordinates.
Default values of 1 result in a circle.</li>
<li><cite>k</cite>: adds &#8216;eggness&#8217; to the shape: a difference between the northern and
southern hemisphere. Values &gt; 0 enlarge the southern hemishpere and
shrink the northern.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">toSpherical</tt><big>(</big><em>dir=[0, 1, 2], angle_spec=0.017453292519943295</em><big>)</big></dt>
<dd><p>Converts from cartesian to spherical coordinates.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies which coordinates axes are parallel to respectively
the spherical axes distance(r), longitude(theta) and latitude(phi).
Latitude is the elevation angle measured from equator in direction
of north pole(90). South pole is -90.
Default order is [0,1,2], thus the equator plane is the (x,y)-plane.</li>
</ul>
<p>The returned angle values are given in degrees.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bump1</tt><big>(</big><em>dir</em>, <em>a</em>, <em>func</em>, <em>dist</em><big>)</big></dt>
<dd><p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with a one-dimensional bump.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the axis of the modified coordinates;</li>
<li><cite>a</cite>: is the point that forces the bumping;</li>
<li><cite>dist</cite>: specifies the direction in which the distance is measured;</li>
<li><cite>func</cite>: is a function that calculates the bump intensity from distance
and should be such that <tt class="docutils literal"><span class="pre">func(0)</span> <span class="pre">!=</span> <span class="pre">0</span></tt>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bump2</tt><big>(</big><em>dir</em>, <em>a</em>, <em>func</em><big>)</big></dt>
<dd><p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with a two-dimensional bump.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the axis of the modified coordinates;</li>
<li><cite>a</cite>: is the point that forces the bumping;</li>
<li><cite>func</cite>: is a function that calculates the bump intensity from distance
!! func(0) should be different from 0.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">bump</tt><big>(</big><em>dir</em>, <em>a</em>, <em>func</em>, <em>dist=None</em><big>)</big></dt>
<dd><p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with a bump.</p>
<p>A bump is a modification of a set of coordinates by a non-matching
point. It can produce various effects, but one of the most common
uses is to force a surface to be indented by some point.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the axis of the modified coordinates;</li>
<li><cite>a</cite>: is the point that forces the bumping;</li>
<li><cite>func</cite>: is a function that calculates the bump intensity from distance
(!! func(0) should be different from 0)</li>
<li><cite>dist</cite>: is the direction in which the distance is measured : this can
be one of the axes, or a list of one or more axes.
If only 1 axis is specified, the effect is like function bump1
If 2 axes are specified, the effect is like bump2
This function can take 3 axes however.
Default value is the set of 3 axes minus the direction of
modification. This function is then equivalent to bump2.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">flare</tt><big>(</big><em>xf, f, dir=[0, 2], end=0, exp=1.0</em><big>)</big></dt>
<dd><p>Create a flare at the end of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> block.</p>
<p>The flare extends over a distance <tt class="docutils literal"><span class="pre">xf</span></tt> at the start (<tt class="docutils literal"><span class="pre">end=0</span></tt>)
or end (<tt class="docutils literal"><span class="pre">end=1</span></tt>) in direction <tt class="docutils literal"><span class="pre">dir[0]</span></tt> of the coords block,
and has a maximum amplitude of <tt class="docutils literal"><span class="pre">f</span></tt> in the <tt class="docutils literal"><span class="pre">dir[1]</span></tt> direction.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">map</tt><big>(</big><em>func</em><big>)</big></dt>
<dd><p>Map a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> by a 3-D function.</p>
<p>This is one of the versatile mapping functions.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>func</cite>: is a numerical function which takes three arguments and produces
a list of three output values. The coordinates [x,y,z] will be
replaced by func(x,y,z).</li>
</ul>
<p>The function must be applicable to arrays, so it should
only include numerical operations and functions understood by the
numpy module.
This method is one of several mapping methods. See also map1 and mapd.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="mi">4</span><span class="o">*</span><span class="n">z</span><span class="p">])</span>
<span class="go">[[ 2.  3.  4.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">map1</tt><big>(</big><em>dir</em>, <em>func</em>, <em>x=None</em><big>)</big></dt>
<dd><p>Map one coordinate by a 1-D function of one coordinate.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>func</cite>: is a numerical function which takes one argument and produces
one result. The coordinate dir will be replaced by func(coord[x]).
If no x is specified, x is taken equal to dir.</li>
</ul>
<p>The function must be applicable on arrays, so it should only
include numerical operations and functions understood by the
numpy module.
This method is one of several mapping methods. See also map and mapd.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">mapd</tt><big>(</big><em>dir, func, point=[0.0, 0.0, 0.0], dist=None</em><big>)</big></dt>
<dd><p>Map one coordinate by a function of the distance to a point.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: 0, 1 or 2: the coordinate that will be replaced with
<tt class="docutils literal"><span class="pre">func(d)</span></tt>, where <cite>d</cite> is calculated as the distance to <cite>point</cite>.</li>
<li><cite>func</cite>: a numerical function which takes one float argument and
produce one float result. The function must be applicable on arrays,
so it should only include numerical operations and functions
understood by the <tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> module.</li>
<li><cite>point</cite>: the point to where the distance <cite>d</cite> is computed.</li>
<li><cite>dist</cite>: a list of coordinate directions that are used to compute
the distances <cite>d</cite>. It can also be a single coordinate direction.
The default is to use 3-D distances.</li>
</ul>
<p>This method is one of several mapping methods. See also
<tt class="xref py py-meth docutils literal"><span class="pre">map3()</span></tt> and <a class="reference internal" href="#coords.Coords.map1" title="coords.Coords.map1"><tt class="xref py py-meth docutils literal"><span class="pre">map1()</span></tt></a>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span><span class="o">.</span><span class="n">mapd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span><span class="n">E</span><span class="o">.</span><span class="n">center</span><span class="p">(),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>maps <tt class="docutils literal"><span class="pre">E</span></tt> on a sphere with radius 10.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">egg</tt><big>(</big><em>k</em><big>)</big></dt>
<dd><p>Maps the coordinates to an egg-shape</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">replace</tt><big>(</big><em>i</em>, <em>j</em>, <em>other=None</em><big>)</big></dt>
<dd><p>Replace the coordinates along the axes i by those along j.</p>
<p>i and j are lists of axis numbers or single axis numbers.
replace ([0,1,2],[1,2,0]) will roll the axes by 1.
replace ([0,1],[1,0]) will swap axes 0 and 1.
An optionally third argument may specify another <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object to take
the coordinates from. It should have the same dimensions.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">swapAxes</tt><big>(</big><em>i</em>, <em>j</em><big>)</big></dt>
<dd><p>Swap coordinate axes i and j.</p>
<p>Beware! This is different from numpy&#8217;s swapaxes() method !</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">rollAxes</tt><big>(</big><em>n=1</em><big>)</big></dt>
<dd><p>Roll the axes over the given amount.</p>
<p>Default is 1, thus axis 0 becomes the new 1 axis, 1 becomes 2 and
2 becomes 0.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">projectOnPlane</tt><big>(</big><em>n=2, P=[0.0, 0.0, 0.0]</em><big>)</big></dt>
<dd><p>Project a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> on a plane (or planes).</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>n</cite>: the normal direction to the plane. It can be specified either
by a list of three floats, or by a single integer (0, 1 or 2) to
use one of the global axes.</li>
<li><cite>P</cite>: a point on the plane, by default the global origin.
If an int, the plane is the coordinate plane perpendicular to the</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For planes parallel to a coordinate plane, it is far more
efficient to specify the normal by an axis number than by a
three component vector.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method will also work if any or both of P and n have
a shape (ncoords,3), where ncoords is the total number of points
in the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>. This allows to project each point on an
individual plane.</p>
</div>
<p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with same shape as original, with all the
points projected on the specified plane(s).</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">projectOnSphere</tt><big>(</big><em>radius=1.0, center=[0.0, 0.0, 0.0]</em><big>)</big></dt>
<dd><p>Project <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> on a sphere.</p>
<p>The default sphere is a unit sphere at the origin.
The center of the sphere should not be part of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">projectOnCylinder</tt><big>(</big><em>radius=1.0, dir=0, center=[0.0, 0.0, 0.0]</em><big>)</big></dt>
<dd><p>Project <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> on a cylinder with axis parallel to a global axis.</p>
<p>The default cylinder has its axis along the x-axis and a unit radius.
No points of the <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> should belong to the axis..</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">projectOnSurface</tt><big>(</big><em>S</em>, <em>dir=0</em>, <em>missing='error'</em>, <em>return_indices=False</em><big>)</big></dt>
<dd><p>Project the Coords on a triangulated surface.</p>
<p>The points of the Coords are projected in the specified direction dir
onto the surface S.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>S</cite>: TriSurface: any triangulated surface</li>
<li><cite>dir</cite>: int or vector: specifies the direction of the projection</li>
<li><cite>missing</cite>: float value or a string. Specifies a distance to set
the position of the projection point in cases where the projective
line does not cut the surface. The sign of the distance is taken
into account. If specified as a string, it should be one of the
strings &#8216;c&#8217;, &#8216;f&#8217;, or &#8216;m&#8217;, possibly preceded by a &#8216;+&#8217; or &#8216;-&#8216;.
The distance will then be taken equal to the closest,
the furthest, or the mean distance of a point to its projection,
and applied in positive or negative direction as specified.
Any other value of missing will result in an error if some point
does not have any projection. An error will also be raised if not
a single point projection intersects the surface.</li>
<li><cite>return_indices</cite>: if True, also returns an index of the points that
have a projection on the surface.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A Coords with the same shape as the input. If <cite>return_indices</cite>
is True, also returns an index of the points that have a projection
on the surface. This index is a sequential one, no matter what the
shape of the input Coords is.</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">isopar</tt><big>(</big><em>eltype</em>, <em>coords</em>, <em>oldcoords</em><big>)</big></dt>
<dd><p>Perform an isoparametric transformation on a Coords.</p>
<p>This is a convenience method to transform a Coords object through
an isoparametric transformation. It is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Isopar</span><span class="p">(</span><span class="n">eltype</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span><span class="n">oldcoords</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>See <tt class="xref py py-mod docutils literal"><span class="pre">plugins.isopar</span></tt> for more details.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">transformCS</tt><big>(</big><em>currentCS</em>, <em>initialCS=None</em><big>)</big></dt>
<dd><p>Perform a coordinate system transformation on the Coords.</p>
<p>This method transforms the Coords object by the transformation that
turns the initial coordinate system into the current coordinate system.</p>
<p>currentCS and initialCS are (4,3) shaped Coords instances defining
a coordinate system as described in <tt class="xref py py-class docutils literal"><span class="pre">CoordinateSystem</span></tt>.
If initialCS is None, the global (x,y,z) axes are used.</p>
<p>E.g. the default initialCS and currentCS equal to:</p>
<div class="highlight-python"><pre> 0.  1.  0.
-1.  0.  0.
 0.  0.  1.
 0.  0.  0.</pre>
</div>
<p>result in a rotation of 90 degrees around the z-axis.</p>
<p>This is a convenience function equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">isopar</span><span class="p">(</span><span class="s">&#39;tet4&#39;</span><span class="p">,</span><span class="n">currentCS</span><span class="p">,</span><span class="n">initialCS</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">addNoise</tt><big>(</big><em>rsize=0.05</em>, <em>asize=0.0</em><big>)</big></dt>
<dd><p>Add random noise to a Coords.</p>
<p>A random amount is added to eacho individual coordinate in the Coords.
The difference of any coordinate from its original value will
not be r than <tt class="docutils literal"><span class="pre">asize+rsize*self.sizes().max()</span></tt>. The default
is to set it to 0.05 times the geometrical size of the structure.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">replicate</tt><big>(</big><em>n</em>, <em>dir=0</em>, <em>step=None</em><big>)</big></dt>
<dd><p>Replicate a Coords n times with fixed step in any direction.</p>
<p>Returns a Coords object with shape <cite>(n,) + self.shape</cite>, thus having
an extra first axis.
Each component along the axis 0 is equal to the previous component
translated over <cite>(dir,step)</cite>, where <cite>dir</cite> and <cite>step</cite> are
interpreted just like in the <a class="reference internal" href="#coords.Coords.translate" title="coords.Coords.translate"><tt class="xref py py-meth docutils literal"><span class="pre">translate()</span></tt></a> method.
The first component along the axis 0 is identical to the
original Coords.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">split</tt><big>(</big><big>)</big></dt>
<dd><p>Split the coordinate array in blocks along first axis.</p>
<p>The result is a sequence of arrays with shape self.shape[1:].
Raises an error if self.ndim &lt; 2.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">sort</tt><big>(</big><em>order=[0, 1, 2]</em><big>)</big></dt>
<dd><p>Sort points in the specified order of their coordinates.</p>
<p>The points are sorted based on their coordinate values. There is a
maximum number of points (above 2 million) that can be sorted. If you
need to to sort more, first split up your data according to the first
axis.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>order</cite>: permutation of [0,1,2], specifying the order in which
the subsequent axes are used to sort the points.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>An int array which is a permutation of range(self.npoints()).
If taken in the specified order, it is guaranteed that no point can
have a coordinate that is larger that the corresponding coordinate
of the next point.</div></blockquote>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">boxes</tt><big>(</big><em>ppb=1</em>, <em>shift=0.5</em>, <em>minsize=1e-05</em><big>)</big></dt>
<dd><p>Create a grid of equally sized boxes spanning the points x.</p>
<p>A regular 3D grid of equally sized boxes is created spanning all
the points <cite>x</cite>. The size, position and number of boxes are determined
from the specified parameters.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>ppb</cite>: int: mean number of points per box. The box sizes and
number of boxes will be determined to approximate this number.</li>
<li><cite>shift</cite>: float (0.0 .. 1.0): a relative shift value for the grid.
Applying a shift of 0.5 will make the lowest coordinate values fall
at the center of the outer boxes.</li>
<li><cite>minsize</cite>: float: minimum absolute size of the boxes (same in each
coordinate direction).</li>
</ul>
<p>Returns a tuple of:</p>
<ul class="simple">
<li><cite>ox</cite>: float array (3): minimal coordinates of the box grid,</li>
<li><cite>dx</cite>: float array (3): box size in the three axis directions,</li>
<li><cite>nx</cite>: in array (3): number of boxes in each of the coordinate
directions.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">fuse</tt><big>(</big><em>ppb=1</em>, <em>shift=0.5</em>, <em>rtol=1e-05</em>, <em>atol=1e-05</em>, <em>repeat=True</em>, <em>nodesperbox=None</em><big>)</big></dt>
<dd><p>Find (almost) identical nodes and return a compressed set.</p>
<p>This method finds the points that are very close and replaces them
with a single point. The return value is a tuple of two arrays:</p>
<ul class="simple">
<li>the unique points as a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object with shape (npoints,3)</li>
<li>an integer (nnod) array holding an index in the unique
coordinates array for each of the original nodes. This index will
have the same shape as the pshape() of the coords array.</li>
</ul>
<p>The procedure works by first dividing the 3D space in a number of
equally sized boxes, with a mean population of ppb.
The boxes are numbered in the 3 directions and a unique integer scalar
is computed, that is then used to sort the nodes.
Then only nodes inside the same box are compared on almost equal
coordinates, using the numpy allclose() function. Two coordinates are
considered close if they are within a relative tolerance rtol or
absolute tolerance atol. See numpy for detail. The default atol is
set larger than in numpy, because pyformex typically runs with single
precision.
Close nodes are replaced by a single one.</p>
<p>Running the procedure once does not guarantee to find all close nodes:
two close nodes might be in adjacent boxes. The performance hit for
testing adjacent boxes is rather high, and the probability of separating
two close nodes with the computed box limits is very small.
Therefore, the most sensible way is to run the procedure twice, with
a different shift value (they should differ more than the tolerance).
Specifying repeat=True will automatically do this.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">match</tt><big>(</big><em>coords</em>, <em>**kargs</em><big>)</big></dt>
<dd><p>Match points form another Coords object.</p>
<p>This method finds the points from <cite>coords</cite> that coincide with
(or are very close to) points of <cite>self</cite>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>coords</cite>: a Coords object</li>
<li><cite>**kargs</cite>: keyword arguments that you want to pass to the
<a class="reference internal" href="#coords.Coords.fuse" title="coords.Coords.fuse"><tt class="xref py py-meth docutils literal"><span class="pre">fuse()</span></tt></a> method.</li>
</ul>
<p>This method works by concatenating the serialized point sets of
both Coords and then fusing them.</p>
<p>Returns:</p>
<ul class="simple">
<li><cite>matches</cite>: an Int array with shape (nmatches,2)</li>
<li><cite>coords</cite>: a Coords with the fused coordinate set</li>
<li><cite>index</cite>: an index with the position of each of the serialized
points of the concatenation in the fused coordinate set. To find
the index of the points of the orginal coordinate sets, split
this index at the position self.npoints() and reshape the resulting
parts to <cite>self.pshape()</cite>, resp. <cite>coords.pshape()</cite>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">append</tt><big>(</big><em>coords</em><big>)</big></dt>
<dd><p>Append coords to a Coords object.</p>
<p>The appended coords should have matching dimensions in all
but the first axis.</p>
<p>Returns the concatenated Coords object, without changing the current.</p>
<p>This is comparable to <tt class="xref py py-func docutils literal"><span class="pre">numpy.append()</span></tt>, but the result
is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object, the default axis is the first one
instead of the last, and it is a method rather than a function.</p>
</dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><tt class="descname">concatenate</tt><big>(</big><em>clas</em>, <em>L</em>, <em>axis=0</em><big>)</big></dt>
<dd><p>Concatenate a list of <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>All <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object in the list L should have the same shape
except for the length of the specified axis.
This function is equivalent to the numpy concatenate, but makes
sure the result is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object,and the default axis
is the first one instead of the last.</p>
<p>The result is at least a 2D array, even when the list contains
a single Coords with a single point.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([[</span><span class="mf">2.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">])</span>
<span class="go">[[ 1.  1.  0.]</span>
<span class="go"> [ 2.  2.  0.]</span>
<span class="go"> [ 3.  3.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="p">])</span>
<span class="go">[[ 1.  1.  0.]</span>
<span class="go"> [ 1.  1.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">Y</span><span class="p">])</span>
<span class="go">[[ 2.  2.  0.]</span>
<span class="go"> [ 3.  3.  0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">X</span><span class="p">])</span>
<span class="go">[[ 1.  1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><tt class="descname">fromstring</tt><big>(</big><em>clas</em>, <em>fil</em>, <em>sep=' '</em>, <em>ndim=3</em>, <em>count=-1</em><big>)</big></dt>
<dd><p>Create a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object with data from a string.</p>
<p>This convenience function uses the <tt class="xref py py-func docutils literal"><span class="pre">numpy.fromstring()</span></tt>
function to read coordinates from a string.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>fil</cite>: a string containing a single sequence of float numbers separated
by whitespace and a possible separator string.</li>
<li><cite>sep</cite>: the separator used between the coordinates. If not a space,
all extra whitespace is ignored.</li>
<li><cite>ndim</cite>: number of coordinates per point. Should be 1, 2 or 3 (default).
If 1, resp. 2, the coordinate string only holds x, resp. x,y
values.</li>
<li><cite>count</cite>: total number of coordinates to read. This should be a multiple
of 3. The default is to read all the coordinates in the string.
count can be used to force an error condition if the string
does not contain the expected number of values.</li>
</ul>
<p>The return value is  Coords object.</p>
</dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><tt class="descname">fromfile</tt><big>(</big><em>clas</em>, <em>fil</em>, <em>**kargs</em><big>)</big></dt>
<dd><p>Read a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> from file.</p>
<p>This convenience function uses the numpy fromfile function to read
the coordinates from file.
You just have to make sure that the coordinates are read in order
(X,Y,Z) for subsequent points, and that the total number of
coordinates read is a multiple of 3.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">interpolate</tt><big>(</big><em>X</em>, <em>div</em><big>)</big></dt>
<dd><p>Create interpolations between two <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>X</cite>: a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with same shape as <cite>self</cite>.</li>
<li><cite>div</cite>: a list of floating point values, or an int. If an int
is specified, a list with (div+1) values for <cite>div</cite> is created
by dividing the interval [0..1] into <cite>div</cite> equal distances.</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with an extra (first) axis, containing the
concatenation of the interpolations of <cite>self</cite> and <cite>X</cite> at all
values in <cite>div</cite>.
Its shape is (n,) + self.shape, where n is the number of values
in <cite>div</cite>.</div></blockquote>
<p>An interpolation of F and G at value v is a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> H where
each coordinate Hijk is obtained from:  Fijk = Fijk + v * (Gijk-Fijk).
Thus, X.interpolate(Y,[0.,0.5,1.0]) will contain all points of
X and Y and all points with mean coordinates between those of X and Y.</p>
<p>F.interpolate(G,n) is equivalent with
F.interpolate(G,arange(0,n+1)/float(n))</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">rot</tt><big>(</big><em>angle</em>, <em>axis=2</em>, <em>around=None</em><big>)</big></dt>
<dd><p>Returns a copy rotated over angle around axis.</p>
<p>The angle is specified in degrees.
The axis is either one of (0,1,2) designating the global axes,
or a vector specifying an axis through the origin.
If no axis is specified, rotation is around the 2(z)-axis. This is
convenient for working on 2D-structures.</p>
<p>As a convenience, the user may also specify a 3x3 rotation matrix,
in which case the function rotate(mat) is equivalent to affine(mat).</p>
<p>All rotations are performed around the point [0.,0.,0.], unless a
rotation origin is specified in the argument &#8216;around&#8217;.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">trl</tt><big>(</big><em>dir</em>, <em>step=None</em>, <em>inplace=False</em><big>)</big></dt>
<dd><p>Translate a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</p>
<p>Translates the Coords in the direction <cite>dir</cite> over a distance
<cite>step * length(dir)</cite>.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: specifies the direction and distance of the translation. It
can be either<ul>
<li>an axis number (0,1,2), specifying a unit vector in the direction
of one of the coordinate axes.</li>
<li>a single translation vector,</li>
<li>an array of translation vectors, compatible with the Coords shape.</li>
</ul>
</li>
<li><cite>step</cite>: If specified, the translation vector specified by <cite>dir</cite> will
be multiplied with this value. It is commonly used with unit <cite>dir</cite>
vectors to set the translation distance.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">rep</tt><big>(</big><em>n</em>, <em>dir=0</em>, <em>step=None</em><big>)</big></dt>
<dd><p>Replicate a Coords n times with fixed step in any direction.</p>
<p>Returns a Coords object with shape <cite>(n,) + self.shape</cite>, thus having
an extra first axis.
Each component along the axis 0 is equal to the previous component
translated over <cite>(dir,step)</cite>, where <cite>dir</cite> and <cite>step</cite> are
interpreted just like in the <a class="reference internal" href="#coords.Coords.translate" title="coords.Coords.translate"><tt class="xref py py-meth docutils literal"><span class="pre">translate()</span></tt></a> method.
The first component along the axis 0 is identical to the
original Coords.</p>
</dd></dl>

</dd></dl>

<p><tt class="docutils literal"><span class="pre">Functions</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">coords</span></tt></p>
<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">bbox</tt><big>(</big><em>objects</em><big>)</big></dt>
<dd><p>Compute the bounding box of a list of objects.</p>
<p>The bounding box of an object is the smallest rectangular cuboid
in the global Cartesian coordinates, such that no points of the
objects lie outside that cuboid. The resulting bounding box of the list
of objects is the smallest bounding box that encloses all the objects
in the list. Objects that do not have a <a class="reference internal" href="#coords.bbox" title="coords.bbox"><tt class="xref py py-meth docutils literal"><span class="pre">bbox()</span></tt></a> method or whose
<a class="reference internal" href="#coords.bbox" title="coords.bbox"><tt class="xref py py-meth docutils literal"><span class="pre">bbox()</span></tt></a> method returns invalid values, are ignored.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>objects</cite>: a list of objects (which should probably have the method
<a class="reference internal" href="#coords.bbox" title="coords.bbox"><tt class="xref py py-meth docutils literal"><span class="pre">bbox()</span></tt></a>).</li>
</ul>
<p>Returns:</p>
<blockquote>
<div>A Coords object with two points: the first contains the minimal
coordinate values, the second has the maximal ones of the overall
bounding box.</div></blockquote>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">formex</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bbox</span><span class="p">([</span><span class="n">Coords</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]),</span><span class="n">Formex</span><span class="p">(</span><span class="s">&#39;l:5&#39;</span><span class="p">)])</span>
<span class="go">Coords([[-1.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.]], dtype=float32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">bboxIntersection</tt><big>(</big><em>A</em>, <em>B</em><big>)</big></dt>
<dd><p>Compute the intersection of the bounding box of two objects.</p>
<p>A and B are objects having a bbox method. The intersection of the two
bounding boxes is returned in boox format.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">testBbox</tt><big>(</big><em>A, bb, dirs=[0, 1, 2], nodes='any'</em><big>)</big></dt>
<dd><p>Test which part of A is inside a given bbox, applied in directions dirs.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>A</cite>: is any object having bbox and a test method (Formex, Mesh).</li>
<li><cite>bb</cite>: is a bounding box, i.e. a (2,3) shape float array.</li>
<li><cite>dirs</cite>: is a list of the three coordinate axes or a subset thereof.</li>
<li><cite>nodes</cite>: has the same meaning as in Formex.test and Mesh.test.</li>
</ul>
<p>The result is a bool array flagging the elements that are inside the given
bounding box.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">origin</tt><big>(</big><big>)</big></dt>
<dd><p>Return a single point with coordinates [0.,0.,0.].</p>
<p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object with shape(3,) holding three zero
coordinates.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">pattern</tt><big>(</big><em>s</em>, <em>aslist=False</em><big>)</big></dt>
<dd><p>Return a series of points lying on a regular grid.</p>
<p>This function creates a series of points that lie on a regular grid
with unit step. These points are created from a string input, interpreting
each character as a code specifying how to move to the next point.
The start position is always the origin (0.,0.,0.).</p>
<p>Currently the following codes are defined:</p>
<ul class="simple">
<li>0: goto origin (0.,0.,0.)</li>
<li>1..8: move in the x,y plane</li>
<li>9 or .: remain at the same place (i.e. duplicate the last point)</li>
<li>A..I: same as 1..9 plus step +1. in z-direction</li>
<li>a..i: same as 1..9 plus step -1. in z-direction</li>
<li>/: do not insert the next point</li>
</ul>
<p>Any other character raises an error.</p>
<p>When looking at the x,y-plane with the x-axis to the right and the
y-axis up, we have the following basic moves:
1 = East, 2 = North, 3 = West, 4 = South, 5 = NE, 6 = NW, 7 = SW, 8 = SE.</p>
<p>Adding 16 to the ordinal of the character causes an extra move of +1. in
the z-direction. Adding 48 causes an extra move of -1. This means that
&#8216;ABCDEFGHI&#8217;, resp. &#8216;abcdefghi&#8217;, correspond with &#8216;123456789&#8217; with an extra
z +/-= 1. This gives the following schema:</p>
<div class="highlight-python"><pre>    z+=1             z unchanged            z -= 1

F    B    E          6    2    5         f    b    e
     |                    |                   |
     |                    |                   |
C----I----A          3----9----1         c----i----a
     |                    |                   |
     |                    |                   |
G    D    H          7    4    8         g    d    h</pre>
</div>
<p>The special character &#8216;/&#8217; can be put before any character to make the
move without inserting the new point. You need to start
the string with a &#8216;0&#8217; or &#8216;9&#8217; to include the origin in the output.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>s</cite>: string: with the characters generating subsequent points.</li>
<li><cite>aslist</cite>: bool: if True, the points are returned as lists of
integer coordinates instead of a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> object.</li>
</ul>
<p>Returns a <a class="reference internal" href="#coords.Coords" title="coords.Coords"><tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></a> with the generated points (default) or a list
of tuples with 3 integer coordinates (if <cite>aslist</cite> is True).</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pattern</span><span class="p">(</span><span class="s">&#39;0123&#39;</span><span class="p">)</span>
<span class="go">[[ 0.  0.  0.]</span>
<span class="go"> [ 1.  0.  0.]</span>
<span class="go"> [ 1.  1.  0.]</span>
<span class="go"> [ 0.  1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">xpattern</tt><big>(</big><em>s</em>, <em>nplex=1</em><big>)</big></dt>
<dd><p>Create a Coords object from a string pattern.</p>
<p>This is like pattern, but allows grouping the points into elements.
First, the string is expanded to a list of points by calling pattern(s).
Then the resulting list of points is transformed in a 2D table of points
where each row has the length <cite>nplex</cite>.</p>
<p>If the number of points produced by <cite>s</cite> is not a multiple of <cite>nplex</cite>,
an error is raised.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">xpattern</span><span class="p">(</span><span class="s">&#39;.12.34&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[[ 0.  0.  0.]</span>
<span class="go">  [ 1.  0.  0.]</span>
<span class="go">  [ 1.  1.  0.]]</span>

<span class="go"> [[ 1.  1.  0.]</span>
<span class="go">  [ 0.  1.  0.]</span>
<span class="go">  [ 0.  0.  0.]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">align</tt><big>(</big><em>L, align, offset=[0.0, 0.0, 0.0]</em><big>)</big></dt>
<dd><p>Align a list of geometrical objects.</p>
<p>L is a list of geometrical objects (Coords or Geometry or subclasses
thereof) and thus having an appropriate <tt class="docutils literal"><span class="pre">align</span></tt> method.
align is a string of three characters, one for each coordinate direction,
defining how the subsequent objects have to be aligned in that direction:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-</span></tt> : align on the minimal coordinate value</li>
<li><tt class="docutils literal"><span class="pre">+</span></tt> : align on the maximal coordinate value</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt> : align on the middle coordinate value</li>
<li><tt class="docutils literal"><span class="pre">|</span></tt> : align the minimum value on the maximal value of the previous item</li>
</ul>
<p>E.g., the string <tt class="docutils literal"><span class="pre">'|--'</span></tt> will juxtapose the objects in the x-direction,
while aligning them on their minimal coordinates in the y- and z- direction.</p>
<p>An offset may be specified to create a space between the object, instead
of juxtaposing them.</p>
<p>Returns: a list with the aligned objects.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">coords.</tt><tt class="descname">sweepCoords</tt><big>(</big><em>self, path, origin=[0.0, 0.0, 0.0], normal=0, upvector=2, avgdir=False, enddir=None, scalex=None, scaley=None</em><big>)</big></dt>
<dd><p>Sweep a Coords object along a path, returning a series of copies.</p>
<p>origin and normal define the local path position and direction on the mesh.</p>
<p>At each point of the curve, a copy of the Coords object is created, with
its origin in the curve&#8217;s point, and its normal along the curve&#8217;s direction.
In case of a PolyLine, directions are pointing to the next point by default.
If avgdir==True, average directions are taken at the intermediate points
avgdir can also be an array like sequence of shape (N,3) to explicitely set the
the directions for ALL the points of the path</p>
<p>Missing end directions can explicitely be set by enddir, and are by default
taken along the last segment.
enddir is a list of 2 array like values of shape (3). one of the two can also be an empty list
If the curve is closed, endpoints are treated as any intermediate point,
and the user should normally not specify enddir.</p>
<p>At each point of the curve, the original Coords object can be scaled in x
and y direction by specifying scalex and scaley. The number of values
specified in scalex and scaly should be equal to the number of points on
the curve.</p>
<p>The return value is a sequence of the transformed Coords objects.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="formex.html" title="4. formex — Formex algebra in Python"
             >next</a> |</li>
        <li class="right" >
          <a href="../refman.html" title="pyFormex reference manual"
             >previous</a> |</li>
        <li><a href="../index.html">pyFormex 0.9.0-a1 documentation</a> &gt;</li>
          <li><a href="../refman.html" >pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
    <div class="footer">
    <span class="left">
        &copy; Copyright 2004-2012, Benedict Verhegghe.
    </span>
      Last updated on Feb 07, 2013.
    <span class="right">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </span>
    </div>
  </body>
</html>