


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- 
##
##  This file is part of the pyFormex project.
##  pyFormex is a tool for generating, manipulating and transforming 3D
##  geometrical models by sequences of mathematical operations.
##  Home page: http://pyformex.org
##  Project page:  http://savannah.nongnu.org/projects/pyformex/
##  Copyright (C) Benedict Verhegghe (benedict.verhegghe@ugent.be) 
##  Distributed under the GNU General Public License version 3 or later.
##
##
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see http://www.gnu.org/licenses/.
##
-->

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>47. nurbs — Using NURBS in pyFormex. &mdash; pyFormex v0.8.7-a6 documentation</title>

    <link rel="stylesheet" href="../_static/pyformex.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.7-a6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="pyFormex v0.8.7-a6 documentation" href="../index.html" />
    <link rel="up" title="pyFormex reference manual" href="../refman.html" />
    <link rel="next" title="48. objects — Selection of objects from the global dictionary." href="objects.html" />
    <link rel="prev" title="46. mesh_ext — Extended functionality of the Mesh class." href="mesh_ext.html" />
<link rel="icon" type="image/png" href="_static/pyformex_fav.png" />

  </head>
  <body>

<div class="header">
  <a href="http://pyformex.org">
  <img src="http://www.nongnu.org/pyformex/_static/scallop_dome_small.png" alt="scallop dome" border="0" hspace="20" vspace="12" align="left" />
  <img src="http://www.nongnu.org/pyformex/_static/pyformex-logo-2.png" alt="pyformex logo" border="0" hspace="10" vspace="8" align="left" />
  </a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="objects.html" title="48. objects — Selection of objects from the global dictionary."
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mesh_ext.html" title="46. mesh_ext — Extended functionality of the Mesh class."
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pyFormex v0.8.7-a6 documentation</a> &gt;</li>
          <li><a href="../refman.html" accesskey="U">pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div align="center">

<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_s-xclick"/>
<input type="hidden" name="hosted_button_id" value="P7J4AM4QULB4Q"/>
<input type="image" src="https://www.paypal.com/en_US/BE/i/btn/btn_donateCC_LG.gif" name="submit" alt="PayPal - The safer, easier way to pay online!"/>
<img alt="" border="0" src="https://www.paypal.com/nl_NL/i/scr/pixel.gif" width="1" height="1"/>
</form>

</div>
   

  <h4>Previous topic</h4>
  <p class="topless"><a href="mesh_ext.html"
                        title="previous chapter">46. <tt class="docutils literal docutils literal docutils literal"><span class="pre">mesh_ext</span></tt> &#8212; Extended functionality of the Mesh class.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="objects.html"
                        title="next chapter">48. <tt class="docutils literal"><span class="pre">objects</span></tt> &#8212; Selection of objects from the global dictionary.</a></p>
  
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>

<div align="center">
  <p>
  <a href="http://www.fsf.org/register_form?referrer=8491"><img src="http://www.nongnu.org/pyformex/_static/fsf-member8491.png" alt="[FSF Associate Member]" width="89" height="31"  /></a>
  </p>
  <p>
    <a href="http://validator.w3.org/check?uri=referer"><img
      src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Transitional" height="31" width="88" /></a>
  </p>
</div>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-nurbs">
<span id="nurbs-using-nurbs-in-pyformex"></span><span id="sec-ref-nurbs"></span><h1>47. <a class="reference internal" href="#module-nurbs" title="nurbs: Using NURBS in pyFormex."><tt class="xref py py-mod docutils literal"><span class="pre">nurbs</span></tt></a> &#8212; Using NURBS in pyFormex.<a class="headerlink" href="#module-nurbs" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="#module-nurbs" title="nurbs: Using NURBS in pyFormex."><tt class="xref py py-mod docutils literal"><span class="pre">nurbs</span></tt></a> module defines functions and classes to manipulate
NURBS curves and surface in pyFormex.</p>
<p><tt class="docutils literal"><span class="pre">Classes</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">nurbs</span></tt></p>
<dl class="class">
<dt id="nurbs.Coords4">
<em class="property">class </em><tt class="descclassname">nurbs.</tt><tt class="descname">Coords4</tt><a class="headerlink" href="#nurbs.Coords4" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of points represented by their homogeneous coordinates.</p>
<p>While most of the pyFormex implementation is based on the 3D Cartesian
coordinates class <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt>, some applications may benefit from using
homogeneous coordinates. The class <a class="reference internal" href="#nurbs.Coords4" title="nurbs.Coords4"><tt class="xref py py-class docutils literal"><span class="pre">Coords4</span></tt></a> provides some basic
functions and conversion to and from cartesian coordinates.
Through the conversion, all other pyFormex functions, such as
transformations, are available.</p>
<p><a class="reference internal" href="#nurbs.Coords4" title="nurbs.Coords4"><tt class="xref py py-class docutils literal"><span class="pre">Coords4</span></tt></a> is implemented as a float type <tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>
whose last axis has a length equal to 4.
Each set of 4 values (x,y,z,w) along the last axis represents a
single point in 3D space. The cartesian coordinates of the point
are obtained by dividing the first three values by the fourth:
(x/w, y/w, z/w). A zero w-value represents a point at infinity.
Converting such points to <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> will result in Inf or NaN
values in the resulting object.</p>
<p>The float datatype is only checked at creation time. It is the
responsibility of the user to keep this consistent throughout the
lifetime of the object.</p>
<p>Just like <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt>, the class <a class="reference internal" href="#nurbs.Coords4" title="nurbs.Coords4"><tt class="xref py py-class docutils literal"><span class="pre">Coords4</span></tt></a> is derived from
<tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt>.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt><cite>data</cite>: array_like</dt>
<dd>If specified, data should evaluate to an array of floats, with the
length of its last axis not larger than 4. When equal to four, each
tuple along the last axis represents a ingle point in homogeneous
coordinates.
If smaller than four, the last axis will be expanded to four by adding
values zero in the second and third position and values 1 in the last
position.
If no data are given, a single point (0.,0.,0.) will be created.</dd>
<dt><cite>w</cite>: array_like</dt>
<dd>If specified, the w values are used to denormalize the homogeneous
data such that the last component becomes w.</dd>
<dt><cite>dtyp</cite>: data-type</dt>
<dd>The datatype to be used. It not specified, the datatype of <cite>data</cite>
is used, or the default <tt class="xref py py-data docutils literal"><span class="pre">Float</span></tt> (which is equivalent to
<tt class="xref py py-data docutils literal"><span class="pre">numpy.float32</span></tt>).</dd>
<dt><cite>copy</cite>: boolean</dt>
<dd>If <tt class="xref docutils literal"><span class="pre">True</span></tt>, the data are copied. By default, the original data are
used if possible, e.g. if a correctly shaped and typed
<tt class="xref py py-class docutils literal"><span class="pre">numpy.ndarray</span></tt> is specified.</dd>
</dl>
<dl class="method">
<dt id="nurbs.Coords4.normalize">
<tt class="descname">normalize</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.Coords4.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize the homogeneous coordinates.</p>
<p>Two sets of homogeneous coordinates that differ only by a
multiplicative constant refer to the same points in cartesian space.
Normalization of the coordinates is a way to make the representation
of a single point unique. Normalization is done so that the last
component (w) is equal to 1.</p>
<p>The normalization of the coordinates is done in place.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Normalizing points at infinity will result in Inf or
NaN values.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="nurbs.Coords4.deNormalize">
<tt class="descname">deNormalize</tt><big>(</big><em>w</em><big>)</big><a class="headerlink" href="#nurbs.Coords4.deNormalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Denormalizes the homogeneous coordinates.</p>
<p>This multiplies the homogeneous coordinates with the values w.
w normally is a constant or an array with shape
self.shape[:-1] + (1,).
It then multiplies all 4 coordinates of a point with the same
value, thus resulting in a denormalization while keeping the
position of the point unchanged.</p>
<p>The denormalization of the coordinates is done in place.
If the Coords4 object was normalized, it will have precisely w as
its 4-th coordinate value after the call.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.Coords4.toCoords">
<tt class="descname">toCoords</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.Coords4.toCoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert homogeneous coordinates to cartesian coordinates.</p>
<p>Returns:</p>
<p>A <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> object with the cartesian coordinates
of the points. Points at infinity (w=0) will result in
Inf or NaN value. If there are no points at infinity, the
resulting <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> point set is equivalent to the
<a class="reference internal" href="#nurbs.Coords4" title="nurbs.Coords4"><tt class="xref py py-class docutils literal"><span class="pre">Coords4</span></tt></a> one.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.Coords4.npoints">
<tt class="descname">npoints</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.Coords4.npoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of points.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.Coords4.ncoords">
<tt class="descname">ncoords</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.Coords4.ncoords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total number of points.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.Coords4.x">
<tt class="descname">x</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.Coords4.x" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the x-plane</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.Coords4.y">
<tt class="descname">y</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.Coords4.y" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the y-plane</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.Coords4.z">
<tt class="descname">z</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.Coords4.z" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the z-plane</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.Coords4.w">
<tt class="descname">w</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.Coords4.w" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the w-plane</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.Coords4.bbox">
<tt class="descname">bbox</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.Coords4.bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bounding box of a set of points.</p>
<p>Returns the bounding box of the cartesian coordinates of
the object.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.Coords4.actor">
<tt class="descname">actor</tt><big>(</big><em>**kargs</em><big>)</big><a class="headerlink" href="#nurbs.Coords4.actor" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphical representation</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nurbs.NurbsCurve">
<em class="property">class </em><tt class="descclassname">nurbs.</tt><tt class="descname">NurbsCurve</tt><big>(</big><em>control</em>, <em>degree=None</em>, <em>wts=None</em>, <em>knots=None</em>, <em>closed=False</em>, <em>blended=True</em><big>)</big><a class="headerlink" href="#nurbs.NurbsCurve" title="Permalink to this definition">¶</a></dt>
<dd><p>A NURBS curve</p>
<p>The Nurbs curve is defined by nctrl control points, a degree (&gt;= 1) and
a knot vector with knots = nctrl+degree+1 parameter values.</p>
<p>The knots vector should hold nknots values in ascending order. The values
are only defined upon a multiplicative constant and will be normalized
to set the last value to 1.
Sensible default values are constructed automatically by calling
<a class="reference internal" href="#nurbs.knotVector" title="nurbs.knotVector"><tt class="xref py py-func docutils literal"><span class="pre">knotVector()</span></tt></a>.</p>
<p>If no knots are given and no degree is specified, the degree is set to
the number of control points - 1 if the curve is blended. If not blended,
the degree is not set larger than 3.</p>
<dl class="method">
<dt id="nurbs.NurbsCurve.bbox">
<tt class="descname">bbox</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.NurbsCurve.bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bounding box of the NURBS curve.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsCurve.pointsAt">
<tt class="descname">pointsAt</tt><big>(</big><em>u</em><big>)</big><a class="headerlink" href="#nurbs.NurbsCurve.pointsAt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the points on the Nurbs curve at given parametric values.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>u</cite>: (nu,) shaped float array, parametric values at which a point
is to be placed.</li>
</ul>
<p>Returns (nu,3) shaped Coords with nu points at the specified
parametric values.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsCurve.derivs">
<tt class="descname">derivs</tt><big>(</big><em>at</em>, <em>d=1</em><big>)</big><a class="headerlink" href="#nurbs.NurbsCurve.derivs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the points and derivatives up to d at parameter values at</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsCurve.knotPoints">
<tt class="descname">knotPoints</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.NurbsCurve.knotPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the points at the knot values.</p>
<p>The multiplicity of the knots is retained in the points set.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsCurve.insertKnots">
<tt class="descname">insertKnots</tt><big>(</big><em>u</em><big>)</big><a class="headerlink" href="#nurbs.NurbsCurve.insertKnots" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert a set of knots in the curve.</p>
<p>u is a vector with knot parameter values to be inserted into the
curve. The control points are adapted to keep the curve unchanged.</p>
<p>Returns:</p>
<p>A Nurbs curve equivalent with the original but with the
specified knot values inserted in the knot vector, and the control
points adapted.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsCurve.decompose">
<tt class="descname">decompose</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.NurbsCurve.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Decomposes a curve in subsequent Bezier curves.</p>
<p>Returns an equivalent unblended Nurbs.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsCurve.removeKnots">
<tt class="descname">removeKnots</tt><big>(</big><em>u</em>, <em>tol</em><big>)</big><a class="headerlink" href="#nurbs.NurbsCurve.removeKnots" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a knots in the curve.</p>
<p>u is a vector with knot parameter values to be inserted into the
curve. The control points are adapted to keep the curve unchanged.</p>
<p>Returns:</p>
<p>A Nurbs curve equivalent with the original but with the
specified knot values inserted in the knot vector, and the control
points adapted.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsCurve.approx">
<tt class="descname">approx</tt><big>(</big><em>ndiv=None</em>, <em>ntot=None</em><big>)</big><a class="headerlink" href="#nurbs.NurbsCurve.approx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a PolyLine approximation of the Nurbs curve</p>
<p>If no <cite>ntot</cite> is given, the curve is approximated by a PolyLine
through equidistant <cite>ndiv+1</cite> point in parameter space. These points
may be far from equidistant in Cartesian space.</p>
<p>If <cite>ntot</cite> is given, a second approximation is computed with <cite>ntot</cite>
straight segments of nearly equal length. The lengths are computed
based on the first approximation with <cite>ndiv</cite> segments.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsCurve.actor">
<tt class="descname">actor</tt><big>(</big><em>**kargs</em><big>)</big><a class="headerlink" href="#nurbs.NurbsCurve.actor" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphical representation</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nurbs.NurbsSurface">
<em class="property">class </em><tt class="descclassname">nurbs.</tt><tt class="descname">NurbsSurface</tt><big>(</big><em>control</em>, <em>degree=(None</em>, <em>None)</em>, <em>wts=None</em>, <em>knots=(None</em>, <em>None)</em>, <em>closed=(False</em>, <em>False)</em>, <em>blended=(True</em>, <em>True)</em><big>)</big><a class="headerlink" href="#nurbs.NurbsSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>A NURBS surface</p>
<p>The Nurbs surface is defined as a tensor product of NURBS curves in two
parametrical directions u and v. The control points form a grid of
(nctrlu,nctrlv) points. The other data are like those for a NURBS curve,
but need to be specified as a tuple for the (u,v) directions.</p>
<p>The knot values are only defined upon a multiplicative constant, equal to
the largest value. Sensible default values are constructed automatically
by a call to the knotVector() function.</p>
<p>If no knots are given and no degree is specified, the degree is set to
the number of control points - 1 if the curve is blended. If not blended,
the degree is not set larger than 3.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is a class under development!</p>
</div>
<dl class="method">
<dt id="nurbs.NurbsSurface.bbox">
<tt class="descname">bbox</tt><big>(</big><big>)</big><a class="headerlink" href="#nurbs.NurbsSurface.bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the bounding box of the NURBS surface.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsSurface.pointsAt">
<tt class="descname">pointsAt</tt><big>(</big><em>u</em><big>)</big><a class="headerlink" href="#nurbs.NurbsSurface.pointsAt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the points on the Nurbs surface at given parametric values.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>u</cite>: (nu,2) shaped float array: <cite>nu</cite> parametric values (u,v) at which
a point is to be placed.</li>
</ul>
<p>Returns (nu,3) shaped Coords with <cite>nu</cite> points at the specified
parametric values.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsSurface.derivs">
<tt class="descname">derivs</tt><big>(</big><em>u</em>, <em>m</em><big>)</big><a class="headerlink" href="#nurbs.NurbsSurface.derivs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return points and derivatives at given parametric values.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>u</cite>: (nu,2) shaped float array: <cite>nu</cite> parametric values (u,v) at which
the points and derivatives are evaluated.</li>
<li><cite>m</cite>: tuple of two int values (mu,mv). The points and derivatives up
to order mu in u direction and mv in v direction are returned.</li>
</ul>
<p>Returns:</p>
<p>(nu+1,nv+1,nu,3) shaped Coords with <cite>nu</cite> points at the
specified parametric values. The slice (0,0,:,:) contains the
points.</p>
</dd></dl>

<dl class="method">
<dt id="nurbs.NurbsSurface.actor">
<tt class="descname">actor</tt><big>(</big><em>**kargs</em><big>)</big><a class="headerlink" href="#nurbs.NurbsSurface.actor" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphical representation</p>
</dd></dl>

</dd></dl>

<p><tt class="docutils literal"><span class="pre">Functions</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">nurbs</span></tt></p>
<dl class="function">
<dt id="nurbs.globalInterpolationCurve">
<tt class="descclassname">nurbs.</tt><tt class="descname">globalInterpolationCurve</tt><big>(</big><em>Q</em>, <em>degree=3</em>, <em>strategy=0.5</em><big>)</big><a class="headerlink" href="#nurbs.globalInterpolationCurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a global interpolation NurbsCurve.</p>
<p>Given an ordered set of points Q, the globalInterpolationCurve
is a NURBS curve of the given degree, passing through all the
points.</p>
<p>Returns:</p>
<p>A NurbsCurve through the given point set. The number of
control points is the same as the number of input points.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently there is the limitation that two consecutive
points should not coincide. If they do, a warning is shown and
the double points will be removed.</p>
</div>
<p>The procedure works by computing the control points that will
produce a NurbsCurve with the given points occurring at predefined
parameter values. The strategy to set this values uses a parameter
as exponent. Different values produce (slighly) different curves.
Typical values are:</p>
<p>0.0: equally spaced (not recommended)
0.5: centripetal (default, recommended)
1.0: chord length (often used)</p>
</dd></dl>

<dl class="function">
<dt id="nurbs.uniformParamValues">
<tt class="descclassname">nurbs.</tt><tt class="descname">uniformParamValues</tt><big>(</big><em>n</em>, <em>umin=0.0</em>, <em>umax=1.0</em><big>)</big><a class="headerlink" href="#nurbs.uniformParamValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a set of uniformly distributed parameter values in a range.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>n</cite>: int: number of intervals in which the range should be divided.
The number of values returned is <tt class="docutils literal"><span class="pre">n+1</span></tt>.</li>
<li><cite>umin</cite>, <cite>umax</cite>: float: start and end value of the interval. Default
interval is [0.0..1.0].</li>
</ul>
<p>Returns:</p>
<p>A float array with n+1 equidistant values in the range umin..umax.
For n &gt; 0, both of the endpoints are included. For n=0, a single
value at the center of the interval will be returned. For n&lt;0, an
empty array is returned.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">uniformParamValues</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[0.0, 0.25, 0.5, 0.75, 1.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uniformParamValues</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[0.5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uniformParamValues</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uniformParamValues</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[1.5, 2.0, 2.5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nurbs.knotVector">
<tt class="descclassname">nurbs.</tt><tt class="descname">knotVector</tt><big>(</big><em>nctrl</em>, <em>degree</em>, <em>blended=True</em>, <em>closed=False</em><big>)</big><a class="headerlink" href="#nurbs.knotVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sensible knot vector for a Nurbs curve.</p>
<p>A knot vector is a sequence of non-decreasing parametric values. These
values define the <cite>knots</cite>, i.e. the points where the analytical expression
of the Nurbs curve may change. The knot values are only meaningful upon a
multiplicative constant, and they are usually normalized to the range
[0.0..1.0].</p>
<p>A Nurbs curve with <tt class="docutils literal"><span class="pre">nctrl</span></tt> points and of given <tt class="docutils literal"><span class="pre">degree</span></tt> needs a knot
vector with <tt class="docutils literal"><span class="pre">nknots</span> <span class="pre">=</span> <span class="pre">nctrl+degree+1</span></tt> values. A <tt class="docutils literal"><span class="pre">degree</span></tt> curve needs
at least <tt class="docutils literal"><span class="pre">nctrl</span> <span class="pre">=</span> <span class="pre">degree+1</span></tt> control points, and thus at least
<tt class="docutils literal"><span class="pre">nknots</span> <span class="pre">=</span> <span class="pre">2*(degree+1)</span></tt> knot values.</p>
<p>To make an open curve start and end in its end points, it needs knots with
multiplicity <tt class="docutils literal"><span class="pre">degree+1</span></tt> at its ends. Thus, for an open blended curve, the
default policy is to set the knot values at the ends to 0.0, resp. 1.0,
both with multiplicity <tt class="docutils literal"><span class="pre">degree+1</span></tt>, and to spread the remaining
<tt class="docutils literal"><span class="pre">nctrl</span> <span class="pre">-</span> <span class="pre">degree</span> <span class="pre">-</span> <span class="pre">1</span></tt> values equally over the interval.</p>
<p>For a closed (blended) curve, the knots are equally spread over the
interval, all having a multiplicity 1 for maximum continuity of the curve.</p>
<p>For an open unblended curve, all internal knots get multiplicity <tt class="docutils literal"><span class="pre">degree</span></tt>.
This results in a curve that is only one time continuously derivable at
the knots, thus the curve is smooth, but the curvature may be discontinuous.
There is an extra requirement in this case: <tt class="docutils literal"><span class="pre">nctrl</span></tt> sohuld be a multiple
of <tt class="docutils literal"><span class="pre">degree</span></tt> plus 1.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">knotVector</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[ 0.    0.    0.    0.    0.25  0.5   0.75  1.    1.    1.    1.  ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">knotVector</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">closed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">[ 0.   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1. ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">knotVector</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">blended</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">[ 0.  0.  0.  0.  1.  1.  1.  2.  2.  2.  2.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nurbs.toCoords4">
<tt class="descclassname">nurbs.</tt><tt class="descname">toCoords4</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#nurbs.toCoords4" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert cartesian coordinates to homogeneous</p>
<dl class="docutils">
<dt><cite>x</cite>: <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt></dt>
<dd>Array with cartesian coordinates.</dd>
</dl>
<p>Returns a Coords4 object corresponding to the input cartesian coordinates.</p>
</dd></dl>

<dl class="function">
<dt id="nurbs.pointsOnBezierCurve">
<tt class="descclassname">nurbs.</tt><tt class="descname">pointsOnBezierCurve</tt><big>(</big><em>P</em>, <em>u</em><big>)</big><a class="headerlink" href="#nurbs.pointsOnBezierCurve" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute points on a Bezier curve</p>
<p>Parameters:</p>
<p>P is an array with n+1 points defining a Bezier curve of degree n.
u is a vector with nu parameter values between 0 and 1.</p>
<p>Returns:</p>
<p>An array with the nu points of the Bezier curve corresponding with the
specified parametric values.
ERROR: currently u is a single paramtric value!</p>
<p>See also:
examples BezierCurve, Casteljou</p>
</dd></dl>

<dl class="function">
<dt id="nurbs.deCasteljou">
<tt class="descclassname">nurbs.</tt><tt class="descname">deCasteljou</tt><big>(</big><em>P</em>, <em>u</em><big>)</big><a class="headerlink" href="#nurbs.deCasteljou" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute points on a Bezier curve using deCasteljou algorithm</p>
<p>Parameters:</p>
<p>P is an array with n+1 points defining a Bezier curve of degree n.
u is a single parameter value between 0 and 1.</p>
<p>Returns:</p>
<p>A list with point sets obtained in the subsequent deCasteljou
approximations. The first one is the set of control points, the last one
is the point on the Bezier curve.</p>
<p>This function works with Coords as well as Coords4 points.</p>
</dd></dl>

<dl class="function">
<dt id="nurbs.curveToNurbs">
<tt class="descclassname">nurbs.</tt><tt class="descname">curveToNurbs</tt><big>(</big><em>B</em><big>)</big><a class="headerlink" href="#nurbs.curveToNurbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a BezierSpline to NurbsCurve</p>
</dd></dl>

<dl class="function">
<dt id="nurbs.frenet">
<tt class="descclassname">nurbs.</tt><tt class="descname">frenet</tt><big>(</big><em>d1</em>, <em>d2</em>, <em>d3=None</em><big>)</big><a class="headerlink" href="#nurbs.frenet" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 3 Frenet vectors and the curvature.</p>
<p>d1,d2 are the first and second derivatives at points of a curve.
d3, if given, is the third derivative. 
Returns 3 normalized vectors along tangent, normal, binormal
plus the curvature.
if d3 is give, also returns the torsion of the curve.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="objects.html" title="48. objects — Selection of objects from the global dictionary."
             >next</a> |</li>
        <li class="right" >
          <a href="mesh_ext.html" title="46. mesh_ext — Extended functionality of the Mesh class."
             >previous</a> |</li>
        <li><a href="../index.html">pyFormex v0.8.7-a6 documentation</a> &gt;</li>
          <li><a href="../refman.html" >pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
    <div class="footer">
    <span class="left">
        &copy; Copyright 2004-2011, Benedict Verhegghe.
    </span>
      Last updated on Oct 16, 2012.
    <span class="right">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.8.
    </span>
    </div>
  </body>
</html>
