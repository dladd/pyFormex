

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>40. fe — Finite Element Models in pyFormex. &mdash; pyFormex v0.8.4-a1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.4-a1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="pyFormex v0.8.4-a1 documentation" href="../index.html" />
    <link rel="up" title="pyFormex reference manual" href="../refman.html" />
    <link rel="next" title="41. fe_abq — Exporting finite element models in Abaqus™ input file format." href="fe_abq.html" />
    <link rel="prev" title="39. properties — General framework for attributing properties to geometrical elements." href="properties.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="fe_abq.html" title="41. fe_abq — Exporting finite element models in Abaqus™ input file format."
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="properties.html" title="39. properties — General framework for attributing properties to geometrical elements."
             accesskey="P">previous</a> |</li>
    <li><a href="http://pyformex.org/">pyFormex Home</a> &gt;</li>
    
        <li><a href="../index.html">pyFormex Documentation</a> &gt;</li>

          <li><a href="../refman.html" accesskey="U">pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <p>DEBUG: Using the (slower) Python misc functions
.. $Id$  -<em>- rst -</em>-
.. pyformex reference manual &#8212; fe
.. CREATED WITH py2rst.py: DO NOT EDIT</p>
<div class="section" id="module-fe">
<span id="fe-finite-element-models-in-pyformex"></span><span id="sec-ref-fe"></span><h1>40. <a class="reference internal" href="#module-fe" title="fe: Finite Element Models in pyFormex."><tt class="xref py py-mod docutils literal"><span class="pre">fe</span></tt></a> &#8212; Finite Element Models in pyFormex.<a class="headerlink" href="#module-fe" title="Permalink to this headline">¶</a></h1>
<p>Finite element models are geometrical models that consist of a unique
set of nodal coordinates and one of more sets of elements.</p>
<p><tt class="docutils literal"><span class="pre">Classes</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">fe</span></tt></p>
<dl class="class">
<dt id="fe.Model">
<em class="property">class </em><tt class="descclassname">fe.</tt><tt class="descname">Model</tt><big>(</big><em>coords</em>, <em>elems</em><big>)</big><a class="headerlink" href="#fe.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains all FE model data.</p>
<dl class="method">
<dt id="fe.Model.nnodes">
<tt class="descname">nnodes</tt><big>(</big><big>)</big><a class="headerlink" href="#fe.Model.nnodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of nodes in the model.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.nelems">
<tt class="descname">nelems</tt><big>(</big><big>)</big><a class="headerlink" href="#fe.Model.nelems" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements in the model.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.ngroups">
<tt class="descname">ngroups</tt><big>(</big><big>)</big><a class="headerlink" href="#fe.Model.ngroups" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of element groups in the model.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.mplex">
<tt class="descname">mplex</tt><big>(</big><big>)</big><a class="headerlink" href="#fe.Model.mplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum plexitude of the model.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.splitElems">
<tt class="descname">splitElems</tt><big>(</big><em>set</em><big>)</big><a class="headerlink" href="#fe.Model.splitElems" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits a set of element numbers over the element groups.</p>
<p>Returns two lists of element sets, the first in global numbering,
the second in group numbering.
Each item contains the element numbers from the given set that
belong to the corresponding group.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.elemNrs">
<tt class="descname">elemNrs</tt><big>(</big><em>group</em>, <em>set</em><big>)</big><a class="headerlink" href="#fe.Model.elemNrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the global element numbers for elements set in group</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.affine">
<tt class="descname">affine</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a general affine transform of the <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> object.</p>
<p><cite>mat</cite>: a 3x3 float matrix</p>
<p><cite>vec</cite>: a length 3 list or array of floats</p>
<p>The returned object has coordinates given by <tt class="docutils literal"><span class="pre">self</span> <span class="pre">*</span> <span class="pre">mat</span> <span class="pre">+</span> <span class="pre">vec</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.bump">
<tt class="descname">bump</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.bump" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> with a bump.</p>
<p>A bump is a modification of a set of coordinates by a non-matching
point. It can produce various effects, but one of the most common
uses is to force a surface to be indented by some point.</p>
<p>dir specifies the axis of the modified coordinates;
a is the point that forces the bumping;
func is a function that calculates the bump intensity from distance
(!! func(0) should be different from 0)
dist is the direction in which the distance is measured : this can
be one of the axes, or a list of one or more axes.
If only 1 axis is specified, the effect is like function bump1
If 2 axes are specified, the effect is like bump2
This function can take 3 axes however.
Default value is the set of 3 axes minus the direction of modification.
This function is then equivalent to bump2.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.bump1">
<tt class="descname">bump1</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.bump1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> with a one-dimensional bump.</p>
<ul class="simple">
<li><cite>dir</cite> specifies the axis of the modified coordinates;</li>
<li><cite>a</cite> is the point that forces the bumping;</li>
<li><cite>dist</cite> specifies the direction in which the distance is measured;</li>
<li><cite>func</cite> is a function that calculates the bump intensity from distance
and should be such that <tt class="docutils literal"><span class="pre">func(0)</span> <span class="pre">!=</span> <span class="pre">0</span></tt>.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fe.Model.bump2">
<tt class="descname">bump2</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.bump2" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> with a two-dimensional bump.</p>
<p>dir specifies the axis of the modified coordinates;
a is the point that forces the bumping;
func is a function that calculates the bump intensity from distance
!! func(0) should be different from 0.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.cylindrical">
<tt class="descname">cylindrical</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.cylindrical" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from cylindrical to cartesian after scaling.</p>
<p>dir specifies which coordinates are interpreted as resp.
distance(r), angle(theta) and height(z). Default order is [r,theta,z].
scale will scale the coordinate values prior to the transformation.
(scale is given in order r,theta,z).
The resulting angle is interpreted in degrees.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.egg">
<tt class="descname">egg</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.egg" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the coordinates to an egg-shape</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.flare">
<tt class="descname">flare</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.flare" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a flare at the end of a <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> block.</p>
<p>The flare extends over a distance <tt class="docutils literal"><span class="pre">xf</span></tt> at the start (<tt class="docutils literal"><span class="pre">end=0</span></tt>)
or end (<tt class="docutils literal"><span class="pre">end=1</span></tt>) in direction <tt class="docutils literal"><span class="pre">dir[0]</span></tt> of the coords block,
and has a maximum amplitude of <tt class="docutils literal"><span class="pre">f</span></tt> in the <tt class="docutils literal"><span class="pre">dir[1]</span></tt> direction.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.isopar">
<tt class="descname">isopar</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.isopar" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an isoparametric transformation on a Coords.</p>
<p>This is a convenience method to transform a Coords object through
an isoparametric transformation. It is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Isopar</span><span class="p">(</span><span class="n">eltype</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span><span class="n">oldcoords</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p>See <tt class="xref py py-mod docutils literal"><span class="pre">plugins.isopar</span></tt> for more details.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.map">
<tt class="descname">map</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> mapped by a 3-D function.</p>
<p>This is one of the versatile mapping functions.
func is a numerical function which takes three arguments and produces
a list of three output values. The coordinates [x,y,z] will be
replaced by func(x,y,z).
The function must be applicable to arrays, so it should
only include numerical operations and functions understood by the
numpy module.
This method is one of several mapping methods. See also map1 and mapd.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="mi">4</span><span class="o">*</span><span class="n">z</span><span class="p">])</span>
<span class="go">[[ 2.  3.  4.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="fe.Model.map1">
<tt class="descname">map1</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.map1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> where coordinate i is mapped by a 1-D function.</p>
<p><cite>func</cite> is a numerical function which takes one argument and produces
one result. The coordinate dir will be replaced by func(coord[x]).
If no x is specified, x is taken equal to dir. 
The function must be applicable on arrays, so it should only
include numerical operations and functions understood by the
numpy module.
This method is one of several mapping methods. See also map and mapd.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.mapd">
<tt class="descname">mapd</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.mapd" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps one coordinate by a function of the distance to a point.</p>
<p><cite>func</cite> a numerical function which takes one argument and produces
one result. The coordinate <cite>dir</cite> will be replaced by <tt class="docutils literal"><span class="pre">func(d)</span></tt>,
where <tt class="docutils literal"><span class="pre">d</span></tt> is calculated as the distance to <cite>point</cite>.
The function must be applicable on arrays, so it should only
include numerical operations and functions understood by the
<tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> module.
By default, the distance d is calculated in 3-D, but one can specify
a limited set of axes to calculate a 2-D or 1-D distance.
This method is one of several mapping methods. See also
<tt class="xref py py-meth docutils literal"><span class="pre">map3()</span></tt> and <a class="reference internal" href="#fe.Model.map1" title="fe.Model.map1"><tt class="xref py py-meth docutils literal"><span class="pre">map1()</span></tt></a>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">E</span><span class="o">.</span><span class="n">mapd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span><span class="n">f</span><span class="o">.</span><span class="n">center</span><span class="p">(),[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>maps <tt class="docutils literal"><span class="pre">E</span></tt> on a sphere with radius 10.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.projectOnCylinder">
<tt class="descname">projectOnCylinder</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.projectOnCylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Project <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> on a cylinder with axis parallel to a global axis.</p>
<p>The default cylinder has its axis along the x-axis and a unit radius.
No points of the <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> should belong to the axis..</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.projectOnSphere">
<tt class="descname">projectOnSphere</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.projectOnSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Project <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> on a sphere.</p>
<p>The default sphere is a unit sphere at the origin.
The center of the sphere should not be part of the <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.reflect">
<tt class="descname">reflect</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.reflect" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflect the coordinates in direction dir against plane at pos.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>dir</cite>: int: direction of the reflection (default 0)</li>
<li><cite>pos</cite>: float: offset of the mirror plane from origin (default 0.0)</li>
<li><cite>inplace</cite>: boolean: change the coordinates inplace (default False)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="fe.Model.replace">
<tt class="descname">replace</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the coordinates along the axes i by those along j.</p>
<p>i and j are lists of axis numbers or single axis numbers.
replace ([0,1,2],[1,2,0]) will roll the axes by 1.
replace ([0,1],[1,0]) will swap axes 0 and 1.
An optionally third argument may specify another <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> object to take
the coordinates from. It should have the same dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.rollAxes">
<tt class="descname">rollAxes</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.rollAxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll the axes over the given amount.</p>
<p>Default is 1, thus axis 0 becomes the new 1 axis, 1 becomes 2 and
2 becomes 0.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.rot">
<tt class="descname">rot</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.rot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy rotated over angle around axis.</p>
<p>The angle is specified in degrees.
The axis is either one of (0,1,2) designating the global axes,
or a vector specifying an axis through the origin.
If no axis is specified, rotation is around the 2(z)-axis. This is
convenient for working on 2D-structures.</p>
<p>As a convenience, the user may also specify a 3x3 rotation matrix,
in which case the function rotate(mat) is equivalent to affine(mat).</p>
<p>All rotations are performed around the point [0,0,0], unless a
rotation origin is specified in the argument &#8216;around&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.rotate">
<tt class="descname">rotate</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy rotated over angle around axis.</p>
<p>The angle is specified in degrees.
The axis is either one of (0,1,2) designating the global axes,
or a vector specifying an axis through the origin.
If no axis is specified, rotation is around the 2(z)-axis. This is
convenient for working on 2D-structures.</p>
<p>As a convenience, the user may also specify a 3x3 rotation matrix,
in which case the function rotate(mat) is equivalent to affine(mat).</p>
<p>All rotations are performed around the point [0,0,0], unless a
rotation origin is specified in the argument &#8216;around&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.scale">
<tt class="descname">scale</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy scaled with scale[i] in direction i.</p>
<p>The scale should be a list of 3 scaling factors for the 3 axis
directions, or a single scaling factor.
In the latter case, dir (a single axis number or a list) may be given
to specify the direction(s) to scale. The default is to produce a
homothetic scaling.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[ 2.  2.  2.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span><span class="o">.</span><span class="n">scale</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">[ 2.  3.  4.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="fe.Model.shear">
<tt class="descname">shear</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.shear" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy skewed in the direction dir of plane (dir,dir1).</p>
<p>The coordinate dir is replaced with (dir + skew * dir1).</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.spherical">
<tt class="descname">spherical</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from spherical to cartesian after scaling.</p>
<ul class="simple">
<li><cite>dir</cite> specifies which coordinates are interpreted as resp.
longitude(theta), latitude(phi) and distance(r).</li>
<li><cite>scale</cite> will scale the coordinate values prior to the transformation.</li>
</ul>
<p>Angles are interpreted in degrees.
Latitude, i.e. the elevation angle, is measured from equator in
direction of north pole(90). South pole is -90.</p>
<p>If colat=True, the third coordinate is the colatitude (90-lat) instead.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.superSpherical">
<tt class="descname">superSpherical</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.superSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a superspherical transformation.</p>
<p>superSpherical is much like spherical, but adds some extra
parameters to enable the creation of virtually any surface.</p>
<p>Just like with spherical(), the input coordinates are interpreted as
the longitude, latitude and distance in a spherical coordinate system.</p>
<p><cite>dir</cite> specifies which coordinates are interpreted as resp.
longitude(theta), latitude(phi) and distance(r).
Angles are then interpreted in degrees.
Latitude, i.e. the elevation angle, is measured from equator in
direction of north pole(90). South pole is -90.
If colat=True, the third coordinate is the colatitude (90-lat) instead.</p>
<p><cite>scale</cite> will scale the coordinate values prior to the transformation.</p>
<p>The <cite>n</cite> and <cite>e</cite> parameters define exponential transformations of the
north_south (latitude), resp. the east_west (longitude) coordinates.
Default values of 1 result in a circle.</p>
<p><cite>k</cite> adds &#8216;eggness&#8217; to the shape: a difference between the northern and
southern hemisphere. Values &gt; 0 enlarge the southern hemishpere and
shrink the northern.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.swapAxes">
<tt class="descname">swapAxes</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.swapAxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap coordinate axes i and j.</p>
<p>Beware! This is different from numpy&#8217;s swapaxes() method !</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.toCylindrical">
<tt class="descname">toCylindrical</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.toCylindrical" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from cartesian to cylindrical coordinates.</p>
<p>dir specifies which coordinates axes are parallel to respectively the
cylindrical axes distance(r), angle(theta) and height(z). Default
order is [x,y,z].
The angle value is given in degrees.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.toSpherical">
<tt class="descname">toSpherical</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.toSpherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from cartesian to spherical coordinates.</p>
<p><cite>dir</cite> specifies which coordinates axes are parallel to respectively
the spherical axes distance(r), longitude(theta) and latitude(phi).
Latitude is the elevation angle measured from equator in direction
of north pole(90). South pole is -90.
Default order is [0,1,2], thus the equator plane is the (x,y)-plane.</p>
<p>The returned angle values are given in degrees.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.transformCS">
<tt class="descname">transformCS</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.transformCS" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a CoordinateSystem transformation on the Coords.</p>
<p>This method transforms the Coords object by the transformation that
turns the initial CoordinateSystem into the currentCoordinateSystem.</p>
<p>currentCS and initialCS are CoordSystem or (4,3) shaped Coords
instances. If initialCS is None, the global (x,y,z) axes are used.</p>
<p>E.g. the default initialCS and currentCS equal to:</p>
<div class="highlight-python"><pre> 0.  1.  0.
-1.  0.  0.
 0.  0.  1.
 0.  0.  0.</pre>
</div>
<p>result in a rotation of 90 degrees around the z-axis.</p>
<p>This is a convenience function equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">isopar</span><span class="p">(</span><span class="s">&#39;tet4&#39;</span><span class="p">,</span><span class="n">currentCS</span><span class="p">,</span><span class="n">initialCS</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="fe.Model.translate">
<tt class="descname">translate</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> object.</p>
<p>The translation vector can be specified in one of the following ways:</p>
<ul class="simple">
<li>an axis number (0,1,2),</li>
<li>a single translation vector,</li>
<li>an array of translation vectors.</li>
</ul>
<p>If an axis number is given, a unit vector in the direction of the
specified axis will be used.
If an array of translation vectors is given, it should be
broadcastable to the size of the <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> array.
If a distance value is given, the translation vector is multiplied
with this value before it is added to the coordinates.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="fe.Model.trl">
<tt class="descname">trl</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.Model.trl" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> object.</p>
<p>The translation vector can be specified in one of the following ways:</p>
<ul class="simple">
<li>an axis number (0,1,2),</li>
<li>a single translation vector,</li>
<li>an array of translation vectors.</li>
</ul>
<p>If an axis number is given, a unit vector in the direction of the
specified axis will be used.
If an array of translation vectors is given, it should be
broadcastable to the size of the <tt class="xref py py-class docutils literal"><span class="pre">Coords</span></tt> array.
If a distance value is given, the translation vector is multiplied
with this value before it is added to the coordinates.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Coords</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[ 1.  2.  1.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">x</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">[ 1.  2.  1.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="fe.Model.getElems">
<tt class="descname">getElems</tt><big>(</big><em>sets</em><big>)</big><a class="headerlink" href="#fe.Model.getElems" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the definitions of the elements in sets.</p>
<p>sets should be a list of element sets with length equal to the
number of element groups. Each set contains element numbers local
to that group.</p>
<p>As the elements can be grouped according to plexitude,
this function returns a list of element arrays matching
the element groups in self.elems. Some of these arrays may
be empty.</p>
<p>It also provide the global and group element numbers, since they
had to be calculated anyway.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#fe.Model.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of the object.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.write">
<tt class="descname">write</tt><big>(</big><em>fil</em>, <em>sep=' '</em>, <em>mode='w'</em><big>)</big><a class="headerlink" href="#fe.Model.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a Geometry to a .pgf file.</p>
<p>If fil is a string, a file with that name is opened. Else fil should
be an open file.
The Geometry is then written to that file in a native format, using
sep as separator between the coordinates.
If fil is a string, the file is closed prior to returning.</p>
</dd></dl>

<dl class="method">
<dt id="fe.Model.renumber">
<tt class="descname">renumber</tt><big>(</big><em>old=None</em>, <em>new=None</em><big>)</big><a class="headerlink" href="#fe.Model.renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Renumber a set of nodes.</p>
<p>old and new are equally sized lists with unique node numbers, each
smaller that the number of nodes in the model.
The old numbers will be renumbered to the new numbers.
If one of the lists is None, a range with the length of the
other is used.
If the lists are shorter than the number of nodes, the remaining
nodes will be numbered in an unspecified order.
If both lists are None, the nodes are renumbered randomly.</p>
<p>This function returns a tuple (old,new) with the full renumbering
vectors used. The first gives the old node numbers of the current
numbers, the second gives the new numbers cooresponding with the
old ones.</p>
</dd></dl>

</dd></dl>

<p><tt class="docutils literal"><span class="pre">Functions</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">fe</span></tt></p>
<dl class="function">
<dt id="fe.mergedModel">
<tt class="descclassname">fe.</tt><tt class="descname">mergedModel</tt><big>(</big><em>meshes</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#fe.mergedModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fe Model obtained from merging individual models.</p>
<p>The input arguments are (coords,elems) tuples.
The return value is a merged fe Model.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
        <p class="logo"><a href="http://pyformex.org/">
        <img class="logo" src="../_static/pyformex_logo_small.png" alt="Logo"/>
        </a></p>
    <h3><a href="../index.html">Documentation</a></h3>
  <h4>Previous topic</h4>
  <p class="topless"><a href="properties.html"
                        title="previous chapter">39. <tt class="docutils literal docutils literal"><span class="pre">properties</span></tt> &#8212; General framework for attributing properties to geometrical elements.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="fe_abq.html"
                        title="next chapter">41. <tt class="docutils literal"><span class="pre">fe_abq</span></tt> &#8212; Exporting finite element models in Abaqus™ input file format.</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="fe_abq.html" title="41. fe_abq — Exporting finite element models in Abaqus™ input file format."
             >next</a> |</li>
        <li class="right" >
          <a href="properties.html" title="39. properties — General framework for attributing properties to geometrical elements."
             >previous</a> |</li>
    <li><a href="http://pyformex.org/">pyFormex Home</a> &gt;</li>
    
        <li><a href="../index.html">pyFormex Documentation</a> &gt;</li>

          <li><a href="../refman.html" >pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Benedict Verhegghe.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.5.
    </div>
  </body>
</html>