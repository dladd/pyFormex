


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<!-- 
##
##  This file is part of the pyFormex project.
##  pyFormex is a tool for generating, manipulating and transforming 3D
##  geometrical models by sequences of mathematical operations.
##  Home page: http://pyformex.org
##  Project page:  http://savannah.nongnu.org/projects/pyformex/
##  Copyright (C) Benedict Verhegghe (benedict.verhegghe@ugent.be) 
##  Distributed under the GNU General Public License version 3 or later.
##
##
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see http://www.gnu.org/licenses/.
##
-->

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>26. viewport — Interactive OpenGL Canvas embedded in a Qt4 widget. &mdash; pyFormex v0.8.8 documentation</title>

    <link rel="stylesheet" href="../_static/pyformex.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="pyFormex v0.8.8 documentation" href="../index.html" />
    <link rel="up" title="pyFormex reference manual" href="../refman.html" />
    <link rel="next" title="27. camera — OpenGL camera handling" href="camera.html" />
    <link rel="prev" title="25. canvas — This implements an OpenGL drawing widget for painting 3D scenes." href="canvas.html" />
<link rel="icon" type="image/png" href="_static/pyformex_fav.png" />

  </head>
  <body>

<div class="header">
  <a href="http://pyformex.org">
  <img src="http://www.nongnu.org/pyformex/_static/scallop_dome_small.png" alt="scallop dome" border="0" hspace="20" vspace="12" align="left" />
  <img src="http://www.nongnu.org/pyformex/_static/pyformex-logo-2.png" alt="pyformex logo" border="0" hspace="10" vspace="8" align="left" />
  </a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="camera.html" title="27. camera — OpenGL camera handling"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="canvas.html" title="25. canvas — This implements an OpenGL drawing widget for painting 3D scenes."
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pyFormex v0.8.8 documentation</a> &gt;</li>
          <li><a href="../refman.html" accesskey="U">pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div align="center">

<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_s-xclick"/>
<input type="hidden" name="hosted_button_id" value="P7J4AM4QULB4Q"/>
<input type="image" src="https://www.paypal.com/en_US/BE/i/btn/btn_donateCC_LG.gif" name="submit" alt="PayPal - The safer, easier way to pay online!"/>
<img alt="" border="0" src="https://www.paypal.com/nl_NL/i/scr/pixel.gif" width="1" height="1"/>
</form>

</div>
   

  <h4>Previous topic</h4>
  <p class="topless"><a href="canvas.html"
                        title="previous chapter">25. <tt class="docutils literal docutils literal docutils literal"><span class="pre">canvas</span></tt> &#8212; This implements an OpenGL drawing widget for painting 3D scenes.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="camera.html"
                        title="next chapter">27. <tt class="docutils literal docutils literal docutils literal"><span class="pre">camera</span></tt> &#8212; OpenGL camera handling</a></p>
  
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>

<div align="center">
  <p>
  <a href="http://www.fsf.org/register_form?referrer=8491"><img src="http://www.nongnu.org/pyformex/_static/fsf-member8491.png" alt="[FSF Associate Member]" width="89" height="31"  /></a>
  </p>
  <p>
    <a href="http://validator.w3.org/check?uri=referer"><img
      src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Transitional" height="31" width="88" /></a>
  </p>
</div>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-viewport">
<span id="viewport-interactive-opengl-canvas-embedded-in-a-qt4-widget"></span><span id="sec-ref-viewport"></span><h1>26. <a class="reference internal" href="#module-viewport" title="viewport: Interactive OpenGL Canvas embedded in a Qt4 widget."><tt class="xref py py-mod docutils literal"><span class="pre">viewport</span></tt></a> &#8212; Interactive OpenGL Canvas embedded in a Qt4 widget.<a class="headerlink" href="#module-viewport" title="Permalink to this headline">¶</a></h1>
<p>This module implements user interaction with the OpenGL canvas defined in
module <a class="reference internal" href="canvas.html#module-canvas" title="canvas: This implements an OpenGL drawing widget for painting 3D scenes."><tt class="xref py py-mod docutils literal"><span class="pre">canvas</span></tt></a>.
<cite>QtCanvas</cite> is a single interactive OpenGL canvas, while <cite>MultiCanvas</cite>
implements a dynamic array of multiple canvases.</p>
<p><tt class="docutils literal"><span class="pre">Classes</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">viewport</span></tt></p>
<dl class="class">
<dt id="viewport.CursorShapeHandler">
<em class="property">class </em><tt class="descclassname">viewport.</tt><tt class="descname">CursorShapeHandler</tt><big>(</big><em>widget</em><big>)</big><a class="headerlink" href="#viewport.CursorShapeHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for handling the mouse cursor shape on the Canvas.</p>
<dl class="method">
<dt id="viewport.CursorShapeHandler.setCursorShape">
<tt class="descname">setCursorShape</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#viewport.CursorShapeHandler.setCursorShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the cursor shape to shape</p>
</dd></dl>

<dl class="method">
<dt id="viewport.CursorShapeHandler.setCursorShapeFromFunc">
<tt class="descname">setCursorShapeFromFunc</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#viewport.CursorShapeHandler.setCursorShapeFromFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the cursor shape to shape</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viewport.CanvasMouseHandler">
<em class="property">class </em><tt class="descclassname">viewport.</tt><tt class="descname">CanvasMouseHandler</tt><a class="headerlink" href="#viewport.CanvasMouseHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for handling the mouse events on the Canvas.</p>
<dl class="method">
<dt id="viewport.CanvasMouseHandler.getMouseFunc">
<tt class="descname">getMouseFunc</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.CanvasMouseHandler.getMouseFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mouse function bound to self.button and self.mod</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viewport.QtCanvas">
<em class="property">class </em><tt class="descclassname">viewport.</tt><tt class="descname">QtCanvas</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas" title="Permalink to this definition">¶</a></dt>
<dd><p>A canvas for OpenGL rendering.</p>
<p>This class provides interactive functionality for the OpenGL canvas
provided by the <a class="reference internal" href="canvas.html#canvas.Canvas" title="canvas.Canvas"><tt class="xref py py-class docutils literal"><span class="pre">canvas.Canvas</span></tt></a> class.</p>
<p>Interactivity is highly dependent on Qt4. Putting the interactive
functions in a separate class makes it esier to use the Canvas class
in non-interactive situations or combining it with other GUI toolsets.</p>
<p>The QtCanvas constructor may have positional and keyword arguments. The
positional arguments are passed to the QtOpenGL.QGLWidget constructor,
while the keyword arguments are passed to the canvas.Canvas constructor.</p>
<dl class="method">
<dt id="viewport.QtCanvas.getSize">
<tt class="descname">getSize</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.getSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of this canvas</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.changeSize">
<tt class="descname">changeSize</tt><big>(</big><em>width</em>, <em>height</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.changeSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize the canvas to (width x height).</p>
<p>If a negative value is given for either width or height,
the corresponding size is set equal to the maximum visible size
(the size of the central widget of the main window).</p>
<p>Note that this may not have the expected result when multiple
viewports are used.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.resetOptions">
<tt class="descname">resetOptions</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.resetOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the Drawing options to some defaults</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setOptions">
<tt class="descname">setOptions</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Drawing options to some values</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setCursorShape">
<tt class="descname">setCursorShape</tt><big>(</big><em>shape</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setCursorShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the cursor shape to shape</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setCursorShapeFromFunc">
<tt class="descname">setCursorShapeFromFunc</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setCursorShapeFromFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the cursor shape to shape</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.getMouseFunc">
<tt class="descname">getMouseFunc</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.getMouseFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mouse function bound to self.button and self.mod</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.mouse_rectangle_zoom">
<tt class="descname">mouse_rectangle_zoom</tt><big>(</big><em>x</em>, <em>y</em>, <em>action</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.mouse_rectangle_zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>Process mouse events during interactive rectangle zooming.</p>
<p>On PRESS, record the mouse position.
On MOVE, create a rectangular zoom window.
On RELEASE, zoom to the picked rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setPickable">
<tt class="descname">setPickable</tt><big>(</big><em>nrs=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setPickable" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the list of pickable actors</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.start_selection">
<tt class="descname">start_selection</tt><big>(</big><em>mode</em>, <em>filter</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.start_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Start an interactive picking mode.</p>
<p>If selection mode was already started, mode is disregarded and
this can be used to change the filter method.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.wait_selection">
<tt class="descname">wait_selection</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.wait_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for the user to interactively make a selection.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.finish_selection">
<tt class="descname">finish_selection</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.finish_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>End an interactive picking mode.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.accept_selection">
<tt class="descname">accept_selection</tt><big>(</big><em>clear=False</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.accept_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Accept or cancel an interactive picking mode.</p>
<p>If clear == True, the current selection is cleared.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.cancel_selection">
<tt class="descname">cancel_selection</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.cancel_selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel an interactive picking mode and clear the selection.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.pick">
<tt class="descname">pick</tt><big>(</big><em>mode='actor'</em>, <em>oneshot=False</em>, <em>func=None</em>, <em>filter=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.pick" title="Permalink to this definition">¶</a></dt>
<dd><p>Interactively pick objects from the viewport.</p>
<ul>
<li><p class="first"><cite>mode</cite>: defines what to pick : one of
<tt class="docutils literal"><span class="pre">['actor','element','point','number','edge']</span></tt></p>
</li>
<li><p class="first"><cite>oneshot</cite>: if True, the function returns as soon as the user ends
a picking operation. The default is to let the user
modify his selection and only to return after an explicit
cancel (ESC or right mouse button).</p>
</li>
<li><p class="first"><cite>func</cite>: if specified, this function will be called after each
atomic pick operation. The Collection with the currently selected
objects is passed as an argument. This can e.g. be used to highlight
the selected objects during picking.</p>
</li>
<li><p class="first"><cite>filter</cite>: defines what elements to retain from the selection: one of
<tt class="docutils literal"><span class="pre">[None,'single','closest,'connected']</span></tt>.</p>
<ul>
<li><p class="first">None (default) will return the complete selection.</p>
</li>
<li><p class="first">&#8216;closest&#8217; will only keep the element closest to the user.</p>
</li>
<li><p class="first">&#8216;connected&#8217; will only keep elements connected to
- the closest element (set picked)
- what is already in the selection (add picked).</p>
<p>Currently this only works when picking mode is &#8216;element&#8217; and
for Actors having a partitionByConnection method.</p>
</li>
</ul>
</li>
</ul>
<p>When the picking operation is finished, the selection is returned.
The return value is always a Collection object.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.pickNumbers">
<tt class="descname">pickNumbers</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.pickNumbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Go into number picking mode and return the selection.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.idraw">
<tt class="descname">idraw</tt><big>(</big><em>mode='point'</em>, <em>npoints=-1</em>, <em>zplane=0.0</em>, <em>func=None</em>, <em>coords=None</em>, <em>preview=False</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.idraw" title="Permalink to this definition">¶</a></dt>
<dd><p>Interactively draw on the canvas.</p>
<p>This function allows the user to interactively create points in 3D
space and collects the subsequent points in a Coords object. The
interpretation of these points is left to the caller.</p>
<ul class="simple">
<li><cite>mode</cite>: one of the drawing modes, specifying the kind of objects you
want to draw. This is passed to the specified <cite>func</cite>.</li>
<li><cite>npoints</cite>: If -1, the user can create any number of points. When &gt;=0,
the function will return when the total number of points in the
collection reaches the specified value.</li>
<li><cite>zplane</cite>: the depth of the z-plane on which the 2D drawing is done.</li>
<li><cite>func</cite>: a function that is called after each atomic drawing
operation. It is typically used to draw a preview using the current
set of points. The function is passed the current Coords and the
<cite>mode</cite> as arguments.</li>
<li><cite>coords</cite>: an initial set of coordinates to which the newly created
points should be added. If specified, <cite>npoints</cite> also counts these
initial points.</li>
<li><cite>preview</cite>: <strong>Experimental</strong> If True, the preview funcion will also
be called during mouse movement with a pressed button, allowing to
preview the result before a point is created.</li>
</ul>
<p>The drawing operation is finished when the number of requested points
has been reached, or when the user clicks the right mouse button or
hits &#8216;ENTER&#8217;.
The return value is a (n,3) shaped Coords array.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.start_draw">
<tt class="descname">start_draw</tt><big>(</big><em>mode</em>, <em>zplane</em>, <em>coords</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.start_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Start an interactive drawing mode.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.finish_draw">
<tt class="descname">finish_draw</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.finish_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>End an interactive drawing mode.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.accept_draw">
<tt class="descname">accept_draw</tt><big>(</big><em>clear=False</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.accept_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel an interactive drawing mode.</p>
<p>If clear == True, the current drawing is cleared.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.cancel_draw">
<tt class="descname">cancel_draw</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.cancel_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel an interactive drawing mode and clear the drawing.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.mouse_draw">
<tt class="descname">mouse_draw</tt><big>(</big><em>x</em>, <em>y</em>, <em>action</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.mouse_draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Process mouse events during interactive drawing.</p>
<p>On PRESS, do nothing.
On MOVE, do nothing.
On RELEASE, add the point to the point list.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.start_drawing">
<tt class="descname">start_drawing</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.start_drawing" title="Permalink to this definition">¶</a></dt>
<dd><p>Start an interactive line drawing mode.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.wait_drawing">
<tt class="descname">wait_drawing</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.wait_drawing" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for the user to interactively draw a line.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.finish_drawing">
<tt class="descname">finish_drawing</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.finish_drawing" title="Permalink to this definition">¶</a></dt>
<dd><p>End an interactive drawing mode.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.accept_drawing">
<tt class="descname">accept_drawing</tt><big>(</big><em>clear=False</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.accept_drawing" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel an interactive drawing mode.</p>
<p>If clear == True, the current drawing is cleared.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.cancel_drawing">
<tt class="descname">cancel_drawing</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.cancel_drawing" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel an interactive drawing mode and clear the drawing.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.edit_drawing">
<tt class="descname">edit_drawing</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.edit_drawing" title="Permalink to this definition">¶</a></dt>
<dd><p>Edit an interactive drawing.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.drawLinesInter">
<tt class="descname">drawLinesInter</tt><big>(</big><em>mode='line'</em>, <em>oneshot=False</em>, <em>func=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.drawLinesInter" title="Permalink to this definition">¶</a></dt>
<dd><p>Interactively draw lines on the canvas.</p>
<ul class="simple">
<li>oneshot: if True, the function returns as soon as the user ends
a drawing operation. The default is to let the user
draw multiple lines and only to return after an explicit
cancel (ESC or right mouse button).</li>
<li>func: if specified, this function will be called after each
atomic drawing operation. The current drawing is passed as
an argument. This can e.g. be used to show the drawing.</li>
</ul>
<p>When the drawing operation is finished, the drawing is returned.
The return value is a (n,2,2) shaped array.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.dynarot">
<tt class="descname">dynarot</tt><big>(</big><em>x</em>, <em>y</em>, <em>action</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.dynarot" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform dynamic rotation operation.</p>
<p>This function processes mouse button events controlling a dynamic
rotation operation. The action is one of PRESS, MOVE or RELEASE.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.dynapan">
<tt class="descname">dynapan</tt><big>(</big><em>x</em>, <em>y</em>, <em>action</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.dynapan" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform dynamic pan operation.</p>
<p>This function processes mouse button events controlling a dynamic
pan operation. The action is one of PRESS, MOVE or RELEASE.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.dynazoom">
<tt class="descname">dynazoom</tt><big>(</big><em>x</em>, <em>y</em>, <em>action</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.dynazoom" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform dynamic zoom operation.</p>
<p>This function processes mouse button events controlling a dynamic
zoom operation. The action is one of PRESS, MOVE or RELEASE.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.wheel_zoom">
<tt class="descname">wheel_zoom</tt><big>(</big><em>delta</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.wheel_zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>Zoom by rotating a wheel over an angle delta</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.emit_done">
<tt class="descname">emit_done</tt><big>(</big><em>x</em>, <em>y</em>, <em>action</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.emit_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Emit a DONE event by clicking the mouse.</p>
<p>This is equivalent to pressing the ENTER button.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.emit_cancel">
<tt class="descname">emit_cancel</tt><big>(</big><em>x</em>, <em>y</em>, <em>action</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.emit_cancel" title="Permalink to this definition">¶</a></dt>
<dd><p>Emit a CANCEL event by clicking the mouse.</p>
<p>This is equivalent to pressing the ESC button.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.draw_state_rect">
<tt class="descname">draw_state_rect</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.draw_state_rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the pos and draw a rectangle to it.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.mouse_pick">
<tt class="descname">mouse_pick</tt><big>(</big><em>x</em>, <em>y</em>, <em>action</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.mouse_pick" title="Permalink to this definition">¶</a></dt>
<dd><p>Process mouse events during interactive picking.</p>
<p>On PRESS, record the mouse position.
On MOVE, create a rectangular picking window.
On RELEASE, pick the objects inside the rectangle.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.pick_actors">
<tt class="descname">pick_actors</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.pick_actors" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the list of actors inside the pick_window.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.pick_parts">
<tt class="descname">pick_parts</tt><big>(</big><em>obj_type</em>, <em>max_objects</em>, <em>store_closest=False</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.pick_parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the list of actor parts inside the pick_window.</p>
<p>obj_type can be &#8216;element&#8217;, &#8216;face&#8217;, &#8216;edge&#8217; or &#8216;point&#8217;.
&#8216;face&#8217; and &#8216;edge&#8217; are only available for Mesh type geometry.
max_objects specifies the maximum number of objects</p>
<p>The picked object numbers are stored in self.picked.
If store_closest==True, the closest picked object is stored in as a
tuple ( [actor,object] ,distance) in self.picked_closest</p>
<p>A list of actors from which can be picked may be given.
If so, the resulting keys are indices in this list.
By default, the full actor list is used.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.pick_elements">
<tt class="descname">pick_elements</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.pick_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the list of actor elements inside the pick_window.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.pick_points">
<tt class="descname">pick_points</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.pick_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the list of actor points inside the pick_window.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.pick_edges">
<tt class="descname">pick_edges</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.pick_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the list of actor edges inside the pick_window.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.pick_faces">
<tt class="descname">pick_faces</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.pick_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the list of actor faces inside the pick_window.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.pick_numbers">
<tt class="descname">pick_numbers</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.pick_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the numbers inside the pick_window.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.draw_state_line">
<tt class="descname">draw_state_line</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.draw_state_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the pos and draw a line to it.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.mouse_draw_line">
<tt class="descname">mouse_draw_line</tt><big>(</big><em>x</em>, <em>y</em>, <em>action</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.mouse_draw_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Process mouse events during interactive drawing.</p>
<p>On PRESS, record the mouse position.
On MOVE, draw a line.
On RELEASE, add the line to the drawing.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.mousePressEvent">
<tt class="descname">mousePressEvent</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.mousePressEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a mouse press event.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.mouseMoveEvent">
<tt class="descname">mouseMoveEvent</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.mouseMoveEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a mouse move event.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.mouseReleaseEvent">
<tt class="descname">mouseReleaseEvent</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.mouseReleaseEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a mouse release event.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.wheelEvent">
<tt class="descname">wheelEvent</tt><big>(</big><em>e</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.wheelEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Process a wheel event.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.enable_lighting">
<tt class="descname">enable_lighting</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.enable_lighting" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle lights on/off.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.has_lighting">
<tt class="descname">has_lighting</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.has_lighting" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the status of the lighting.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.resetDefaults">
<tt class="descname">resetDefaults</tt><big>(</big><em>dict={}</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.resetDefaults" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all the settings to their default values.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setAmbient">
<tt class="descname">setAmbient</tt><big>(</big><em>ambient</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setAmbient" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the global ambient lighting for the canvas</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setMaterial">
<tt class="descname">setMaterial</tt><big>(</big><em>matname</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setMaterial" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the default material light properties for the canvas</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.resetLighting">
<tt class="descname">resetLighting</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.resetLighting" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the light parameters</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setRenderMode">
<tt class="descname">setRenderMode</tt><big>(</big><em>mode</em>, <em>lighting=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setRenderMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the rendering mode.</p>
<p>This sets or changes the rendermode and lighting attributes.
If lighting is not specified, it is set depending on the rendermode.</p>
<p>If the canvas has not been initialized, this merely sets the
attributes self.rendermode and self.settings.lighting.
If the canvas was already initialized (it has a camera), and one of
the specified settings is fdifferent from the existing, the new mode
is set, the canvas is re-initialized according to the newly set mode,
and everything is redrawn with the new mode.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setToggle">
<tt class="descname">setToggle</tt><big>(</big><em>attr</em>, <em>state</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setToggle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or toggle a boolean settings attribute</p>
<p>Furthermore, if a Canvas method do_ATTR is defined, it will be called
with the old and new toggle state as a parameter.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.do_lighting">
<tt class="descname">do_lighting</tt><big>(</big><em>state</em>, <em>oldstate=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.do_lighting" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle lights on/off.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setLineWidth">
<tt class="descname">setLineWidth</tt><big>(</big><em>lw</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setLineWidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the linewidth for line rendering.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setLineStipple">
<tt class="descname">setLineStipple</tt><big>(</big><em>repeat</em>, <em>pattern</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setLineStipple" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the linestipple for line rendering.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setPointSize">
<tt class="descname">setPointSize</tt><big>(</big><em>sz</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setPointSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the size for point drawing.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setBackground">
<tt class="descname">setBackground</tt><big>(</big><em>color=None</em>, <em>image=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setBackground" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the color(s) and image.</p>
<p>Change the background settings according to the specified parameters
and set the canvas background accordingly. Only (and all) the specified
parameters get a new value.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>color</cite>: either a single color, a list of two colors or a list of
four colors.</li>
<li><cite>image</cite>: an image to be set.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.createBackground">
<tt class="descname">createBackground</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.createBackground" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the background object.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setFgColor">
<tt class="descname">setFgColor</tt><big>(</big><em>color</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setFgColor" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the default foreground color.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setSlColor">
<tt class="descname">setSlColor</tt><big>(</big><em>color</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setSlColor" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the highlight color.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setTriade">
<tt class="descname">setTriade</tt><big>(</big><em>on=None</em>, <em>pos='lb'</em>, <em>siz=100</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setTriade" title="Permalink to this definition">¶</a></dt>
<dd><p>Toggle the display of the global axes on or off.</p>
<p>If on is True, a triade of global axes is displayed, if False it is
removed. The default (None) toggles between on and off.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the canvas to the background color.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setDefaults">
<tt class="descname">setDefaults</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setDefaults" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate the canvas settings in the GL machine.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.overrideMode">
<tt class="descname">overrideMode</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.overrideMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Override some settings</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.glinit">
<tt class="descname">glinit</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.glinit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the rendering machine.</p>
<p>The rendering machine is initialized according to self.settings:
- self.rendermode: one of
- self.lighting</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.glupdate">
<tt class="descname">glupdate</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.glupdate" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush all OpenGL commands, making sure the display is updated.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.display">
<tt class="descname">display</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.display" title="Permalink to this definition">¶</a></dt>
<dd><p>(Re)display all the actors in the scene.</p>
<p>This should e.g. be used when actors are added to the scene,
or after changing  camera position/orientation or lens.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.begin_2D_drawing">
<tt class="descname">begin_2D_drawing</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.begin_2D_drawing" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the canvas for 2D drawing on top of 3D canvas.</p>
<p>The 2D drawing operation should be ended by calling end_2D_drawing. 
It is assumed that you will not try to change/refresh the normal
3D drawing cycle during this operation.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.end_2D_drawing">
<tt class="descname">end_2D_drawing</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.end_2D_drawing" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel the 2D drawing mode initiated by begin_2D_drawing.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setBbox">
<tt class="descname">setBbox</tt><big>(</big><em>bbox=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setBbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the bounding box of the scene you want to be visible.</p>
<p>bbox is a (2,3) shaped array specifying a bounding box.
If no bbox is given, the bounding box of all the actors in the
scene is used, or if the scene is empty, a default unit bounding box.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.addActor">
<tt class="descname">addActor</tt><big>(</big><em>itemlist</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.addActor" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a 3D actor or a list thereof to the 3D scene.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.addHighlight">
<tt class="descname">addHighlight</tt><big>(</big><em>itemlist</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.addHighlight" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a highlight or a list thereof to the 3D scene.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.addAnnotation">
<tt class="descname">addAnnotation</tt><big>(</big><em>itemlist</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.addAnnotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an annotation or a list thereof to the 3D scene.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.addDecoration">
<tt class="descname">addDecoration</tt><big>(</big><em>itemlist</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.addDecoration" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a 2D decoration or a list thereof to the canvas.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.addAny">
<tt class="descname">addAny</tt><big>(</big><em>itemlist=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.addAny" title="Permalink to this definition">¶</a></dt>
<dd><p>Add any  item or list.</p>
<p>This will add any actor/annotation/decoration item or a list
of any such items  to the canvas. This is the prefered method to add
an item to the canvas, because it makes sure that each item is added
to the proper list. It can however not be used to add highlights.</p>
<p>If you have a long list of a single type, it is more efficient to
use one of the type specific add methods.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.removeActor">
<tt class="descname">removeActor</tt><big>(</big><em>itemlist=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.removeActor" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a 3D actor or a list thereof from the 3D scene.</p>
<p>Without argument, removes all actors from the scene.
This also resets the bounding box for the canvas autozoom.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.removeHighlight">
<tt class="descname">removeHighlight</tt><big>(</big><em>itemlist=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.removeHighlight" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a highlight or a list thereof from the 3D scene.</p>
<p>Without argument, removes all highlights from the scene.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.removeAnnotation">
<tt class="descname">removeAnnotation</tt><big>(</big><em>itemlist=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.removeAnnotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an annotation or a list thereof from the 3D scene.</p>
<p>Without argument, removes all annotations from the scene.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.removeDecoration">
<tt class="descname">removeDecoration</tt><big>(</big><em>itemlist=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.removeDecoration" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a 2D decoration or a list thereof from the canvas.</p>
<p>Without argument, removes all decorations from the scene.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.removeAny">
<tt class="descname">removeAny</tt><big>(</big><em>itemlist=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.removeAny" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a list of any actor/highlights/annotation/decoration items.</p>
<p>This will remove the items from any of the canvas lists in which the
item appears.
itemlist can also be a single item instead of a list.
If None is specified, all items from all lists will be removed.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.redrawAll">
<tt class="descname">redrawAll</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.redrawAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Redraw all actors in the scene.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.setCamera">
<tt class="descname">setCamera</tt><big>(</big><em>bbox=None</em>, <em>angles=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.setCamera" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the camera looking under angles at bbox.</p>
<p>This function sets the camera parameters to view the specified
bbox volume from the specified viewing direction.</p>
<p>Parameters:</p>
<ul class="simple">
<li><cite>bbox</cite>: the bbox of the volume looked at</li>
<li><cite>angles</cite>: the camera angles specifying the viewing direction.
It can also be a string, the key of one of the predefined
camera directions</li>
</ul>
<p>If no angles are specified, the viewing direction remains constant.
The scene center (camera focus point), camera distance, fovy and
clipping planes are adjusted to make the whole bbox viewed from the
specified direction fit into the screen.</p>
<p>If no bbox is specified, the following remain constant:
the center of the scene, the camera distance, the lens opening
and aspect ratio, the clipping planes. In other words the camera
is moving on a spherical surface and keeps focusing on the same
point.</p>
<p>If both are specified, then first the scene center is set,
then the camera angles, and finally the camera distance.</p>
<p>In the current implementation, the lens fovy and aspect are not
changed by this function. Zoom adjusting is performed solely by
changing the camera distance.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.project">
<tt class="descname">project</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>locked=False</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the object coordinates (x,y,z) to window coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.unProject">
<tt class="descname">unProject</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>locked=False</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.unProject" title="Permalink to this definition">¶</a></dt>
<dd><p>Map the window coordinates (x,y,z) to object coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.zoom">
<tt class="descname">zoom</tt><big>(</big><em>f</em>, <em>dolly=True</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>Dolly zooming.</p>
<p>Zooms in with a factor <cite>f</cite> by moving the camera closer
to the scene. This does noet change the camera&#8217;s FOV setting.
It will change the perspective view though.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.zoomRectangle">
<tt class="descname">zoomRectangle</tt><big>(</big><em>x0</em>, <em>y0</em>, <em>x1</em>, <em>y1</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.zoomRectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Rectangle zooming.</p>
<p>Zooms in/out by changing the area and position of the visible
part of the lens.
Unlike zoom(), this does not change the perspective view.</p>
<p><cite>x0,y0,x1,y1</cite> are pixel coordinates of the lower left and upper right
corners of the area of the lens that will be mapped on the
canvas viewport.
Specifying values that lead to smaller width/height will zoom in.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.zoomCentered">
<tt class="descname">zoomCentered</tt><big>(</big><em>w</em>, <em>h</em>, <em>x=None</em>, <em>y=None</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.zoomCentered" title="Permalink to this definition">¶</a></dt>
<dd><p>Rectangle zooming with specified center.</p>
<p>This is like zoomRectangle, but the zoom rectangle is specified
by its center and size, which may be more appropriate when using
off-center zooming.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.zoomAll">
<tt class="descname">zoomAll</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.zoomAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Rectangle zoom to make full scene visible.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.saveBuffer">
<tt class="descname">saveBuffer</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.saveBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the current OpenGL buffer</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.showBuffer">
<tt class="descname">showBuffer</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.QtCanvas.showBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the saved buffer</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.draw_focus_rectangle">
<tt class="descname">draw_focus_rectangle</tt><big>(</big><em>ofs=0</em>, <em>color=(1.0</em>, <em>0.2</em>, <em>0.4)</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.draw_focus_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the focus rectangle.</p>
<p>The specified width is HALF of the line width</p>
</dd></dl>

<dl class="method">
<dt id="viewport.QtCanvas.draw_cursor">
<tt class="descname">draw_cursor</tt><big>(</big><em>x</em>, <em>y</em><big>)</big><a class="headerlink" href="#viewport.QtCanvas.draw_cursor" title="Permalink to this definition">¶</a></dt>
<dd><p>draw the cursor</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viewport.NewiMultiCanvas">
<em class="property">class </em><tt class="descclassname">viewport.</tt><tt class="descname">NewiMultiCanvas</tt><big>(</big><em>parent=None</em><big>)</big><a class="headerlink" href="#viewport.NewiMultiCanvas" title="Permalink to this definition">¶</a></dt>
<dd><p>An OpenGL canvas with multiple viewports and QT interaction.</p>
<p>The MultiCanvas implements a central QT widget containing one or more
QtCanvas widgets.</p>
<dl class="method">
<dt id="viewport.NewiMultiCanvas.changeLayout">
<tt class="descname">changeLayout</tt><big>(</big><em>nvps=None</em>, <em>ncols=None</em>, <em>nrows=None</em>, <em>pos=None</em>, <em>rstretch=None</em>, <em>cstretch=None</em><big>)</big><a class="headerlink" href="#viewport.NewiMultiCanvas.changeLayout" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the lay-out of the viewports on the OpenGL widget.</p>
<p>nvps: number of viewports
ncols: number of columns
nrows: number of rows
pos: list holding the position and span of each viewport
[[row,col,rowspan,colspan],...]
rstretch: list holding the stretch factor for each row
cstretch: list holding the stretch factor for each column
(rows/columns with a higher stretch factor take more of the
available space)
Each of this parameters is optional.</p>
<p>If pos is given, it specifies all viewports and nvps, nrows and ncols
are disregarded.</p>
<p>Else:</p>
<p>If nvps is given, it specifies the number of viewports in the layout.
Else, nvps will be set to the current number of viewports.</p>
<p>If ncols is an int, viewports are laid out rowwise over ncols
columns and nrows is ignored. If ncols is None and nrows is an int,
viewports are laid out columnwise over nrows rows.</p>
<p>If nvps is not equal to the current number of viewports, viewports
will be added or removed to match the requested number.</p>
<p>By default they are laid out rowwise over two columns.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.NewiMultiCanvas.createView">
<tt class="descname">createView</tt><big>(</big><em>shared=None</em><big>)</big><a class="headerlink" href="#viewport.NewiMultiCanvas.createView" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new viewport</p>
<p>If another QtCanvas instance is passed, both will share the same
display lists and textures.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.NewiMultiCanvas.addView">
<tt class="descname">addView</tt><big>(</big><em>view</em>, <em>row</em>, <em>col</em>, <em>rowspan=1</em>, <em>colspan=1</em><big>)</big><a class="headerlink" href="#viewport.NewiMultiCanvas.addView" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new viewport and make it visible</p>
</dd></dl>

<dl class="method">
<dt id="viewport.NewiMultiCanvas.removeView">
<tt class="descname">removeView</tt><big>(</big><em>view=None</em><big>)</big><a class="headerlink" href="#viewport.NewiMultiCanvas.removeView" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a view from the canvas</p>
<p>If view is None, the last one is removed.
You can not remove a view when there is only one left.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.NewiMultiCanvas.setCurrent">
<tt class="descname">setCurrent</tt><big>(</big><em>view</em><big>)</big><a class="headerlink" href="#viewport.NewiMultiCanvas.setCurrent" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the specified viewport the current one.</p>
<p>view can be either a viewport or viewport number.
The current viewport is the one that will be used for drawing
operations. This may be different from the viewport having GUI
focus (pf.canvas).</p>
</dd></dl>

<dl class="method">
<dt id="viewport.NewiMultiCanvas.setStretch">
<tt class="descname">setStretch</tt><big>(</big><em>rowstretch</em>, <em>colstretch</em><big>)</big><a class="headerlink" href="#viewport.NewiMultiCanvas.setStretch" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the row and column stretch factors.</p>
<p>rowstretch and colstretch are lists of stretch factors to be applied
on the subsequent rows/columns. If the lists are shorter than the
number of rows/columns, the</p>
</dd></dl>

<dl class="method">
<dt id="viewport.NewiMultiCanvas.link">
<tt class="descname">link</tt><big>(</big><em>vp</em>, <em>to</em><big>)</big><a class="headerlink" href="#viewport.NewiMultiCanvas.link" title="Permalink to this definition">¶</a></dt>
<dd><p>Link viewport vp to to</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="viewport.FramedGridLayout">
<em class="property">class </em><tt class="descclassname">viewport.</tt><tt class="descname">FramedGridLayout</tt><big>(</big><em>parent=None</em><big>)</big><a class="headerlink" href="#viewport.FramedGridLayout" title="Permalink to this definition">¶</a></dt>
<dd><p>A QtGui.QGridLayout where each added widget is framed.</p>
</dd></dl>

<dl class="class">
<dt id="viewport.MultiCanvas">
<em class="property">class </em><tt class="descclassname">viewport.</tt><tt class="descname">MultiCanvas</tt><big>(</big><em>parent=None</em><big>)</big><a class="headerlink" href="#viewport.MultiCanvas" title="Permalink to this definition">¶</a></dt>
<dd><p>An OpenGL canvas with multiple viewports and QT interaction.</p>
<p>The MultiCanvas implements a central QT widget containing one or more
QtCanvas widgets.</p>
<dl class="method">
<dt id="viewport.MultiCanvas.newView">
<tt class="descname">newView</tt><big>(</big><em>shared=None</em>, <em>settings=None</em><big>)</big><a class="headerlink" href="#viewport.MultiCanvas.newView" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new viewport</p>
<p>If another QtCanvas instance is passed, both will share the same
display lists and textures.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.MultiCanvas.addView">
<tt class="descname">addView</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.MultiCanvas.addView" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new viewport to the widget</p>
</dd></dl>

<dl class="method">
<dt id="viewport.MultiCanvas.setCurrent">
<tt class="descname">setCurrent</tt><big>(</big><em>canv</em><big>)</big><a class="headerlink" href="#viewport.MultiCanvas.setCurrent" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the specified viewport the current one.</p>
<p>canv can be either a viewport or viewport number.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.MultiCanvas.viewIndex">
<tt class="descname">viewIndex</tt><big>(</big><em>view</em><big>)</big><a class="headerlink" href="#viewport.MultiCanvas.viewIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the specified view</p>
</dd></dl>

<dl class="method">
<dt id="viewport.MultiCanvas.showWidget">
<tt class="descname">showWidget</tt><big>(</big><em>w</em><big>)</big><a class="headerlink" href="#viewport.MultiCanvas.showWidget" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the view w.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.MultiCanvas.changeLayout">
<tt class="descname">changeLayout</tt><big>(</big><em>nvps=None</em>, <em>ncols=None</em>, <em>nrows=None</em>, <em>pos=None</em>, <em>rstretch=None</em>, <em>cstretch=None</em><big>)</big><a class="headerlink" href="#viewport.MultiCanvas.changeLayout" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the lay-out of the viewports on the OpenGL widget.</p>
<p>nvps: number of viewports
ncols: number of columns
nrows: number of rows
pos: list holding the position and span of each viewport
[[row,col,rowspan,colspan],...]
rstretch: list holding the stretch factor for each row
cstretch: list holding the stretch factor for each column
(rows/columns with a higher stretch factor take more of the
available space)
Each of this parameters is optional.</p>
<p>If a number of viewports is given, viewports will be added
or removed to match the requested number.
By default they are laid out rowwise over two columns.</p>
<p>If ncols is an int, viewports are laid out rowwise over ncols
columns and nrows is ignored. If ncols is None and nrows is an int,
viewports are laid out columnwise over nrows rows. Alternatively,
the pos argument can be used to specify the layout of the viewports.</p>
</dd></dl>

<dl class="method">
<dt id="viewport.MultiCanvas.link">
<tt class="descname">link</tt><big>(</big><em>vp</em>, <em>to</em><big>)</big><a class="headerlink" href="#viewport.MultiCanvas.link" title="Permalink to this definition">¶</a></dt>
<dd><p>Link viewport vp to to</p>
</dd></dl>

</dd></dl>

<p><tt class="docutils literal"><span class="pre">Functions</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">module</span> <span class="pre">viewport</span></tt></p>
<dl class="function">
<dt id="viewport.dotpr">
<tt class="descclassname">viewport.</tt><tt class="descname">dotpr</tt><big>(</big><em>v</em>, <em>w</em><big>)</big><a class="headerlink" href="#viewport.dotpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dot product of vectors v and w</p>
</dd></dl>

<dl class="function">
<dt id="viewport.length">
<tt class="descclassname">viewport.</tt><tt class="descname">length</tt><big>(</big><em>v</em><big>)</big><a class="headerlink" href="#viewport.length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of the vector v</p>
</dd></dl>

<dl class="function">
<dt id="viewport.projection">
<tt class="descclassname">viewport.</tt><tt class="descname">projection</tt><big>(</big><em>v</em>, <em>w</em><big>)</big><a class="headerlink" href="#viewport.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the (signed) length of the projection of vector v on vector w.</p>
</dd></dl>

<dl class="function">
<dt id="viewport.setOpenGLFormat">
<tt class="descclassname">viewport.</tt><tt class="descname">setOpenGLFormat</tt><big>(</big><big>)</big><a class="headerlink" href="#viewport.setOpenGLFormat" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the correct OpenGL format.</p>
<p>On a correctly installed system, the default should do well.
The default OpenGL format can be changed by command line options:</p>
<div class="highlight-python"><pre>--dri   : use the Direct Rendering Infrastructure, if available
--nodri : do not use the DRI
--alpha : enable the alpha buffer </pre>
</div>
</dd></dl>

<dl class="function">
<dt id="viewport.OpenGLFormat">
<tt class="descclassname">viewport.</tt><tt class="descname">OpenGLFormat</tt><big>(</big><em>fmt=None</em><big>)</big><a class="headerlink" href="#viewport.OpenGLFormat" title="Permalink to this definition">¶</a></dt>
<dd><p>Some information about the OpenGL format.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="camera.html" title="27. camera — OpenGL camera handling"
             >next</a> |</li>
        <li class="right" >
          <a href="canvas.html" title="25. canvas — This implements an OpenGL drawing widget for painting 3D scenes."
             >previous</a> |</li>
        <li><a href="../index.html">pyFormex v0.8.8 documentation</a> &gt;</li>
          <li><a href="../refman.html" >pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
    <div class="footer">
    <span class="left">
        &copy; Copyright 2004-2012, Benedict Verhegghe.
    </span>
      Last updated on Nov 04, 2012.
    <span class="right">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.8.
    </span>
    </div>
  </body>
</html>
