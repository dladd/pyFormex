<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>31. surface — Operations on triangulated surfaces. &mdash; pyFormex v0.8.2 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.2',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="pyFormex v0.8.2 documentation" href="../index.html" />
    <link rel="up" title="pyFormex reference manual" href="../refman.html" />
    <link rel="next" title="32. geomtools — Basic geometrical operations." href="geomtools.html" />
    <link rel="prev" title="30. mesh — mesh.py" href="mesh.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="geomtools.html" title="32. geomtools — Basic geometrical operations."
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mesh.html" title="30. mesh — mesh.py"
             accesskey="P">previous</a> |</li>
    <li><a href="http://pyformex.org/">pyFormex Home</a> &gt;</li>
    
        <li><a href="../index.html">pyFormex Documentation</a> &gt;</li>

          <li><a href="../refman.html" accesskey="U">pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-surface">
<span id="sec-ref-surface"></span><h1>31. <tt class="xref docutils literal"><span class="pre">surface</span></tt> &#8212; Operations on triangulated surfaces.<a class="headerlink" href="#module-surface" title="Permalink to this headline">¶</a></h1>
<p>Operations on triangulated surfaces.</p>
<p>A triangulated surface is a surface consisting solely of triangles.
Any surface in space, no matter how complex, can be approximated with
a triangulated surface.</p>
<dl class="class">
<dt id="surface.TriSurface">
<em class="property">class </em><tt class="descclassname">surface.</tt><tt class="descname">TriSurface</tt><big>(</big><em>*args</em>, <em>**kargs</em><big>)</big><a class="headerlink" href="#surface.TriSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>A class representing a triangulated 3D surface.</p>
<p>The surface contains <cite>ntri</cite> triangles, each having 3 vertices with
3 coordinates. The surface can be initialized from one of the following:</p>
<ul class="simple">
<li>a (ntri,3,3) shaped array of floats</li>
<li>a Formex with plexitude 3</li>
<li>a Mesh with plexitude 3</li>
<li>an (ncoords,3) float array of vertex coordinates and
an (ntri,3) integer array of vertex numbers</li>
<li>an (ncoords,3) float array of vertex coordinates,
an (nedges,2) integer array of vertex numbers,
an (ntri,3) integer array of edges numbers.</li>
</ul>
<p>Additionally, a keyword argument prop= may be specified to
set property values.</p>
<p class="rubric">Methods</p>
<p>Create a new surface.</p>
<p class="rubric">Methods</p>
<p>TriSurface objects have the following methods:</p>
<dl class="method">
<dt id="surface.TriSurface.nedges">
<tt class="descname">nedges</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nedges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nfaces">
<tt class="descname">nfaces</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nfaces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.vertices">
<tt class="descname">vertices</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.vertices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.shape" title="Permalink to this definition">¶</a></dt>
<dd>Return the number of points, edges, faces of the TriSurface.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.getEdges">
<tt class="descname">getEdges</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.getEdges" title="Permalink to this definition">¶</a></dt>
<dd>Get the edges data.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.getFaces">
<tt class="descname">getFaces</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.getFaces" title="Permalink to this definition">¶</a></dt>
<dd>Get the faces data.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.setCoords">
<tt class="descname">setCoords</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#surface.TriSurface.setCoords" title="Permalink to this definition">¶</a></dt>
<dd>Change the coords.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.setElems">
<tt class="descname">setElems</tt><big>(</big><em>elems</em><big>)</big><a class="headerlink" href="#surface.TriSurface.setElems" title="Permalink to this definition">¶</a></dt>
<dd>Change the elems.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.setEdgesAndFaces">
<tt class="descname">setEdgesAndFaces</tt><big>(</big><em>edges</em>, <em>faces</em><big>)</big><a class="headerlink" href="#surface.TriSurface.setEdgesAndFaces" title="Permalink to this definition">¶</a></dt>
<dd>Change the edges and faces.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.refresh">
<tt class="descname">refresh</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.refresh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.append">
<tt class="descname">append</tt><big>(</big><em>S</em><big>)</big><a class="headerlink" href="#surface.TriSurface.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge another surface with self.</p>
<p>This just merges the data sets, and does not check
whether the surfaces intersect or are connected!
This is intended mostly for use inside higher level functions.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.copy" title="Permalink to this definition">¶</a></dt>
<dd>Return a (deep) copy of the surface.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.select">
<tt class="descname">select</tt><big>(</big><em>idx</em>, <em>compact=True</em><big>)</big><a class="headerlink" href="#surface.TriSurface.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a TriSurface which holds only elements with numbers in ids.</p>
<p>idx can be a single element number or a list of numbers or
any other index mechanism accepted by numpy&#8217;s ndarray
By default, the vertex list will be compressed to hold only those
used in the selected elements.
Setting compress==False will keep all original nodes in the surface.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.pointNormals">
<tt class="descname">pointNormals</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.pointNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the normal vectors at the points.</p>
<p>The normal vector in a point is the average of the normal vectors of
all the neighbouring triangles.
The normal vectors are normalized before they are returned.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.offset">
<tt class="descname">offset</tt><big>(</big><em>distance=1.</em><big>)</big><a class="headerlink" href="#surface.TriSurface.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset a surface with a certain distance.</p>
<p>All the nodes of the surface are translated over a specified distance
along their normal vector.</p>
</dd></dl>

<dl class="classmethod">
<dt id="surface.TriSurface.read">
<em class="property">classmethod </em><tt class="descname">read</tt><big>(</big><em>clas</em>, <em>fn</em>, <em>ftype=None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a surface from file.</p>
<p>If no file type is specified, it is derived from the filename
extension.
Currently supported file types:</p>
<ul class="simple">
<li>.stl (ASCII or BINARY)</li>
<li>.gts</li>
<li>.off</li>
<li>.neu (Gambit Neutral)</li>
<li>.smesh (Tetgen)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.write">
<tt class="descname">write</tt><big>(</big><em>fname</em>, <em>ftype=None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the surface to file.</p>
<p>If no filetype is given, it is deduced from the filename extension.
If the filename has no extension, the &#8216;gts&#8217; file type is used.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.reflect">
<tt class="descname">reflect</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.reflect" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflect the coordinates in direction dir against plane at pos.</p>
<p>Default position of the plane is through the origin.
Default mirror direction is the z-direction.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.avgVertexNormals">
<tt class="descname">avgVertexNormals</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.avgVertexNormals" title="Permalink to this definition">¶</a></dt>
<dd>Compute the average normals at the vertices.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.areaNormals">
<tt class="descname">areaNormals</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.areaNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the area and normal vectors of the surface triangles.</p>
<p>The normal vectors are normalized.
The area is always positive.</p>
<p>The values are returned and saved in the object.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.facetArea">
<tt class="descname">facetArea</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.facetArea" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.area">
<tt class="descname">area</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.area" title="Permalink to this definition">¶</a></dt>
<dd>Return the area of the surface</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.volume">
<tt class="descname">volume</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the enclosed volume of the surface.</p>
<p>This will only be correct if the surface is a closed manifold.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.curvature">
<tt class="descname">curvature</tt><big>(</big><em>neighbours=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the curvature parameters at the nodes.</p>
<p>This uses the nodes that are connected to the node via a shortest
path of &#8216;neighbours&#8217; edges.
Eight values are returned: the Gaussian and mean curvature, the
shape index, the curvedness, the principal curvatures and the
principal directions.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.inertia">
<tt class="descname">inertia</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return inertia related quantities of the surface.</p>
<p>This returns the center of gravity, the principal axes of inertia, the principal
moments of inertia and the inertia tensor.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.edgeConnections">
<tt class="descname">edgeConnections</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.edgeConnections" title="Permalink to this definition">¶</a></dt>
<dd>Find the elems connected to edges.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nodeConnections">
<tt class="descname">nodeConnections</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nodeConnections" title="Permalink to this definition">¶</a></dt>
<dd>Find the elems connected to nodes.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nEdgeConnected">
<tt class="descname">nEdgeConnected</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nEdgeConnected" title="Permalink to this definition">¶</a></dt>
<dd>Find the number of elems connected to edges.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nNodeConnected">
<tt class="descname">nNodeConnected</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nNodeConnected" title="Permalink to this definition">¶</a></dt>
<dd>Find the number of elems connected to nodes.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.edgeAdjacency">
<tt class="descname">edgeAdjacency</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.edgeAdjacency" title="Permalink to this definition">¶</a></dt>
<dd>Find the elems adjacent to elems via an edge.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nEdgeAdjacent">
<tt class="descname">nEdgeAdjacent</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nEdgeAdjacent" title="Permalink to this definition">¶</a></dt>
<dd>Find the number of adjacent elems.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nodeAdjacency">
<tt class="descname">nodeAdjacency</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nodeAdjacency" title="Permalink to this definition">¶</a></dt>
<dd>Find the elems adjacent to elems via one or two nodes.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nNodeAdjacent">
<tt class="descname">nNodeAdjacent</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nNodeAdjacent" title="Permalink to this definition">¶</a></dt>
<dd>Find the number of adjacent elems.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.surfaceType">
<tt class="descname">surfaceType</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.surfaceType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.borderEdges">
<tt class="descname">borderEdges</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.borderEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect the border elements of TriSurface.</p>
<p>The border elements are the edges having less than 2 connected elements.
Returns True where edge is on the border.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.borderEdgeNrs">
<tt class="descname">borderEdgeNrs</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.borderEdgeNrs" title="Permalink to this definition">¶</a></dt>
<dd>Returns the numbers of the border edges.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.borderNodeNrs">
<tt class="descname">borderNodeNrs</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.borderNodeNrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect the border nodes of TriSurface.</p>
<p>The border nodes are the vertices belonging to the border edges.
Returns a list of vertex numbers.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.isManifold">
<tt class="descname">isManifold</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.isManifold" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.isClosedManifold">
<tt class="descname">isClosedManifold</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.isClosedManifold" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.checkBorder">
<tt class="descname">checkBorder</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.checkBorder" title="Permalink to this definition">¶</a></dt>
<dd>Return the border of TriSurface as a set of segments.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.fillBorder">
<tt class="descname">fillBorder</tt><big>(</big><em>method=0</em><big>)</big><a class="headerlink" href="#surface.TriSurface.fillBorder" title="Permalink to this definition">¶</a></dt>
<dd><p>If the surface has a single closed border, fill it.</p>
<p>Filling the border is done by adding a single point inside
the border and connectin it with all border segments.
This works well if the border is smooth and nearly planar.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.border">
<tt class="descname">border</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.border" title="Permalink to this definition">¶</a></dt>
<dd>Return the border of TriSurface as a Plex-2 Formex.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.edgeCosAngles">
<tt class="descname">edgeCosAngles</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.edgeCosAngles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cos of the angles over all edges.</p>
<p>The surface should be a manifold (max. 2 elements per edge).
Edges with only one element get angles = 1.0.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.edgeAngles">
<tt class="descname">edgeAngles</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.edgeAngles" title="Permalink to this definition">¶</a></dt>
<dd>Return the angles over all edges (in degrees).</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.aspectRatio">
<tt class="descname">aspectRatio</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.aspectRatio" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.smallestAltitude">
<tt class="descname">smallestAltitude</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.smallestAltitude" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.longestEdge">
<tt class="descname">longestEdge</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.longestEdge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.shortestEdge">
<tt class="descname">shortestEdge</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.shortestEdge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.stats">
<tt class="descname">stats</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.stats" title="Permalink to this definition">¶</a></dt>
<dd>Return a text with full statistics.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.distanceOfPoints">
<tt class="descname">distanceOfPoints</tt><big>(</big><em>X</em>, <em>return_points=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.distanceOfPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the distances of points X to the TriSurface.</p>
<p>The distance of a point is either:
- the closest perpendicular distance to the facets;
- the closest perpendicular distance to the edges;
- the closest distance to the vertices.</p>
<p>X is a (nX,3) shaped array of points.
If return_points = True, a second value is returned: an array with
the closest (foot)points matching X.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.edgeFront">
<tt class="descname">edgeFront</tt><big>(</big><em>startat=0</em>, <em>okedges=None</em>, <em>front_increment=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.edgeFront" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator function returning the frontal elements.</p>
<p>startat is an element number or list of numbers of the starting front.
On first call, this function returns the starting front.
Each next() call returns the next front.
front_increment determines how the property increases at each
frontal step. There is an extra increment +1 at each start of
a new part. Thus, the start of a new part can always be detected
by a front not having the property of the previous plus front_increment.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nodeFront">
<tt class="descname">nodeFront</tt><big>(</big><em>startat=0</em>, <em>front_increment=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.nodeFront" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator function returning the frontal elements.</p>
<p>startat is an element number or list of numbers of the starting front.
On first call, this function returns the starting front.
Each next() call returns the next front.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.walkEdgeFront">
<tt class="descname">walkEdgeFront</tt><big>(</big><em>startat=0</em>, <em>nsteps=1</em>, <em>okedges=None</em>, <em>front_increment=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.walkEdgeFront" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.walkNodeFront">
<tt class="descname">walkNodeFront</tt><big>(</big><em>startat=0</em>, <em>nsteps=1</em>, <em>front_increment=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.walkNodeFront" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.growSelection">
<tt class="descname">growSelection</tt><big>(</big><em>sel</em>, <em>mode='node'</em>, <em>nsteps=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.growSelection" title="Permalink to this definition">¶</a></dt>
<dd><p>Grows a selection of a surface.</p>
<p><cite>p</cite> is a single element number or a list of numbers.
The return value is a list of element numbers obtained by
growing the front <cite>nsteps</cite> times.
The <cite>mode</cite> argument specifies how a single frontal step is done:</p>
<ul class="simple">
<li>&#8216;node&#8217; : include all elements that have a node in common,</li>
<li>&#8216;edge&#8217; : include all elements that have an edge in common.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.partitionByEdgeFront">
<tt class="descname">partitionByEdgeFront</tt><big>(</big><em>okedges</em>, <em>firstprop=0</em>, <em>startat=0</em><big>)</big><a class="headerlink" href="#surface.TriSurface.partitionByEdgeFront" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects different parts of the surface using a frontal method.</p>
<p>okedges flags the edges where the two adjacent triangles are to be
in the same part of the surface.
startat is a list of elements that are in the first part. 
The partitioning is returned as a property type array having a value
corresponding to the part number. The lowest property number will be
firstprop</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.partitionByNodeFront">
<tt class="descname">partitionByNodeFront</tt><big>(</big><em>firstprop=0</em>, <em>startat=0</em><big>)</big><a class="headerlink" href="#surface.TriSurface.partitionByNodeFront" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects different parts of the surface using a frontal method.</p>
<p>okedges flags the edges where the two adjacent triangles are to be
in the same part of the surface.
startat is a list of elements that are in the first part. 
The partitioning is returned as a property type array having a value
corresponding to the part number. The lowest property number will be
firstprop</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.partitionByConnection">
<tt class="descname">partitionByConnection</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.partitionByConnection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.partitionByAngle">
<tt class="descname">partitionByAngle</tt><big>(</big><em>angle=180.</em>, <em>firstprop=0</em>, <em>startat=0</em><big>)</big><a class="headerlink" href="#surface.TriSurface.partitionByAngle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.cutWithPlane">
<tt class="descname">cutWithPlane</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.cutWithPlane" title="Permalink to this definition">¶</a></dt>
<dd>Cut a surface with a plane.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.connectedElements">
<tt class="descname">connectedElements</tt><big>(</big><em>target</em>, <em>elemlist=None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.connectedElements" title="Permalink to this definition">¶</a></dt>
<dd>Return the elements from list connected with target</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.intersectionWithPlane">
<tt class="descname">intersectionWithPlane</tt><big>(</big><em>p</em>, <em>n</em>, <em>atol=0.</em>, <em>ignoreErrors=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.intersectionWithPlane" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection lines with plane (p,n).</p>
<p>Returns a plex-2 mesh with the line segments obtained by cutting
all triangles of the surface with the plane (p,n)
p is a point specified by 3 coordinates.
n is the normal vector to a plane, specified by 3 components.
atol is a tolerance factor defining whether an edge is intersected
by the plane.</p>
<p>The return value is a plex-2 Mesh where the line segments defining
the intersection are sorted to form continuous lines. The Mesh has
property numbers such that all segments forming a single continuous
part have the same property value.
The splitProp() method can be used to get a list of Meshes.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.slice">
<tt class="descname">slice</tt><big>(</big><em>dir=0</em>, <em>nplanes=20</em>, <em>ignoreErrors=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Intersect a surface with a sequence of planes.</p>
<p>A sequence of nplanes planes with normal dir is constructed
at equal distances spread over the bbox of the surface.</p>
<p>The return value is a list of intersectionWithPlanes() return
values, i.e. a list of list of meshes.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.smoothLowPass">
<tt class="descname">smoothLowPass</tt><big>(</big><em>n_iterations=2</em>, <em>lambda_value=0.5</em>, <em>neighbours=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.smoothLowPass" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth the surface using a low-pass filter.</p>
<p>This uses the nodes that are connected to the node via a shortest
path of minimum 1 and maximum &#8216;neighbours&#8217; edges.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.smoothLaplaceHC">
<tt class="descname">smoothLaplaceHC</tt><big>(</big><em>n_iterations=2</em>, <em>lambda_value=0.5</em>, <em>alpha=0.</em>, <em>beta=0.2</em>, <em>neighbours=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.smoothLaplaceHC" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth the surface using a Laplace filter and HC algorithm.</p>
<p>This uses the nodes that are connected to the node via a shortest
path of minimum 1 and maximum &#8216;neighbours&#8217; edges.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.check">
<tt class="descname">check</tt><big>(</big><em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.check" title="Permalink to this definition">¶</a></dt>
<dd>Check the surface using gtscheck.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.split">
<tt class="descname">split</tt><big>(</big><em>base</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.split" title="Permalink to this definition">¶</a></dt>
<dd>Check the surface using gtscheck.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.coarsen">
<tt class="descname">coarsen</tt><big>(</big><em>min_edges=None</em>, <em>max_cost=None</em>, <em>mid_vertex=False</em>, <em>length_cost=False</em>, <em>max_fold=1.0</em>, <em>volume_weight=0.5</em>, <em>boundary_weight=0.5</em>, <em>shape_weight=0.0</em>, <em>progressive=False</em>, <em>log=False</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.coarsen" title="Permalink to this definition">¶</a></dt>
<dd>Coarsen the surface using gtscoarsen.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.refine">
<tt class="descname">refine</tt><big>(</big><em>max_edges=None</em>, <em>min_cost=None</em>, <em>log=False</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.refine" title="Permalink to this definition">¶</a></dt>
<dd>Refine the surface using gtsrefine.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.smooth">
<tt class="descname">smooth</tt><big>(</big><em>lambda_value=0.5</em>, <em>n_iterations=2</em>, <em>fold_smoothing=None</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.smooth" title="Permalink to this definition">¶</a></dt>
<dd>Smooth the surface using gtssmooth.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.boolean">
<tt class="descname">boolean</tt><big>(</big><em>surf</em>, <em>op</em>, <em>inter=False</em>, <em>check=False</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.boolean" title="Permalink to this definition">¶</a></dt>
<dd>Perform a boolean operation with surface surf.</dd></dl>

</dd></dl>

<p><strong>Functions defined in the module surface</strong></p>
<blockquote>
<dl class="function">
<dt id="surface.areaNormals">
<tt class="descclassname">surface.</tt><tt class="descname">areaNormals</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#surface.areaNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the area and normal vectors of a collection of triangles.</p>
<p>x is an (ntri,3,3) array of coordinates.</p>
<p>Returns a tuple of areas,normals.
The normal vectors are normalized.
The area is always positive.</p>
</dd></dl>

<dl class="function">
<dt id="surface.stlConvert">
<tt class="descclassname">surface.</tt><tt class="descname">stlConvert</tt><big>(</big><em>stlname</em>, <em>outname=None</em>, <em>options='-d'</em><big>)</big><a class="headerlink" href="#surface.stlConvert" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an .stl file to .off or .gts format.</p>
<p>If outname is given, it is either &#8216;.off&#8217; or &#8216;.gts&#8217; or a filename ending
on one of these extensions. If it is only an extension, the stlname will
be used with extension changed.</p>
<p>If the outname file exists and its mtime is more recent than the stlname,
the outname file is considered uptodate and the conversion programwill
not be run.</p>
<p>The conversion program will be choosen depending on the extension.
This uses the external commands &#8216;admesh&#8217; or &#8216;stl2gts&#8217;.</p>
<p>The return value is a tuple of the output file name, the conversion
program exit code (0 if succesful) and the stdout of the conversion
program (or a &#8216;file is already uptodate&#8217; message).</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_gts">
<tt class="descclassname">surface.</tt><tt class="descname">read_gts</tt><big>(</big><em>fn</em><big>)</big><a class="headerlink" href="#surface.read_gts" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a GTS surface mesh.</p>
<p>Return a coords,edges,faces tuple.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_off">
<tt class="descclassname">surface.</tt><tt class="descname">read_off</tt><big>(</big><em>fn</em><big>)</big><a class="headerlink" href="#surface.read_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an OFF surface mesh.</p>
<p>The mesh should consist of only triangles!
Returns a nodes,elems tuple.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_stl">
<tt class="descclassname">surface.</tt><tt class="descname">read_stl</tt><big>(</big><em>fn</em>, <em>intermediate=None</em><big>)</big><a class="headerlink" href="#surface.read_stl" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a surface from .stl file.</p>
<p>This is done by first coverting the .stl to .gts or .off format.
The name of the intermediate file may be specified. If not, it will be
generated by changing the extension of fn to &#8216;.gts&#8217; or &#8216;.off&#8217; depending
on the setting of the &#8216;surface/stlread&#8217; config setting.</p>
<p>Return a coords,edges,faces or a coords,elems tuple, depending on the
intermediate format.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_gambit_neutral">
<tt class="descclassname">surface.</tt><tt class="descname">read_gambit_neutral</tt><big>(</big><em>fn</em><big>)</big><a class="headerlink" href="#surface.read_gambit_neutral" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a triangular surface mesh in Gambit neutral format.</p>
<p>The .neu file nodes are numbered from 1!
Returns a nodes,elems tuple.</p>
</dd></dl>

<dl class="function">
<dt id="surface.write_gts">
<tt class="descclassname">surface.</tt><tt class="descname">write_gts</tt><big>(</big><em>fn</em>, <em>nodes</em>, <em>edges</em>, <em>faces</em><big>)</big><a class="headerlink" href="#surface.write_gts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="surface.write_stla">
<tt class="descclassname">surface.</tt><tt class="descname">write_stla</tt><big>(</big><em>f</em>, <em>x</em><big>)</big><a class="headerlink" href="#surface.write_stla" title="Permalink to this definition">¶</a></dt>
<dd>Export an x[n,3,3] float array as an ascii .stl file.</dd></dl>

<dl class="function">
<dt id="surface.write_stlb">
<tt class="descclassname">surface.</tt><tt class="descname">write_stlb</tt><big>(</big><em>f</em>, <em>x</em><big>)</big><a class="headerlink" href="#surface.write_stlb" title="Permalink to this definition">¶</a></dt>
<dd>Export an x[n,3,3] float array as an binary .stl file.</dd></dl>

<dl class="function">
<dt id="surface.write_gambit_neutral">
<tt class="descclassname">surface.</tt><tt class="descname">write_gambit_neutral</tt><big>(</big><em>fn</em>, <em>nodes</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.write_gambit_neutral" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="surface.write_off">
<tt class="descclassname">surface.</tt><tt class="descname">write_off</tt><big>(</big><em>fn</em>, <em>nodes</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.write_off" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="surface.write_smesh">
<tt class="descclassname">surface.</tt><tt class="descname">write_smesh</tt><big>(</big><em>fn</em>, <em>nodes</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.write_smesh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="surface.surface_volume">
<tt class="descclassname">surface.</tt><tt class="descname">surface_volume</tt><big>(</big><em>x</em>, <em>pt=None</em><big>)</big><a class="headerlink" href="#surface.surface_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the volume inside a 3-plex Formex.</p>
<ul class="simple">
<li><cite>x</cite>: an (ntri,3,3) shaped float array, representing ntri triangles.</li>
<li><cite>pt</cite>: a point in space. If unspecified, it is taken equal to the
center() of the coordinates <cite>x</cite>.</li>
</ul>
<p>Returns an (ntri) shaped array with the volume of the tetraeders formed
by the triangles and the point <cite>pt</cite>. If <cite>x</cite> represents a closed surface,
the sum of this array will represent the volume inside the surface.</p>
</dd></dl>

<dl class="function">
<dt id="surface.curvature">
<tt class="descclassname">surface.</tt><tt class="descname">curvature</tt><big>(</big><em>coords</em>, <em>elems</em>, <em>edges</em>, <em>neighbours=1</em><big>)</big><a class="headerlink" href="#surface.curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate curvature parameters at the nodes</p>
<p>(according to Dong and Wang 2005;
Koenderink and Van Doorn 1992).
This uses the nodes that are connected to the node via a shortest
path of &#8216;neighbours&#8217; edges.
Eight values are returned: the Gaussian and mean curvature, the
shape index, the curvedness, the principal curvatures and the
principal directions.</p>
</dd></dl>

<dl class="function">
<dt id="surface.surfaceInsideLoop">
<tt class="descclassname">surface.</tt><tt class="descname">surfaceInsideLoop</tt><big>(</big><em>coords</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.surfaceInsideLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a surface inside a closed curve defined by coords and elems.</p>
<p>coords is a set of coordinates.
elems is an (nsegments,2) shaped connectivity array defining a set of line
segments forming a closed loop.</p>
<p>The return value is coords,elems tuple where
coords has one more point: the center of th original coords
elems is (nsegment,3) and defines triangles describing a surface inside
the original curve.</p>
</dd></dl>

<dl class="function">
<dt id="surface.fillHole">
<tt class="descclassname">surface.</tt><tt class="descname">fillHole</tt><big>(</big><em>coords</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.fillHole" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a hole surrounded by the border defined by coords and elems.</p>
<p>Coords is a (npoints,3) shaped array of floats.
Elems is a (nelems,2) shaped array of integers representing the border
element numbers and must be ordered.</p>
</dd></dl>

<dl class="function">
<dt id="surface.create_border_triangle">
<tt class="descclassname">surface.</tt><tt class="descname">create_border_triangle</tt><big>(</big><em>coords</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.create_border_triangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a triangle within a border.</p>
<p>The triangle is created from the two border elements with
the sharpest angle.
Coords is a (npoints,3) shaped array of floats.
Elems is a (nelems,2) shaped array of integers representing
the border element numbers and must be ordered.
A list of two objects is returned: the new border elements and the triangle.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_error">
<tt class="descclassname">surface.</tt><tt class="descname">read_error</tt><big>(</big><em>cnt</em>, <em>line</em><big>)</big><a class="headerlink" href="#surface.read_error" title="Permalink to this definition">¶</a></dt>
<dd>Raise an error on reading the stl file.</dd></dl>

<dl class="function">
<dt id="surface.degenerate">
<tt class="descclassname">surface.</tt><tt class="descname">degenerate</tt><big>(</big><em>area</em>, <em>norm</em><big>)</big><a class="headerlink" href="#surface.degenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the degenerate faces according to area and normals.</p>
<p>A face is degenerate if its surface is less or equal to zero or the
normal has a nan.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_stla">
<tt class="descclassname">surface.</tt><tt class="descname">read_stla</tt><big>(</big><em>fn</em>, <em>dtype=Float</em>, <em>large=False</em>, <em>guess=True</em><big>)</big><a class="headerlink" href="#surface.read_stla" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an ascii .stl file into an [n,3,3] float array.</p>
<p>If the .stl is large, read_ascii_large() is recommended, as it is
a lot faster.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_ascii_large">
<tt class="descclassname">surface.</tt><tt class="descname">read_ascii_large</tt><big>(</big><em>fn</em>, <em>dtype=Float</em><big>)</big><a class="headerlink" href="#surface.read_ascii_large" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an ascii .stl file into an [n,3,3] float array.</p>
<p>This is an alternative for read_ascii, which is a lot faster on large
STL models.
It requires the &#8216;awk&#8217; command though, so is probably only useful on
Linux/UNIX. It works by first transforming  the input file to a
.nodes file and then reading it through numpy&#8217;s fromfile() function.</p>
</dd></dl>

<dl class="function">
<dt id="surface.off_to_tet">
<tt class="descclassname">surface.</tt><tt class="descname">off_to_tet</tt><big>(</big><em>fn</em><big>)</big><a class="headerlink" href="#surface.off_to_tet" title="Permalink to this definition">¶</a></dt>
<dd>Transform an .off model to tetgen (.node/.smesh) format.</dd></dl>

<dl class="function">
<dt id="surface.find_row">
<tt class="descclassname">surface.</tt><tt class="descname">find_row</tt><big>(</big><em>mat</em>, <em>row</em>, <em>nmatch=None</em><big>)</big><a class="headerlink" href="#surface.find_row" title="Permalink to this definition">¶</a></dt>
<dd>Find all rows in matrix matching given row.</dd></dl>

<dl class="function">
<dt id="surface.find_nodes">
<tt class="descclassname">surface.</tt><tt class="descname">find_nodes</tt><big>(</big><em>nodes</em>, <em>coords</em><big>)</big><a class="headerlink" href="#surface.find_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Find nodes with given coordinates in a node set.</p>
<p>nodes is a (nnodes,3) float array of coordinates.
coords is a (npts,3) float array of coordinates.</p>
<p>Returns a (n,) integer array with ALL the node numbers matching EXACTLY
ALL the coordinates of ANY of the given points.</p>
</dd></dl>

<dl class="function">
<dt id="surface.find_first_nodes">
<tt class="descclassname">surface.</tt><tt class="descname">find_first_nodes</tt><big>(</big><em>nodes</em>, <em>coords</em><big>)</big><a class="headerlink" href="#surface.find_first_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Find nodes with given coordinates in a node set.</p>
<p>nodes is a (nnodes,3) float array of coordinates.
coords is a (npts,3) float array of coordinates.</p>
<p>Returns a (n,) integer array with THE FIRST node number matching EXACTLY
ALL the coordinates of EACH of the given points.</p>
</dd></dl>

<dl class="function">
<dt id="surface.find_triangles">
<tt class="descclassname">surface.</tt><tt class="descname">find_triangles</tt><big>(</big><em>elems</em>, <em>triangles</em><big>)</big><a class="headerlink" href="#surface.find_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Find triangles with given node numbers in a surface mesh.</p>
<p>elems is a (nelems,3) integer array of triangles.
triangles is a (ntri,3) integer array of triangles to find.</p>
<p>Returns a (ntri,) integer array with the triangles numbers.</p>
</dd></dl>

<dl class="function">
<dt id="surface.remove_triangles">
<tt class="descclassname">surface.</tt><tt class="descname">remove_triangles</tt><big>(</big><em>elems</em>, <em>remove</em><big>)</big><a class="headerlink" href="#surface.remove_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove triangles from a surface mesh.</p>
<p>elems is a (nelems,3) integer array of triangles.
remove is a (nremove,3) integer array of triangles to remove.</p>
<p>Returns a (nelems-nremove,3) integer array with the triangles of
nelems where the triangles of remove have been removed.</p>
</dd></dl>

<dl class="function">
<dt id="surface.Rectangle">
<tt class="descclassname">surface.</tt><tt class="descname">Rectangle</tt><big>(</big><em>nx</em>, <em>ny</em><big>)</big><a class="headerlink" href="#surface.Rectangle" title="Permalink to this definition">¶</a></dt>
<dd>Create a plane rectangular surface consisting of a nx,ny grid.</dd></dl>

<dl class="function">
<dt id="surface.Cube">
<tt class="descclassname">surface.</tt><tt class="descname">Cube</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.Cube" title="Permalink to this definition">¶</a></dt>
<dd>Create a surface in the form of a cube</dd></dl>

<dl class="function">
<dt id="surface.Sphere">
<tt class="descclassname">surface.</tt><tt class="descname">Sphere</tt><big>(</big><em>level=4</em>, <em>verbose=False</em>, <em>filename=None</em><big>)</big><a class="headerlink" href="#surface.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a spherical surface by caling the gtssphere command.</p>
<p>If a filename is given, it is stored under that name, else a temporary
file is created.
Beware: this may take a lot of time if level is 8 or higher.</p>
</dd></dl>

<dl class="function">
<dt id="surface.checkDistanceLinesPointsTreshold">
<tt class="descclassname">surface.</tt><tt class="descname">checkDistanceLinesPointsTreshold</tt><big>(</big><em>p</em>, <em>q</em>, <em>m</em>, <em>dtresh</em><big>)</big><a class="headerlink" href="#surface.checkDistanceLinesPointsTreshold" title="Permalink to this definition">¶</a></dt>
<dd>p are np points, q m are nl lines, dtresh are np distances. It returns the indices of lines, points which are in a distance &lt; dtresh. The distance point-line is calculated using Pitagora as it seems the fastest way.</dd></dl>

<dl class="function">
<dt id="surface.intersectLineWithPlaneOne2One">
<tt class="descclassname">surface.</tt><tt class="descname">intersectLineWithPlaneOne2One</tt><big>(</big><em>q</em>, <em>m</em>, <em>p</em>, <em>n</em><big>)</big><a class="headerlink" href="#surface.intersectLineWithPlaneOne2One" title="Permalink to this definition">¶</a></dt>
<dd>it returns for each pair of line(q,m) and plane (p,n) the point of intersection. plane: (x-p)n=0, line: x=q+t m. It find the scalar t and returns the point.</dd></dl>

<dl class="function">
<dt id="surface.checkPointInsideTriangleOne2One">
<tt class="descclassname">surface.</tt><tt class="descname">checkPointInsideTriangleOne2One</tt><big>(</big><em>tpi</em>, <em>pi</em>, <em>atol=1.e-5</em><big>)</big><a class="headerlink" href="#surface.checkPointInsideTriangleOne2One" title="Permalink to this definition">¶</a></dt>
<dd>return a 1D boolean with the same dimension of tpi and pi. The value [i] is True if the point pi[i] is inside the triangle tpi[i]. It uses areas to check it.</dd></dl>

<dl class="function">
<dt id="surface.intersectSurfaceWithLines">
<tt class="descclassname">surface.</tt><tt class="descname">intersectSurfaceWithLines</tt><big>(</big><em>ts</em>, <em>qli</em>, <em>mli</em><big>)</big><a class="headerlink" href="#surface.intersectSurfaceWithLines" title="Permalink to this definition">¶</a></dt>
<dd>it takes a TriSurface ts and a set of lines ql,ml and intersect the lines with the TriSurface.
It returns the points of intersection and the indices of the intersected line and triangle.
TODO: the slowest part is computing the distances of lines from triangles, can it be faster?</dd></dl>

<dl class="function">
<dt id="surface.intersectSurfaceWithSegments">
<tt class="descclassname">surface.</tt><tt class="descname">intersectSurfaceWithSegments</tt><big>(</big><em>s1</em>, <em>segm</em>, <em>atol=1.e-5</em><big>)</big><a class="headerlink" href="#surface.intersectSurfaceWithSegments" title="Permalink to this definition">¶</a></dt>
<dd>it takes a TriSurface ts and a set of segments (-1,2,3) and intersect the segments with the TriSurface.
It returns the points of intersections and, for each point, the indices of the intersected segment and triangle</dd></dl>

</blockquote>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
        <p class="logo"><a href="http://pyformex.org/">
        <img class="logo" src="../_static/pyformex_logo_small.png" alt="Logo"/>
        </a></p>
    <h3><a href="../index.html">Documentation</a></h3>
            <h4>Previous topic</h4>
            <p class="topless"><a href="mesh.html"
                                  title="previous chapter">30. <tt class="docutils literal docutils literal docutils literal"><span class="pre">mesh</span></tt> &#8212; mesh.py</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="geomtools.html"
                                  title="next chapter">32. <tt class="docutils literal docutils literal docutils literal"><span class="pre">geomtools</span></tt> &#8212; Basic geometrical operations.</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/ref/surface.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="geomtools.html" title="32. geomtools — Basic geometrical operations."
             >next</a> |</li>
        <li class="right" >
          <a href="mesh.html" title="30. mesh — mesh.py"
             >previous</a> |</li>
    <li><a href="http://pyformex.org/">pyFormex Home</a> &gt;</li>
    
        <li><a href="../index.html">pyFormex Documentation</a> &gt;</li>

          <li><a href="../refman.html" >pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, Benedict Verhegghe.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.3.
    </div>
  </body>
</html>