<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>29. surface — Operations on triangulated surfaces. &mdash; pyFormex v0.8.2-a1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.2-a1',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="pyFormex v0.8.2-a1 documentation" href="../index.html" />
    <link rel="up" title="pyFormex reference manual" href="../refman.html" />
    <link rel="next" title="30. isopar — Isoparametric transformations" href="isopar.html" />
    <link rel="prev" title="28. curve — Definition of curves in pyFormex." href="curve.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="isopar.html" title="30. isopar — Isoparametric transformations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="curve.html" title="28. curve — Definition of curves in pyFormex."
             accesskey="P">previous</a> |</li>
    <li><a href="http://pyformex.org/">pyFormex Home</a> &gt;</li>
    
        <li><a href="../index.html">pyFormex Documentation</a> &gt;</li>

          <li><a href="../refman.html" accesskey="U">pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-surface">
<span id="sec-ref-surface"></span><h1>29. <tt class="xref docutils literal"><span class="pre">surface</span></tt> &#8212; Operations on triangulated surfaces.<a class="headerlink" href="#module-surface" title="Permalink to this headline">¶</a></h1>
<p>Operations on triangulated surfaces.</p>
<p>A triangulated surface is a surface consisting solely of triangles.
Any surface in space, no matter how complex, can be approximated with
a triangulated surface.</p>
<dl class="class">
<dt id="surface.TriSurface">
<em class="property">class </em><tt class="descclassname">surface.</tt><tt class="descname">TriSurface</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#surface.TriSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for handling triangulated 3D surfaces.</p>
<p>Create a new surface.</p>
<p>The surface contains ntri triangles, each having 3 vertices with
3 coordinates.
The surface can be initialized from one of the following:</p>
<ul class="simple">
<li>a (ntri,3,3) shaped array of floats ;</li>
<li>a 3-plex Formex with ntri elements ;</li>
<li>an (ncoords,3) float array of vertex coordinates and
an (ntri,3) integer array of vertex numbers ;</li>
<li>an (ncoords,3) float array of vertex coordinates,
an (nedges,2) integer array of vertex numbers,
an (ntri,3) integer array of edges numbers.</li>
</ul>
<p>Internally, the surface is stored in a (coords,edges,faces) tuple.</p>
<p>TriSurface objects have the following methods:</p>
<dl class="method">
<dt id="surface.TriSurface.getElems">
<tt class="descname">getElems</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.getElems" title="Permalink to this definition">¶</a></dt>
<dd>Get the elems data.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.setElems">
<tt class="descname">setElems</tt><big>(</big><em>elems</em><big>)</big><a class="headerlink" href="#surface.TriSurface.setElems" title="Permalink to this definition">¶</a></dt>
<dd>Change the elems data.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.refresh">
<tt class="descname">refresh</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.refresh" title="Permalink to this definition">¶</a></dt>
<dd><p>Make the internal information consistent and complete.</p>
<p>This function should be called after one of the data fields
have been changed.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.compress">
<tt class="descname">compress</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.compress" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all nodes which are not used.</p>
<p>Normally, the surface definition can hold nodes that are not
used in the edge/facet tables. They do however influence the
bounding box of the surface.
This method will remove all the unconnected nodes.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.append">
<tt class="descname">append</tt><big>(</big><em>S</em><big>)</big><a class="headerlink" href="#surface.TriSurface.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge another surface with self.</p>
<p>This just merges the data sets, and does not check
whether the surfaces intersect or are connected!
This is intended mostly for use inside higher level functions.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.ncoords">
<tt class="descname">ncoords</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.ncoords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nedges">
<tt class="descname">nedges</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nedges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nfaces">
<tt class="descname">nfaces</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nfaces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nplex">
<tt class="descname">nplex</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nplex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.ndim">
<tt class="descname">ndim</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.ndim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.vertices">
<tt class="descname">vertices</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.vertices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.shape">
<tt class="descname">shape</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.shape" title="Permalink to this definition">¶</a></dt>
<dd>Return the number of ;points, edges, faces of the TriSurface.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a (deep) copy of the surface.</p>
<p>If an index is given, only the specified faces are retained.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.select">
<tt class="descname">select</tt><big>(</big><em>idx</em>, <em>compress=True</em><big>)</big><a class="headerlink" href="#surface.TriSurface.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a TriSurface which holds only elements with numbers in ids.</p>
<p>idx can be a single element number or a list of numbers or
any other index mechanism accepted by numpy&#8217;s ndarray
By default, the vertex list will be compressed to hold only those
used in the selected elements.
Setting compress==False will keep all original nodes in the surface.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.setProp">
<tt class="descname">setProp</tt><big>(</big><em>p=None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.setProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Create or delete the property array for the TriSurface.</p>
<p>A property array is a rank-1 integer array with dimension equal
to the number of elements in the TriSurface.
You can specify a single value or a list/array of integer values.
If the number of passed values is less than the number of elements,
they wil be repeated. If you give more, they will be ignored.</p>
<p>If a value None is given, the properties are removed from the TriSurface.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.prop">
<tt class="descname">prop</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.prop" title="Permalink to this definition">¶</a></dt>
<dd>Return the properties as a numpy array (ndarray)</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.maxprop">
<tt class="descname">maxprop</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.maxprop" title="Permalink to this definition">¶</a></dt>
<dd>Return the highest property value used, or None</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.propSet">
<tt class="descname">propSet</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.propSet" title="Permalink to this definition">¶</a></dt>
<dd>Return a list with unique property values.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.x">
<tt class="descname">x</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.y">
<tt class="descname">y</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.z">
<tt class="descname">z</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.z" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.bbox">
<tt class="descname">bbox</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.bbox" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.center">
<tt class="descname">center</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.center" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.centroid">
<tt class="descname">centroid</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.centroid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.sizes">
<tt class="descname">sizes</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.sizes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.dsize">
<tt class="descname">dsize</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.dsize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.bsphere">
<tt class="descname">bsphere</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.bsphere" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.centroids">
<tt class="descname">centroids</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.centroids" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the centroids of all elements of the Formex.</p>
<p>The centroid of an element is the point whose coordinates
are the mean values of all points of the element.
The return value is an (nfaces,3) shaped Coords array.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.distanceFromPlane">
<tt class="descname">distanceFromPlane</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.distanceFromPlane" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.distanceFromLine">
<tt class="descname">distanceFromLine</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.distanceFromLine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.distanceFromPoint">
<tt class="descname">distanceFromPoint</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.distanceFromPoint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.test">
<tt class="descname">test</tt><big>(</big><em>nodes='all'</em>, <em>dir=0</em>, <em>min=None</em>, <em>max=None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag elements having nodal coordinates between min and max.</p>
<p>This function is very convenient in clipping a TriSurface in a specified
direction. It returns a 1D integer array flagging (with a value 1 or
True) the elements having nodal coordinates in the required range.
Use where(result) to get a list of element numbers passing the test.
Or directly use clip() or cclip() to create the clipped TriSurface</p>
<p>The test plane can be defined in two ways, depending on the value of dir.
If dir == 0, 1 or 2, it specifies a global axis and min and max are
the minimum and maximum values for the coordinates along that axis.
Default is the 0 (or x) direction.</p>
<p>Else, dir should be compaitble with a (3,) shaped array and specifies
the direction of the normal on the planes. In this case, min and max
are points and should also evaluate to (3,) shaped arrays.</p>
<p>nodes specifies which nodes are taken into account in the comparisons.
It should be one of the following:</p>
<ul class="simple">
<li>a single (integer) point number (&lt; the number of points in the Formex)</li>
<li>a list of point numbers</li>
<li>one of the special strings: &#8216;all&#8217;, &#8216;any&#8217;, &#8216;none&#8217;</li>
</ul>
<p>The default (&#8216;all&#8217;) will flag all the elements that have all their
nodes between the planes x=min and x=max, i.e. the elements that
fall completely between these planes. One of the two clipping planes
may be left unspecified.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.clip">
<tt class="descname">clip</tt><big>(</big><em>t</em><big>)</big><a class="headerlink" href="#surface.TriSurface.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a TriSurface with all the elements where t&gt;0.</p>
<p>t should be a 1-D integer array with length equal to the number
of elements of the TriSurface.
The resulting TriSurface will contain all elements where t &gt; 0.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.cclip">
<tt class="descname">cclip</tt><big>(</big><em>t</em><big>)</big><a class="headerlink" href="#surface.TriSurface.cclip" title="Permalink to this definition">¶</a></dt>
<dd>This is the complement of clip, returning a TriSurface where t&lt;=0.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.pointNormals">
<tt class="descname">pointNormals</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.pointNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the normal vectors in each point of a collection of triangles.</p>
<p>The normal vector in a point is the average of the normal vectors of
the neighbouring triangles.
The normal vectors are normalized.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.offset">
<tt class="descname">offset</tt><big>(</big><em>distance=1.</em><big>)</big><a class="headerlink" href="#surface.TriSurface.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset a surface with a certain distance.</p>
<p>All the nodes of the surface are translated over a specified distance
along their normal vector.
This creates a new congruent surface.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.toMesh">
<tt class="descname">toMesh</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.toMesh" title="Permalink to this definition">¶</a></dt>
<dd>Return a tuple of nodal coordinates and element connectivity.</dd></dl>

<dl class="classmethod">
<dt id="surface.TriSurface.read">
<em class="property">classmethod </em><tt class="descname">read</tt><big>(</big><em>clas</em>, <em>fn</em>, <em>ftype=None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a surface from file.</p>
<p>If no file type is specified, it is derived from the filename
extension.
Currently supported file types:</p>
<ul class="simple">
<li>.stl (ASCII or BINARY)</li>
<li>.gts</li>
<li>.off</li>
<li>.neu (Gambit Neutral)</li>
<li>.smesh (Tetgen)</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.write">
<tt class="descname">write</tt><big>(</big><em>fname</em>, <em>ftype=None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the surface to file.</p>
<p>If no filetype is given, it is deduced from the filename extension.
If the filename has no extension, the &#8216;gts&#8217; file type is used.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.toFormex">
<tt class="descname">toFormex</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.toFormex" title="Permalink to this definition">¶</a></dt>
<dd>Convert the surface to a Formex.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.scale">
<tt class="descname">scale</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy scaled with scale[i] in direction i.</p>
<p>The scale should be a list of 3 scaling factors for the 3 axis
directions, or a single scaling factor.
In the latter case, dir (a single axis number or a list) may be given
to specify the direction(s) to scale. The default is to produce a
homothetic scaling.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.translate">
<tt class="descname">translate</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translate a <tt class="xref docutils literal"><span class="pre">Coords</span></tt> object.</p>
<p>The translation vector can be specified in one of the following ways:</p>
<ul class="simple">
<li>an axis number (0,1,2),</li>
<li>a single translation vector,</li>
<li>an array of translation vectors.</li>
</ul>
<p>If an axis number is given, a unit vector in the direction of the
specified axis will be used.
If an array of translation vectors is given, it should be
broadcastable to the size of the <tt class="xref docutils literal"><span class="pre">Coords</span></tt> array.
If a distance value is given, the translation vector is multiplied
with this value before it is added to the coordinates.</p>
<p>Thus, the following lines are all equivalent:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">F</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span>
<span class="n">F</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span><span class="mf">1</span><span class="p">)</span>
<span class="n">F</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mf">0</span><span class="p">,</span><span class="mf">1</span><span class="p">,</span><span class="mf">0</span><span class="p">])</span>
<span class="n">F</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="mf">0</span><span class="p">,</span><span class="mf">2</span><span class="p">,</span><span class="mf">0</span><span class="p">],</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.rotate">
<tt class="descname">rotate</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy rotated over angle around axis.</p>
<p>The angle is specified in degrees.
The axis is either one of (0,1,2) designating the global axes,
or a vector specifying an axis through the origin.
If no axis is specified, rotation is around the 2(z)-axis. This is
convenient for working on 2D-structures.</p>
<p>As a convenience, the user may also specify a 3x3 rotation matrix,
in which case the function rotate(mat) is equivalent to affine(mat).</p>
<p>All rotations are performed around the point [0,0,0], unless a
rotation origin is specified in the argument &#8216;around&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.shear">
<tt class="descname">shear</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.shear" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy skewed in the direction dir of plane (dir,dir1).</p>
<p>The coordinate dir is replaced with (dir + skew * dir1).</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.reflect">
<tt class="descname">reflect</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.reflect" title="Permalink to this definition">¶</a></dt>
<dd><p>Reflect the coordinates in direction dir against plane at pos.</p>
<p>Default position of the plane is through the origin.
Default mirror direction is the z-direction.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.affine">
<tt class="descname">affine</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a general affine transform of the <tt class="xref docutils literal"><span class="pre">Coords</span></tt> object.</p>
<p><cite>mat</cite>: a 3x3 float matrix</p>
<p><cite>vec</cite>: a length 3 list or array of floats</p>
<p>The returned object has coordinates given by <tt class="docutils literal"><span class="pre">self</span> <span class="pre">*</span> <span class="pre">mat</span> <span class="pre">+</span> <span class="pre">vec</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.avgVertexNormals">
<tt class="descname">avgVertexNormals</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.avgVertexNormals" title="Permalink to this definition">¶</a></dt>
<dd>Compute the average normals at the vertices.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.areaNormals">
<tt class="descname">areaNormals</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.areaNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the area and normal vectors of the surface triangles.</p>
<p>The normal vectors are normalized.
The area is always positive.</p>
<p>The values are returned and saved in the object.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.facetArea">
<tt class="descname">facetArea</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.facetArea" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.area">
<tt class="descname">area</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.area" title="Permalink to this definition">¶</a></dt>
<dd>Return the area of the surface</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.volume">
<tt class="descname">volume</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the enclosed volume of the surface.</p>
<p>This will only be correct if the surface is a closed manifold.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.curvature">
<tt class="descname">curvature</tt><big>(</big><em>neighbours=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the curvature parameters at the nodes.</p>
<p>The n-ring neighbourhood of the nodes is used (n=neighbours).
Eight values are returned: the Gaussian and mean curvature, the
shape index, the curvedness, the principal curvatures and the
principal directions.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.edgeConnections">
<tt class="descname">edgeConnections</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.edgeConnections" title="Permalink to this definition">¶</a></dt>
<dd>Find the elems connected to edges.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nodeConnections">
<tt class="descname">nodeConnections</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nodeConnections" title="Permalink to this definition">¶</a></dt>
<dd>Find the elems connected to nodes.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nEdgeConnected">
<tt class="descname">nEdgeConnected</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nEdgeConnected" title="Permalink to this definition">¶</a></dt>
<dd>Find the number of elems connected to edges.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nNodeConnected">
<tt class="descname">nNodeConnected</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nNodeConnected" title="Permalink to this definition">¶</a></dt>
<dd>Find the number of elems connected to nodes.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.edgeAdjacency">
<tt class="descname">edgeAdjacency</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.edgeAdjacency" title="Permalink to this definition">¶</a></dt>
<dd>Find the elems adjacent to elems via an edge.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nEdgeAdjacent">
<tt class="descname">nEdgeAdjacent</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nEdgeAdjacent" title="Permalink to this definition">¶</a></dt>
<dd>Find the number of adjacent elems.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nodeAdjacency">
<tt class="descname">nodeAdjacency</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nodeAdjacency" title="Permalink to this definition">¶</a></dt>
<dd>Find the elems adjacent to elems via one or two nodes.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nNodeAdjacent">
<tt class="descname">nNodeAdjacent</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.nNodeAdjacent" title="Permalink to this definition">¶</a></dt>
<dd>Find the number of adjacent elems.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.surfaceType">
<tt class="descname">surfaceType</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.surfaceType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.borderEdges">
<tt class="descname">borderEdges</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.borderEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect the border elements of TriSurface.</p>
<p>The border elements are the edges having less than 2 connected elements.
Returns True where edge is on the border.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.borderEdgeNrs">
<tt class="descname">borderEdgeNrs</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.borderEdgeNrs" title="Permalink to this definition">¶</a></dt>
<dd>Returns the numbers of the border edges.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.borderNodeNrs">
<tt class="descname">borderNodeNrs</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.borderNodeNrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect the border nodes of TriSurface.</p>
<p>The border nodes are the vertices belonging to the border edges.
Returns a list of vertex numbers.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.isManifold">
<tt class="descname">isManifold</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.isManifold" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.isClosedManifold">
<tt class="descname">isClosedManifold</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.isClosedManifold" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.checkBorder">
<tt class="descname">checkBorder</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.checkBorder" title="Permalink to this definition">¶</a></dt>
<dd>Return the border of TriSurface as a set of segments.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.fillBorder">
<tt class="descname">fillBorder</tt><big>(</big><em>method=0</em><big>)</big><a class="headerlink" href="#surface.TriSurface.fillBorder" title="Permalink to this definition">¶</a></dt>
<dd><p>If the surface has a single closed border, fill it.</p>
<p>Filling the border is done by adding a single point inside
the border and connectin it with all border segments.
This works well if the border is smooth and nearly planar.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.border">
<tt class="descname">border</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.border" title="Permalink to this definition">¶</a></dt>
<dd>Return the border of TriSurface as a Plex-2 Formex.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.edgeCosAngles">
<tt class="descname">edgeCosAngles</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.edgeCosAngles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cos of the angles over all edges.</p>
<p>The surface should be a manifold (max. 2 elements per edge).
Edges with only one element get angles = 1.0.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.edgeAngles">
<tt class="descname">edgeAngles</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.edgeAngles" title="Permalink to this definition">¶</a></dt>
<dd>Return the angles over all edges (in degrees).</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.data">
<tt class="descname">data</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.data" title="Permalink to this definition">¶</a></dt>
<dd>Compute data for all edges and faces.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.aspectRatio">
<tt class="descname">aspectRatio</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.aspectRatio" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.smallestAltitude">
<tt class="descname">smallestAltitude</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.smallestAltitude" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.longestEdge">
<tt class="descname">longestEdge</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.longestEdge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.shortestEdge">
<tt class="descname">shortestEdge</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.shortestEdge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.stats">
<tt class="descname">stats</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.stats" title="Permalink to this definition">¶</a></dt>
<dd>Return a text with full statistics.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.edgeFront">
<tt class="descname">edgeFront</tt><big>(</big><em>startat=0</em>, <em>okedges=None</em>, <em>front_increment=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.edgeFront" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator function returning the frontal elements.</p>
<p>startat is an element number or list of numbers of the starting front.
On first call, this function returns the starting front.
Each next() call returns the next front.
front_increment determines haw the property increases at each
frontal step. There is an extra increment +1 at each start of
a new part. Thus, the start of a new part can always be detected
by a front not having the property of the previous plus front_increment.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.nodeFront">
<tt class="descname">nodeFront</tt><big>(</big><em>startat=0</em>, <em>front_increment=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.nodeFront" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator function returning the frontal elements.</p>
<p>startat is an element number or list of numbers of the starting front.
On first call, this function returns the starting front.
Each next() call returns the next front.</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.walkEdgeFront">
<tt class="descname">walkEdgeFront</tt><big>(</big><em>startat=0</em>, <em>nsteps=-1</em>, <em>okedges=None</em>, <em>front_increment=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.walkEdgeFront" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.walkNodeFront">
<tt class="descname">walkNodeFront</tt><big>(</big><em>startat=0</em>, <em>nsteps=-1</em>, <em>front_increment=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.walkNodeFront" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.growSelection">
<tt class="descname">growSelection</tt><big>(</big><em>sel</em>, <em>mode='node'</em>, <em>nsteps=1</em><big>)</big><a class="headerlink" href="#surface.TriSurface.growSelection" title="Permalink to this definition">¶</a></dt>
<dd><p>Grows a selection of a surface.</p>
<p><cite>p</cite> is a single element number or a list of numbers.
The return value is a list of element numbers obtained by
growing the front <cite>nsteps</cite> times.
The <cite>mode</cite> argument specifies how a single frontal step is done:</p>
<ul class="simple">
<li>&#8216;node&#8217; : include all elements that have a node in common,</li>
<li>&#8216;edge&#8217; : include all elements that have an edge in common.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.partitionByEdgeFront">
<tt class="descname">partitionByEdgeFront</tt><big>(</big><em>okedges</em>, <em>firstprop=0</em>, <em>startat=0</em><big>)</big><a class="headerlink" href="#surface.TriSurface.partitionByEdgeFront" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects different parts of the surface using a frontal method.</p>
<p>okedges flags the edges where the two adjacent triangles are to be
in the same part of the surface.
startat is a list of elements that are in the first part. 
The partitioning is returned as a property type array having a value
corresponding to the part number. The lowest property number will be
firstprop</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.partitionByNodeFront">
<tt class="descname">partitionByNodeFront</tt><big>(</big><em>firstprop=0</em>, <em>startat=0</em><big>)</big><a class="headerlink" href="#surface.TriSurface.partitionByNodeFront" title="Permalink to this definition">¶</a></dt>
<dd><p>Detects different parts of the surface using a frontal method.</p>
<p>okedges flags the edges where the two adjacent triangles are to be
in the same part of the surface.
startat is a list of elements that are in the first part. 
The partitioning is returned as a property type array having a value
corresponding to the part number. The lowest property number will be
firstprop</p>
</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.partitionByConnection">
<tt class="descname">partitionByConnection</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.TriSurface.partitionByConnection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.partitionByAngle">
<tt class="descname">partitionByAngle</tt><big>(</big><em>angle=180.</em>, <em>firstprop=0</em>, <em>startat=0</em><big>)</big><a class="headerlink" href="#surface.TriSurface.partitionByAngle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="surface.TriSurface.cutWithPlane">
<tt class="descname">cutWithPlane</tt><big>(</big><em>None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.cutWithPlane" title="Permalink to this definition">¶</a></dt>
<dd>Cut a surface with a plane.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.connectedElements">
<tt class="descname">connectedElements</tt><big>(</big><em>target</em>, <em>elemlist=None</em><big>)</big><a class="headerlink" href="#surface.TriSurface.connectedElements" title="Permalink to this definition">¶</a></dt>
<dd>Return the elements from list connected with target</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.smoothLowPass">
<tt class="descname">smoothLowPass</tt><big>(</big><em>n_iterations=2</em>, <em>lambda_value=0.5</em><big>)</big><a class="headerlink" href="#surface.TriSurface.smoothLowPass" title="Permalink to this definition">¶</a></dt>
<dd>Smooth the surface using a low-pass filter.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.smoothLaplaceHC">
<tt class="descname">smoothLaplaceHC</tt><big>(</big><em>n_iterations=2</em>, <em>lambda_value=0.5</em>, <em>alpha=0.</em>, <em>beta=0.2</em><big>)</big><a class="headerlink" href="#surface.TriSurface.smoothLaplaceHC" title="Permalink to this definition">¶</a></dt>
<dd>Smooth the surface using a Laplace filter and HC algorithm.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.check">
<tt class="descname">check</tt><big>(</big><em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.check" title="Permalink to this definition">¶</a></dt>
<dd>Check the surface using gtscheck.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.split">
<tt class="descname">split</tt><big>(</big><em>base</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.split" title="Permalink to this definition">¶</a></dt>
<dd>Check the surface using gtscheck.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.coarsen">
<tt class="descname">coarsen</tt><big>(</big><em>min_edges=None</em>, <em>max_cost=None</em>, <em>mid_vertex=False</em>, <em>length_cost=False</em>, <em>max_fold=1.0</em>, <em>volume_weight=0.5</em>, <em>boundary_weight=0.5</em>, <em>shape_weight=0.0</em>, <em>progressive=False</em>, <em>log=False</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.coarsen" title="Permalink to this definition">¶</a></dt>
<dd>Coarsen the surface using gtscoarsen.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.refine">
<tt class="descname">refine</tt><big>(</big><em>max_edges=None</em>, <em>min_cost=None</em>, <em>log=False</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.refine" title="Permalink to this definition">¶</a></dt>
<dd>Refine the surface using gtsrefine.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.smooth">
<tt class="descname">smooth</tt><big>(</big><em>lambda_value=0.5</em>, <em>n_iterations=2</em>, <em>fold_smoothing=None</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.smooth" title="Permalink to this definition">¶</a></dt>
<dd>Smooth the surface using gtssmooth.</dd></dl>

<dl class="method">
<dt id="surface.TriSurface.boolean">
<tt class="descname">boolean</tt><big>(</big><em>surf</em>, <em>op</em>, <em>inter=False</em>, <em>check=False</em>, <em>verbose=False</em><big>)</big><a class="headerlink" href="#surface.TriSurface.boolean" title="Permalink to this definition">¶</a></dt>
<dd>Perform a boolean operation with surface surf.</dd></dl>

</dd></dl>

<p><strong>Functions defined in the module surface</strong></p>
<blockquote>
<dl class="function">
<dt id="surface.areaNormals">
<tt class="descclassname">surface.</tt><tt class="descname">areaNormals</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#surface.areaNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the area and normal vectors of a collection of triangles.</p>
<p>x is an (ntri,3,3) array of coordinates.</p>
<p>Returns a tuple of areas,normals.
The normal vectors are normalized.
The area is always positive.</p>
</dd></dl>

<dl class="function">
<dt id="surface.stlConvert">
<tt class="descclassname">surface.</tt><tt class="descname">stlConvert</tt><big>(</big><em>stlname</em>, <em>outname=None</em>, <em>options='-d'</em><big>)</big><a class="headerlink" href="#surface.stlConvert" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an .stl file to .off or .gts format.</p>
<p>If outname is given, it is either &#8216;.off&#8217; or &#8216;.gts&#8217; or a filename ending
on one of these extensions. If it is only an extension, the stlname will
be used with extension changed.</p>
<p>If the outname file exists and its mtime is more recent than the stlname,
the outname file is considered uptodate and the conversion programwill
not be run.</p>
<p>The conversion program will be choosen depending on the extension.
This uses the external commands &#8216;admesh&#8217; or &#8216;stl2gts&#8217;.</p>
<p>The return value is a tuple of the output file name, the conversion
program exit code (0 if succesful) and the stdout of the conversion
program (or a &#8216;file is already uptodate&#8217; message).</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_gts">
<tt class="descclassname">surface.</tt><tt class="descname">read_gts</tt><big>(</big><em>fn</em><big>)</big><a class="headerlink" href="#surface.read_gts" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a GTS surface mesh.</p>
<p>Return a coords,edges,faces tuple.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_off">
<tt class="descclassname">surface.</tt><tt class="descname">read_off</tt><big>(</big><em>fn</em><big>)</big><a class="headerlink" href="#surface.read_off" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an OFF surface mesh.</p>
<p>The mesh should consist of only triangles!
Returns a nodes,elems tuple.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_stl">
<tt class="descclassname">surface.</tt><tt class="descname">read_stl</tt><big>(</big><em>fn</em>, <em>intermediate=None</em><big>)</big><a class="headerlink" href="#surface.read_stl" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a surface from .stl file.</p>
<p>This is done by first coverting the .stl to .gts or .off format.
The name of the intermediate file may be specified. If not, it will be
generated by changing the extension of fn to &#8216;.gts&#8217; or &#8216;.off&#8217; depending
on the setting of the &#8216;surface/stlread&#8217; config setting.</p>
<p>Return a coords,edges,faces or a coords,elems tuple, depending on the
intermediate format.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_gambit_neutral">
<tt class="descclassname">surface.</tt><tt class="descname">read_gambit_neutral</tt><big>(</big><em>fn</em><big>)</big><a class="headerlink" href="#surface.read_gambit_neutral" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a triangular surface mesh in Gambit neutral format.</p>
<p>The .neu file nodes are numbered from 1!
Returns a nodes,elems tuple.</p>
</dd></dl>

<dl class="function">
<dt id="surface.write_gts">
<tt class="descclassname">surface.</tt><tt class="descname">write_gts</tt><big>(</big><em>fn</em>, <em>nodes</em>, <em>edges</em>, <em>faces</em><big>)</big><a class="headerlink" href="#surface.write_gts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="surface.write_stla">
<tt class="descclassname">surface.</tt><tt class="descname">write_stla</tt><big>(</big><em>f</em>, <em>x</em><big>)</big><a class="headerlink" href="#surface.write_stla" title="Permalink to this definition">¶</a></dt>
<dd>Export an x[n,3,3] float array as an ascii .stl file.</dd></dl>

<dl class="function">
<dt id="surface.write_stlb">
<tt class="descclassname">surface.</tt><tt class="descname">write_stlb</tt><big>(</big><em>f</em>, <em>x</em><big>)</big><a class="headerlink" href="#surface.write_stlb" title="Permalink to this definition">¶</a></dt>
<dd>Export an x[n,3,3] float array as an binary .stl file.</dd></dl>

<dl class="function">
<dt id="surface.write_gambit_neutral">
<tt class="descclassname">surface.</tt><tt class="descname">write_gambit_neutral</tt><big>(</big><em>fn</em>, <em>nodes</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.write_gambit_neutral" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="surface.write_off">
<tt class="descclassname">surface.</tt><tt class="descname">write_off</tt><big>(</big><em>fn</em>, <em>nodes</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.write_off" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="surface.write_smesh">
<tt class="descclassname">surface.</tt><tt class="descname">write_smesh</tt><big>(</big><em>fn</em>, <em>nodes</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.write_smesh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="surface.surface_volume">
<tt class="descclassname">surface.</tt><tt class="descname">surface_volume</tt><big>(</big><em>x</em>, <em>pt=None</em><big>)</big><a class="headerlink" href="#surface.surface_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the volume inside a 3-plex Formex.</p>
<p>For each element of Formex, return the volume of the tetrahedron
formed by the point pt (default the center of x) and the 3 points
of the element.</p>
</dd></dl>

<dl class="function">
<dt id="surface.curvature">
<tt class="descclassname">surface.</tt><tt class="descname">curvature</tt><big>(</big><em>coords</em>, <em>elems</em>, <em>edges</em>, <em>neighbours=1</em><big>)</big><a class="headerlink" href="#surface.curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate curvature parameters</p>
<p>(according to Dong and Wang 2005;
Koenderink and Van Doorn 1992).
The n-ring neighbourhood of the nodes is used (n=neighbours).
Eight values are returned: the Gaussian and mean curvature, the
shape index, the curvedness, the principal curvatures and the
principal directions.</p>
</dd></dl>

<dl class="function">
<dt id="surface.surfaceInsideLoop">
<tt class="descclassname">surface.</tt><tt class="descname">surfaceInsideLoop</tt><big>(</big><em>coords</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.surfaceInsideLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a surface inside a closed curve defined by coords and elems.</p>
<p>coords is a set of coordinates.
elems is an (nsegments,2) shaped connectivity array defining a set of line
segments forming a closed loop.</p>
<p>The return value is coords,elems tuple where
coords has one more point: the center of th original coords
elems is (nsegment,3) and defines triangles describing a surface inside
the original curve.</p>
</dd></dl>

<dl class="function">
<dt id="surface.fillHole">
<tt class="descclassname">surface.</tt><tt class="descname">fillHole</tt><big>(</big><em>coords</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.fillHole" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill a hole surrounded by the border defined by coords and elems.</p>
<p>Coords is a (npoints,3) shaped array of floats.
Elems is a (nelems,2) shaped array of integers representing the border
element numbers and must be ordered.</p>
</dd></dl>

<dl class="function">
<dt id="surface.create_border_triangle">
<tt class="descclassname">surface.</tt><tt class="descname">create_border_triangle</tt><big>(</big><em>coords</em>, <em>elems</em><big>)</big><a class="headerlink" href="#surface.create_border_triangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a triangle within a border.</p>
<p>The triangle is created from the two border elements with
the sharpest angle.
Coords is a (npoints,3) shaped array of floats.
Elems is a (nelems,2) shaped array of integers representing
the border element numbers and must be ordered.
A list of two objects is returned: the new border elements and the triangle.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_error">
<tt class="descclassname">surface.</tt><tt class="descname">read_error</tt><big>(</big><em>cnt</em>, <em>line</em><big>)</big><a class="headerlink" href="#surface.read_error" title="Permalink to this definition">¶</a></dt>
<dd>Raise an error on reading the stl file.</dd></dl>

<dl class="function">
<dt id="surface.degenerate">
<tt class="descclassname">surface.</tt><tt class="descname">degenerate</tt><big>(</big><em>area</em>, <em>norm</em><big>)</big><a class="headerlink" href="#surface.degenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the degenerate faces according to area and normals.</p>
<p>A face is degenerate if its surface is less or equal to zero or the
normal has a nan.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_stla">
<tt class="descclassname">surface.</tt><tt class="descname">read_stla</tt><big>(</big><em>fn</em>, <em>dtype=Float</em>, <em>large=False</em>, <em>guess=True</em><big>)</big><a class="headerlink" href="#surface.read_stla" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an ascii .stl file into an [n,3,3] float array.</p>
<p>If the .stl is large, read_ascii_large() is recommended, as it is
a lot faster.</p>
</dd></dl>

<dl class="function">
<dt id="surface.read_ascii_large">
<tt class="descclassname">surface.</tt><tt class="descname">read_ascii_large</tt><big>(</big><em>fn</em>, <em>dtype=Float</em><big>)</big><a class="headerlink" href="#surface.read_ascii_large" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an ascii .stl file into an [n,3,3] float array.</p>
<p>This is an alternative for read_ascii, which is a lot faster on large
STL models.
It requires the &#8216;awk&#8217; command though, so is probably only useful on
Linux/UNIX. It works by first transforming  the input file to a
.nodes file and then reading it through numpy&#8217;s fromfile() function.</p>
</dd></dl>

<dl class="function">
<dt id="surface.off_to_tet">
<tt class="descclassname">surface.</tt><tt class="descname">off_to_tet</tt><big>(</big><em>fn</em><big>)</big><a class="headerlink" href="#surface.off_to_tet" title="Permalink to this definition">¶</a></dt>
<dd>Transform an .off model to tetgen (.node/.smesh) format.</dd></dl>

<dl class="function">
<dt id="surface.find_row">
<tt class="descclassname">surface.</tt><tt class="descname">find_row</tt><big>(</big><em>mat</em>, <em>row</em>, <em>nmatch=None</em><big>)</big><a class="headerlink" href="#surface.find_row" title="Permalink to this definition">¶</a></dt>
<dd>Find all rows in matrix matching given row.</dd></dl>

<dl class="function">
<dt id="surface.find_nodes">
<tt class="descclassname">surface.</tt><tt class="descname">find_nodes</tt><big>(</big><em>nodes</em>, <em>coords</em><big>)</big><a class="headerlink" href="#surface.find_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Find nodes with given coordinates in a node set.</p>
<p>nodes is a (nnodes,3) float array of coordinates.
coords is a (npts,3) float array of coordinates.</p>
<p>Returns a (n,) integer array with ALL the node numbers matching EXACTLY
ALL the coordinates of ANY of the given points.</p>
</dd></dl>

<dl class="function">
<dt id="surface.find_first_nodes">
<tt class="descclassname">surface.</tt><tt class="descname">find_first_nodes</tt><big>(</big><em>nodes</em>, <em>coords</em><big>)</big><a class="headerlink" href="#surface.find_first_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Find nodes with given coordinates in a node set.</p>
<p>nodes is a (nnodes,3) float array of coordinates.
coords is a (npts,3) float array of coordinates.</p>
<p>Returns a (n,) integer array with THE FIRST node number matching EXACTLY
ALL the coordinates of EACH of the given points.</p>
</dd></dl>

<dl class="function">
<dt id="surface.find_triangles">
<tt class="descclassname">surface.</tt><tt class="descname">find_triangles</tt><big>(</big><em>elems</em>, <em>triangles</em><big>)</big><a class="headerlink" href="#surface.find_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Find triangles with given node numbers in a surface mesh.</p>
<p>elems is a (nelems,3) integer array of triangles.
triangles is a (ntri,3) integer array of triangles to find.</p>
<p>Returns a (ntri,) integer array with the triangles numbers.</p>
</dd></dl>

<dl class="function">
<dt id="surface.remove_triangles">
<tt class="descclassname">surface.</tt><tt class="descname">remove_triangles</tt><big>(</big><em>elems</em>, <em>remove</em><big>)</big><a class="headerlink" href="#surface.remove_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove triangles from a surface mesh.</p>
<p>elems is a (nelems,3) integer array of triangles.
remove is a (nremove,3) integer array of triangles to remove.</p>
<p>Returns a (nelems-nremove,3) integer array with the triangles of
nelems where the triangles of remove have been removed.</p>
</dd></dl>

<dl class="function">
<dt id="surface.Rectangle">
<tt class="descclassname">surface.</tt><tt class="descname">Rectangle</tt><big>(</big><em>nx</em>, <em>ny</em><big>)</big><a class="headerlink" href="#surface.Rectangle" title="Permalink to this definition">¶</a></dt>
<dd>Create a plane rectangular surface consisting of a nx,ny grid.</dd></dl>

<dl class="function">
<dt id="surface.Cube">
<tt class="descclassname">surface.</tt><tt class="descname">Cube</tt><big>(</big><big>)</big><a class="headerlink" href="#surface.Cube" title="Permalink to this definition">¶</a></dt>
<dd>Create a surface in the form of a cube</dd></dl>

<dl class="function">
<dt id="surface.Sphere">
<tt class="descclassname">surface.</tt><tt class="descname">Sphere</tt><big>(</big><em>level=4</em>, <em>verbose=False</em>, <em>filename=None</em><big>)</big><a class="headerlink" href="#surface.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a spherical surface by caling the gtssphere command.</p>
<p>If a filename is given, it is stored under that name, else a temporary
file is created.
Beware: this may take a lot of time if level is 8 or higher.</p>
</dd></dl>

</blockquote>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
        <p class="logo"><a href="http://pyformex.org/">
        <img class="logo" src="../_static/pyformex_logo.png" alt="Logo"/>
        </a></p>
    <h3><a href="../index.html">Documentation</a></h3>
            <h4>Previous topic</h4>
            <p class="topless"><a href="curve.html"
                                  title="previous chapter">28. <tt class="docutils literal docutils literal docutils literal"><span class="pre">curve</span></tt> &#8212; Definition of curves in pyFormex.</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="isopar.html"
                                  title="next chapter">30. <tt class="docutils literal docutils literal docutils literal"><span class="pre">isopar</span></tt> &#8212; Isoparametric transformations</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/ref/surface.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="isopar.html" title="30. isopar — Isoparametric transformations"
             >next</a> |</li>
        <li class="right" >
          <a href="curve.html" title="28. curve — Definition of curves in pyFormex."
             >previous</a> |</li>
    <li><a href="http://pyformex.org/">pyFormex Home</a> &gt;</li>
    
        <li><a href="../index.html">pyFormex Documentation</a> &gt;</li>

          <li><a href="../refman.html" >pyFormex reference manual</a> &gt;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2009, Benedict Verhegghe.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.3.
    </div>
  </body>
</html>