% pyformex manual --- coords
% $Id$
% (C) B.Verhegghe

\section{coords}
\label{sec:coords}

The \module{coords} module implements a data class for storing large sets of 3D coordinates and provides a extensive set of methods for transforming these coordinates. The \class{Coords} class is used by other classes, such as \class{Formex} and \class{Surface}, which thus inherit the same transformation capabilities. In future, other geometrical data models may (and should) also derive from the \class{Coords} class. While the user will mostly use the higher level classes, he might occasionally find good reason to use the \class{Coords} class directly as well.

\subsection{The Coords class}
This class represents a structured set of 3D coordinates.
As the \class{Coords} class was written purposely to implement the \class{Formex} class, most of its features are exactly mirrored in the \class{Formex} class, and we refer to its description in \ref{sec:formex} for full details of all methods. Here we will merely point out the difference between a general instance of the \class{Coords} class and the \var{f} attribute of a \class{Formex} instance. 
The \class{Formex} class is always a 2-dimensional collection of \Code{(nelems*nplex)} points, each with 3 coordinates. A \class{Coords} object however is a collection of points having any possible shape.

Coords is implemented as a Numerical Python array with a length of its
last axis equal to 3.
Each set of 3 values along the last axis represents a single point in 3D.

The datatype should be a float type; default is Float.

\begin{classdesc}{Coords}{data=None,dtyp=None,copy=False}
Create a new instance of class Coords.

If no data are given, a single point (0.,0.,0.) will be created.
If specified, data should evaluate to an (...,3) shaped array of floats.
If copy==True, the data are copied.
If no dtype is given that of data are used, or float32 by default.

\end{classdesc}


\subsection{Methods returning information}

\begin{methoddesc}{points}{}
Return the data as a simple set of points.

This reshapes the array to a 2-dimensional array, flattening
the structure of the points.
\end{methoddesc}

    
\begin{methoddesc}{pshape}{}
Return shape of the points array.

This is the shape of the Coords array with last axis removed.

The full shape of the \class{Coords} array can be obtained from its \var{shape} attribute.\footnote{Note that this differs from the \class{Formex} class, where you have to use a call to the shape() method.} 
\end{methoddesc}


\begin{methoddesc}{npoints}{}
Return the total number of points.
\end{methoddesc}
\begin{methoddesc}{x}{}
  Return the x-plane.
\end{methoddesc}
\begin{methoddesc}{y}{}
  Return the y-plane.
\end{methoddesc}
\begin{methoddesc}{z}{}
  Return the z-plane.
\end{methoddesc}

\begin{methoddesc}{bbox}{}
Return the bounding box of a set of points.

        The bounding box is the smallest rectangular volume in global
        coordinates, such at no points are outside the box.
        It is returned as a Coords object with shape (2,3): the first row
        holds the minimal coordinates and the second row the maximal.
\end{methoddesc}

\begin{methoddesc}{center}{}
Return the center of the Coords.

        The center of a Coords is the center of its bbox().
        The return value is a (3,) shaped Coords object.\end{methoddesc}

\begin{methoddesc}{centroid}{}
Return the centroid of the Coords.

        The centroid of a Coords is the point whose coordinates
        are the mean values of all points.
        The return value is a (3,) shaped Coords object.\end{methoddesc}

\begin{methoddesc}{sizes}{}
Returns an array with shape (3,) holding the length of the bbox along the 3 axes.
\end{methoddesc}

\begin{methoddesc}{diagonal}{}
Return the length of the diagonal of the bbox().
\end{methoddesc}

\begin{methoddesc}{bsphere}{}
Return the diameter of the bounding sphere of the Coords.

The bounding sphere is the smallest sphere with center in the \function{center()} of the Coords, and such that no points of the Coords are lying outside the sphere. It is not necessarily the smallest sphere surrounding all points of the Coords.
\end{methoddesc}


\begin{methoddesc}{distanceFromPlane}{p,n}
    Return the distance from the plane (p,n) for all points of the Coords.

    p is a point specified by 3 coordinates.
    n is the normal vector to a plane, specified by 3 components.

    The return value is a [...] shaped array with the distance of
    each point to the plane containing the point  p and having normal n.
    Distance values are positive if the point is on the side of the
    plane indicated by the positive normal.
\end{methoddesc}


\begin{methoddesc}{distanceFromLine}{p,q}
    Return the distance from the line (p,q) for all points of the Coords.

    p and q are two points specified by 3 coordinates.

    The return value is a [...] shaped array with the distance of
    each point to the line through p and q.
    All distance values are positive or zero.
\end{methoddesc}


\begin{methoddesc}{distanceFromPoint}{p}
    Return the distance from the point p for all points of the Coords.

    p is a point specified by 3 coordinates.

    The return value is a [...] shaped array with the distance of
    each point to the line through p and q.
    All distance values are positive or zero.
\end{methoddesc}


    def test(self,dir=0,min=None,max=None):
        """Flag points having coordinates between min and max.

        This function is very convenient in clipping a Coords in a specified
        direction. It returns a 1D integer array flagging (with a value 1 or
        True) the elements having nodal coordinates in the required range.
        Use where(result) to get a list of element numbers passing the test.
        Or directly use clip() or cclip() to create the clipped Coords.
        
        The test plane can be define in two ways depending on the value of dir.
        If dir == 0, 1 or 2, it specifies a global axis and min and max are
        the minimum and maximum values for the coordinates along that axis.
        Default is the 0 (or x) direction.

        Else, dir should be compaitble with a (3,) shaped array and specifies
        the direction of the normal on the planes. In this case, min and max
        are points and should also evaluate to (3,) shaped arrays.
        
        Nodes specifies which nodes are taken into account in the comparisons.
        It should be one of the following:
        - a single (integer) node number (< the number of nodes)
        - a list of node numbers
        - one of the special strings: 'all', 'any', 'none'
        The default ('all') will flag all the elements that have all their
        nodes between the planes x=min and x=max, i.e. the elements that
        fall completely between these planes. One of the two clipping planes
        may be left unspecified.


\begin{methoddesc}{fprint}{fmt="\%10.3e \%10.3e \%10.3e"}
Prints all the points of the formex with the specified format. The format should hold three formatting codes, for the three coordinates of the point. 
\end{methoddesc}


\begin{methoddesc}{test}{nodes='all',dir=0,min=None,max=None}
Flag elements having nodal coordinates between min and max.

This function is very convenient in clipping a Formex in one of
the coordinate directions. It returns a 1D integer array flagging
(with a value 1 or True) the elements having points with coordinates in the
specified range.
Use \Code{where(result)} to get a list of element numbers passing the test.
Or directly use the \Code{clip()} or \Code{cclip()} methods to create the clipped Formex.
       
The test plane can be defined in two ways, depending on the value of dir.
If \var{dir} is a single integer (0, 1 or 2), it specifies a global axis
and \var{min} and \var{max} are the minimum and maximum values for the
coordinates along that axis.
Default is the 0 (or x) direction.
Else, \var{dir} should be compatible with a (3,) shaped array and specifies
the direction of the normal on the planes. In this case, \var{min} and \var{max}
are points and should also evaluate to (3,) shaped arrays.

xmin,xmax are there minimum and maximum values required for the
coordinates in direction dir (default is the x or 0 direction).

\var{nodes} specifies which points are taken into account in the comparisons.
It should be one of the following:
\begin{itemize}
\item a single (integer) node number (< the number of points in an element)
\item a list of point numbers
\item one of the special strings: 'all', 'any', 'none'
\end{itemize}
The default ('all') will flag all the elements that have all their
points between the planes x=min and x=max, i.e. the elements that
fall completely between these planes. One of the two clipping planes
may be left unspecified.
\end{methoddesc}


\subsection{Clipping methods}
These methods can be use to make a selection of elements based on their nodal coordinates. The heart is the function

If you want to have a list of the element numbers that satisfy the specified conditions, you can use numpy's where function on the result. Thus \Code{where(F.where(min=1.0))} returns a list with all elements lying right of the plane \Code{x=1.0}.

\begin{methoddesc}{clip}{t}
Returns a Formex with all the elements where t>0.

t should be a 1-D integer array with length equal to the number
of elements of the formex.
The resulting Formex will contain all elements where t > 0.
This is a convenience function for the user, equivalent to
\Code{F.select(t>0)}.
\end{methoddesc}

\begin{methoddesc}{cclip}{t}
This is the complement of clip, returning a Formex where t<=0.
\end{methoddesc}

    def fuse(self,nodesperbox=1,shift=0.5,rtol=1.e-5,atol=1.e-5):
        """Find (almost) identical nodes and return a compressed set.

        This method finds the points that are very close and replaces them
        with a single point. The return value is a tuple of two arrays:
        - the unique points as a Coords object,
        - an integer (nnod) array holding an index in the unique
        coordinates array for each of the original nodes. This index will
        have the same shape as the pshape() of the coords array.

        The procedure works by first dividing the 3D space in a number of
        equally sized boxes, with a mean population of nodesperbox.
        The boxes are numbered in the 3 directions and a unique integer scalar
        is computed, that is then used to sort the nodes.
        Then only nodes inside the same box are compared on almost equal
        coordinates, using the numpy allclose() function. Two coordinates are
        considered close if they are within a relative tolerance rtol or absolute
        tolerance atol. See numpy for detail. The default atol is set larger than
        in numpy, because pyformex typically runs with single precision.
        Close nodes are replaced by a single one.

        Currently the procedure does not guarantee to find all close nodes:
        two close nodes might be in adjacent boxes. The performance hit for
        testing adjacent boxes is rather high, and the probability of separating
        two close nodes with the computed box limits is very small. Nevertheless
        we intend to access this problem by repeating the procedure with the
        boxes shifted in space.
 

\subsection{Coordinate transformations}

The following coordinate transorming methods are defined in the Coords class.
They implement the functionality of the \class{Formex} methods with the same name. We refer the reader to section~\ref{sec:formex} for a detailed description of these methods. 
\begin{methoddesc}{scale}{scale}
\end{methoddesc}

\begin{methoddesc}{translate}{dir,distance=None}
\end{methoddesc}

\begin{methoddesc}{rotate}{angle,axis=2}
\end{methoddesc}

\begin{methoddesc}{shear}{dir,dir1,skew}
\end{methoddesc}

\begin{methoddesc}{reflect}{dir,pos=0}
\end{methoddesc}

\begin{methoddesc}{mirror}{dir,pos=0}
\end{methoddesc}

\begin{methoddesc}{affine}{mat,vec=None}
\end{methoddesc}


\begin{methoddesc}{cylindrical}{dir=[0,1,2],scale=[1.,1.,1.]}
\end{methoddesc}

\begin{methoddesc}{toCylindrical}{dir=[0,1,2]}
\end{methoddesc}

\begin{methoddesc}{spherical}{dir=[0,1,2],scale=[1.,1.,1.],colat=False}
\end{methoddesc}

\begin{methoddesc}{toSpherical}{dir=[0,1,2]}
\end{methoddesc}

\begin{methoddesc}{bump}{dir,a,func,dist=None}
\end{methoddesc}

\begin{methoddesc}{bump1}{dir,a,func,dist}
\end{methoddesc}

\begin{methoddesc}{bump2}{dir,a,func}
\end{methoddesc}

\begin{methoddesc}{map}{func}
\end{methoddesc}

\begin{methoddesc}{map1}{dir,func}
\end{methoddesc}

\begin{methoddesc}{mapd}{dir,func,point,dist=None}
\end{methoddesc}

\begin{methoddesc}{replace}{i,j,other=None}
\end{methoddesc}

\begin{methoddesc}{swapaxes}{i,j}
\end{methoddesc}

\begin{methoddesc}{rollAxes}{n=1}
\end{methoddesc}

\begin{methoddesc}{projectOnSphere}{radius,center=[0.,0.,0.]}
\end{methoddesc}


\subsection{Class methods}

The following class methods are defined for the \class{Coords} class.
These should be called as \Code{Coords.method()}.

\begin{methoddesc}{concatenate}{L}
Concatenate a list of Coords object.

 All Coords object in the list L should have the same shape
 except for the length of the first axis.
 This function is equivalent to the numpy concatenate, but makes
 sure the result is a Cooords object.

\classmethod
\end{methoddesc}

\begin{methoddesc}{fromfile}{*args}
Read a Coords from file.

        This convenience function uses the numpy fromfile function to read
        the coordinates from file.
        You just have to make sure that the coordinates are read in order
        (X,Y,Z) for subsequent points, and that the total number of
        coordinates read is a multiple of 3.

\classmethod
\end{methoddesc}


\begin{methoddesc}{interpolate}{F,G,div}
Create interpolations between two Coords.

        F and G are two Coords with the same shape.
        v is a list of floating point values.
        The result is the concatenation of the interpolations of F and G at all
        the values in div.
        An interpolation of F and G at value v is a Coords H where each
        coordinate Hijk is obtained from:  Hijk = Fijk + v * (Gijk-Fijk).
        Thus, a Coords interpolate(F,G,[0.,0.5,1.0]) will contain all points of
        F and G and all points with mean coordinates between those of F and G.

        As a convenience, if an integer is specified for div, it is taken as a
        number of divisions for the interval [0..1].
        Thus, interpolate(F,G,n) is equivalent with
        interpolate(F,G,arange(0,n+1)/float(n))

        The resulting Coords array has an extra axis (the first). Its shape is
        (n,) + F.shape, where n is the number of divisions.

\classmethod
\end{methoddesc}



\subsection{Non-member functions}
The following functions operate on or return Formex objects, but are not part of the Formex class.\footnote{They might be implemented as class methods in future releases.}


\begin{funcdesc}{interpolate}{F,G,div,swap=False}
Create interpolations between two formices.

\var{F} and \var{G} are two Formices with the same shape.
\var{v} is a list of floating point values.
The result is the concatenation of the interpolations of \var{F} and \var{G} at all the values in \var{div}.

An interpolation of \var{F} and \var{G} at value \var{v} is a Formex \var{H} where each coordinate \var{Hijk} is obtained from  \Code{Hijk = Fijk + v * (Gijk-Fijk)}.
Thus, a Formex \Code{interpolate(F,G,[0.,0.5,1.0])} will contain all elements
of \var{F} and \var{G} and all elements with mean coordinates between those of \var{F} and \var{G}.

As a convenience, if an integer is specified for \var{div}, it is taken as a
number of division for the interval [0..1].
Thus, \Code{interpolate(F,G,n)} is equivalent with
\Code{interpolate(F,G,arange(0,n+1)/float(n))}

The swap argument sets the order of the elements in the resulting Formex.
By default, if $n$ interpolations are created of an $m$-element Formex, the element order is in-Formex first ($n$ sequences of $m$ elements).
If \Code{swap==True}, the order is swapped and you get $m$ sequences of $n$
interpolations.
\end{funcdesc}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pyformex"
%%% End: 
